# 双臂机器人位姿转换

现在就是想把两个机械臂的坐标相互转换、或者转换到同一坐标系下。

## x, y, z坐标转换

设相机坐标系原点位置为$V$，机械臂手眼标定矩阵为$R$，机械臂基坐标系下末端位置为$W$

有公式：
$$W = R \cdot V \tag{1}$$

----

假设我们有两个机械臂，一个相机。
设相机坐标系原点位置为$V$，左臂手眼标定矩阵为$R_{left}$，机械臂基坐标系下末端位置为$W_{left}$,
右臂手眼标定矩阵为$R_{right}$，机械臂基坐标系下末端位置为$W_{right}$

则有：

$$W_{left} = R_{left} \cdot V \tag{2.1}$$

$$W_{right} = R_{right} \cdot V \tag{2.2}$$

由于相机只有一个，则$V$只有一个，我们可以利用2.1式将2.2式中的$V$消掉：

$$V = R_{left}' \cdot W_{left} \tag{2.3}$$

将2.3式代入到2.2式，则有：

$$W_{right} = R_{right} \cdot R_{left}' \cdot W_{left} \tag{2.4}$$

==注意：==

此时的$W_{right}$是四维向量$[x, y, z, 1]$。
目前为止没有涉及到旋转角`u, v, w`的计算和转换

==其实可以不用手眼矩阵来进行转换。==

首先手眼矩阵本身就有误差，而且误差再怎么控制都有2~3mm，如果我们有上面的方法来对左右臂坐标进行转换，那么由2.4式可得转换矩阵为

$$^{left}_{right}T = R_{right} \cdot R_{left}'$$

根据误差传播定律，两个机械臂的手眼矩阵的误差都将在转换矩阵$^{left}_{right}T$中得到放大。

但实际上我们可以不用通过两个机械臂的手眼矩阵来得到转换矩阵$^{left}_{right}T$

## u, v, w旋转角转换

首先我们知道u, v, w是可以通过旋转矩阵得到的

那我们先把旋转矩阵算出来

设$R_{right}$为右臂末端相对于右臂基座的旋转角， $R_{left}$为左臂末端相对于左臂基座的旋转角，$^{left}_{right}T$则是左臂基座坐标系相对于右臂基座坐标系的转换矩阵

则我们可以得到类似2.4式的式子：

$$R_{right} = ^{left}_{right}T \cdot R_{left}$$

其中已知$^{right}_{left}R$为左臂基座相对于右臂基座的旋转矩阵

$$^{right}_{left}R = 
\begin{bmatrix}
   1 & 0 & 0  \\
   0 & \cos \pi & -\sin \pi \\
   0 & \sin \pi & \cos \pi
\end{bmatrix}
$$

即
$$R_{right} = 
\begin{bmatrix}
   1 & 0 & 0  \\
   0 & \cos \pi & -\sin \pi \\
   0 & \sin \pi & \cos \pi
\end{bmatrix}
R_{left}
$$

==注意==

这里的$R_{right}$ 和 $R_{left}$都是旋转矩阵（注意与上面的手眼矩阵区分，含义不同），如果要发送给机器人进行运动，还需转换成世界坐标的$u, v, w$

### 旋转矩阵 转 旋转角(u, v, w)

$$
\begin{bmatrix}
   1 & 0 & 0 & 0 \\
   0 & \cos \theta & -\sin \theta & 0 \\
   0 & \sin \theta & \cos \theta & 0 \\
   0 & 0 & 0 & 1 
  \end{bmatrix} 
$$

```cpp
/**
* @brief 旋转矩阵转欧拉角
* @param matrix 旋转矩阵
* @return 欧拉角
*/
cv::Mat HYRoboticState::matrixToAngle(const cv::Mat& matrix)
{
    cv::Mat theta = cv::Mat(3, 1, CV_64F);
    theta.at<double>(0, 0) = atan2(matrix.at<double>(2, 1), matrix.at<double>(2, 2));
    theta.at<double>(1, 0) = atan2(-matrix.at<double>(2, 0), sqrt(pow(matrix.at<double>(2, 1), 2) + pow(matrix.at<double>(2, 2), 2)));
    theta.at<double>(2, 0) = atan2(matrix.at<double>(1, 0), matrix.at<double>(0, 0));

    return theta;
}
```

### 旋转角(u, v, w) 转 旋转矩阵

这个简单，直接根据下式计算即可：

设置机械臂基座坐标系为${B}$，机械臂末端坐标系为${A}$，则机械臂末端相对于基座的旋转矩阵为：

$$^A_BR = R_Z(\alpha) \cdot R_Y(\beta) \cdot R_X(\gamma) $$

==注意==
* $\alpha$ 是绕Z轴转的角
* $\beta$ 是绕Y轴转的角
* $\gamma$ 是绕X轴转的角

$$^A_BR =
\begin{bmatrix}
   \cos \alpha & -\sin \alpha & 0  \\
   \sin \alpha & \cos \alpha & 0 \\
   0 & 0 & 1 
\end{bmatrix}
\begin{bmatrix}
   \cos \beta & 0 & \sin \beta\\
   0 & 1 & 0 \\
   -\sin \beta & 0 & \cos \beta
\end{bmatrix} 
\begin{bmatrix}
   1 & 0 & 0  \\
   0 & \cos \gamma & -\sin \gamma \\
   0 & \sin \gamma & \cos \gamma 
\end{bmatrix}
$$

```cpp
/**
 * @brief 欧拉角转 旋转矩阵
 * @param vec 欧拉角
 * @return 新的旋转矩阵
*/
cv::Mat HYRoboticState::angleToMatrix(const cv::Mat& vec)
{
    double theta_x = vec.at<double>(0, 0);
    double theta_y = vec.at<double>(1, 0);
    double theta_z = vec.at<double>(2, 0);

    cv::Mat rx = (cv::Mat_<double>(3, 3) << 1, 0, 0, 0, cos(theta_x), -sin(theta_x), 0, sin(theta_x), cos(theta_x));
    cv::Mat ry = (cv::Mat_<double>(3, 3) << cos(theta_y), 0, sin(theta_y), 0, 1, 0, -sin(theta_y), 0, cos(theta_y));
    cv::Mat rz = (cv::Mat_<double>(3, 3) << cos(theta_z), -sin(theta_z), 0, sin(theta_z), cos(theta_z), 0, 0, 0, 1);

    cv::Mat r = rz * ry * rx;

    return r;
}
```
