# 摸索如何限制伯朗特机器人的J6关节的旋转角度

## 注意控制旋转的代码要写在navigation函数里

```cpp
int BorunteRobotPlugin::navigation(const hy::NavigationParam& originParam, int type /*= hy::ROBOT_POSE_TCP*/)
{
	if (!this->connected())
	{
		HY_LOG_SEV(error) << "robot is not connected";
		return PLUGIN_ERROR_FAIL;
	}

	hy::NavigationParam limitedParam;
	checkoutAxisConfig(originParam, limitedParam);
	hy::NavigationParam param = limitedParam;

	//定义起始点
	std::vector<double> start_loc;
	//获取当前的位置为起始位置
	this->pose(start_loc);
	//张开电爪
	this->run("Put");
	
	if (PLUGIN_ERROR_FAIL == this->setPos(start_loc, start_pos_addr_))
		return PLUGIN_ERROR_FAIL;
    
    //20210422判断w的旋转角度是否大于180
    double w_delta = start_loc[5] - param.Destination[5];
	if (w_delta > 180)
	{
		param.Transition[5] -= 180;
		param.Destination[5] -= 180;
	}
	if (w_delta < 180)
	{
		param.Transition[5] += 180;
		param.Destination[5] += 180;
	}

	if (PLUGIN_ERROR_FAIL == this->setPos(param.Transition, transition_addr_))
		return PLUGIN_ERROR_FAIL;
	if (PLUGIN_ERROR_FAIL == this->setPos(param.Destination, target_addr_))
		return PLUGIN_ERROR_FAIL;
	if (PLUGIN_ERROR_FAIL == this->setPos(coordinate_.Positions[param.Position], put_pos_addr_))
		return PLUGIN_ERROR_FAIL;

	//开始
	this->run("MoveStartFlag");

	//等待机器人完成抓取并反馈
	using namespace std::literals::chrono_literals;
	while (!this->run("MoveDoneFlag"))
	{
		std::this_thread::sleep_for(100ms);
	}
	this->run("Done");
	return PLUGIN_ERROR_SUCESS;
}
```

## Aubo机器人插件的J6旋转代码

```cpp
if (target_point.jointpos[5] > (M_PI * 7.0f / 180.0f))
{
    target_point.jointpos[5] = abs(refer_point.jointpos[5] - target_point.jointpos[5] + M_PI) >
        abs(refer_point.jointpos[5] - target_point.jointpos[5) ? 
        target_point.jointpos[5]
        : 
        target_point.jointpos[5] - M_PI;
}
else if(target_point.jointpos[5] < - (M_PI * 7.0f / 180.0f))
{
    target_point.jointpos[5] = abs(refer_point.jointpos[5] - target_point.jointpos[5] -M_PI) >
        abs(refer_point.jointpos[5] - target_point.jointpos[5]) ? 
        target_point.jointpos[5] 
        : 
        target_point.jointpos[5] + M_PI;
}
```

思路：
找出同方向旋转最接近起始点的位置。

from 苏丁鹏

## 我在伯朗特上的实现

要注意的是J6旋转的范围，我们在伯朗特上暂时是用世界坐标w来表示的。
w的范围为：$$[-180, +180]$$
但实际上J6的范围是以关节坐标来定的，实际活动范围要比w大，关节坐标范围为：
$$[-360, +360]$$

### 解决方案1

J6旋转之前获取当前的$w$的值为$w_0$，目标点的$w$为$w_1$。
判断一下$\Delta W = w_1 - w_0$，如果$\Delta W$的绝对值大于180，则根据符号加或者减180.
$\Delta W > 180$，则$\Delta W - 180$
$\Delta W > -180$，则$\Delta W + 180$

```cpp
//20210422判断w的旋转角度是否大于180
    double w_delta = start_loc[5] - param.Destination[5];
	if (w_delta > 180)
	{
		param.Transition[5] -= 180;
		param.Destination[5] -= 180;
	}
	if (w_delta < 180)
	{
		param.Transition[5] += 180;
		param.Destination[5] += 180;
	}
```

**最终版本**

```cpp
	/*********************************************************
	* @brief      解决J6关节旋转方向问题导致的爪具连接线缠绕问题
	* @details
	* @author    Ruilin Huang
	* @date      2021/04/25
	********************************************************/
	//检查起始点到目标点的要转的角度
	double w_delta1 = start_loc[5] - param.Destination[5];
	//检查目标点到放料点的w
	//double w_delta2 = param.Destination[5] - coordinate_.Positions[param.Position][5];

	if (w_delta1 > 180)
	{
		//param.Transition[5] -= 180;
		//param.Destination[5] -= 180;
		w_delta1 -= 180;
		param.Destination[5] = start_loc[5] + w_delta1;
	}
	if (w_delta1 < -180)
	{
		//param.Transition[5] += 180;
		//param.Destination[5] += 180;
		w_delta1 += 180;
		param.Destination[5] = start_loc[5] + w_delta1;
	}
	
	//如果要转的角度的绝对值等于180，就不用转了
	//if (w_delta1 == -180 || w_delta1 == 180)
		//param.Destination[5] = start_loc[5];

	//保证过渡点和目标点的w是一致的，不用再调整了
	param.Transition[5] = param.Destination[5];
	//保证放料点和目标点的w是一致的，不用再调整了
	coordinate_.Positions[param.Position][5] = param.Destination[5];
```

这个方案还是有问题的，因为有时候旋转的角度会超过90度，而实际上如果是反方向则根本没有必要转这么多角度。

### 尝试复现苏丁鹏大佬的代码

```cpp
	/*********************************************************
	* @brief      解决J6关节旋转方向问题导致的爪具连接线缠绕问题
	* @details
	* @author    Ruilin Huang
	* @date      2021/04/29
	********************************************************/
	//检查起始点到目标点的要转的角度
	double w0 = 0.0;
	if (param.Destination[5] > 0)
	{
		w0 = param.Destination[5] - 180;
	}
	else
		w0 = param.Destination[5] + 180;

	double w_delta1 = abs(start_loc[5]) - abs(param.Destination[5]);
	double w_delta2 = abs(start_loc[5]) - abs(w0);

	param.Destination[5] = (w_delta1 > w_delta2) ? w0 : param.Destination[5];

	//保证过渡点和目标点的w是一致的，不用再调整了
	param.Transition[5] = param.Destination[5];
	//保证放料点和目标点的w是一致的，不用再调整了
	coordinate_.Positions[param.Position][5] = param.Destination[5];
```

## 考虑是否将HYpick的w的转换一下

使得HYpick的w范围是在$[-180, 180]$之间。

```cpp
/*
* 测试勃朗特机器人 J6旋转 w限制在 [-180, 180] 代码存档
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

double limit(double w) {
    int i = 0;
    if (w > 180.0) {
        while (w - i * 180 > 0)
            i++;
        w = -180.0 + (w - (i - 1) * 180);
    }

    if (w < -180.0) {
        while (w + i * 180 < 0)
            i++;
        w = 180.0 + (w + (i - 1) * 180);
    }

    return w;
}

int main() {
    double w;
    puts("请输入一个w：");
    scanf("%lf", &w);
    
    w = limit(w);

    printf("%lf\n", w);
    return 0;
}
```
