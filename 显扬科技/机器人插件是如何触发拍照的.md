# 机器人插件是如何触发拍照的

首先实在引导函数navigation()里有触发拍照，是通过调用`this->run("Ready")`来实现的。

this指向的是当前机器人插件对象。

run的源代码：

```cpp
virtual int run(const std::string& task) {
	if (task_.find(task) == task_.end())
		return HY_FAIL_NOT_FOUND;
			
	return HY_SUCESS;
}
```

```cpp
int AuboRobotPlugin::run(const std::string& task)
{
    HY_LOG_SEV(debug) << "This is run api.";
    if (task_.find(task) == task_.end())
    {
        HY_LOG_SEV(error) << boost::format("no io task key match %1%") % task;
        return HY_FAIL_UNDEFINE;
    }

    int code, status = HY_FAIL_UNDEFINE;;
    double val;
    for (HYRobotIOTask t : task_[task])
    {
        status = HY_FAIL_UNDEFINE;
        try
        {
            if (t.Type != ROBOT_IO_TYPE_DO && t.Type != ROBOT_IO_TYPE_DI)
                return HY_FAIL_UNDEFINE;

            switch (t.Action)
            {
            case ROBOT_IO_ACTION_SET:
                if (t.Type == ROBOT_IO_TYPE_DO)
                {
                    code = rs_set_board_io_status_by_name(device_handle_,
                        RobotBoardUserDO,
                        t.Name.c_str(),
                        (t.Value > 0) ? IO_STATUS_VALID : IO_STATUS_INVALID);
                    if (code != RS_SUCC)
                    {
                        HY_LOG_SEV(error) << boost::format("set do %1% to %2% fail, error code %3%") % t.Name % status % code;
                    }
                    else
                        status = HY_SUCESS;
                }
                break;
            case ROBOT_IO_ACTION_GET:
                code = rs_get_board_io_status_by_name(device_handle_,
                    t.Type == ROBOT_IO_TYPE_DO ? RobotBoardUserDO : RobotBoardUserDI,
                    t.Name.c_str(), &val);
                if (code != RS_SUCC)
                {
                    HY_LOG_SEV(error) << boost::format("get %1% io %2% status fail, error code %3%") % t.Type % t.Name % code;
                }
                else if (val == t.Value)
                {
                    status = HY_SUCESS;
                }
                break;
            case ROBOT_IO_ACTION_WAIT_MS:
                std::this_thread::sleep_for(std::chrono::milliseconds((long)t.Value));
                status = HY_SUCESS;
                break;
            default:
                break;
            }
        }
        catch (const std::exception& ex)
        {
            HY_LOG_SEV(error) << boost::format("run io task, action %1%, type %2%, name %3%, value %4% catch exception: %5%")
                % t.Action % t.Type % t.Name % t.Value % ex.what();
            return HY_FAIL_UNDEFINE;
        }

        if (status != HY_SUCESS)
            break;
    }
    return status;
}
```

task_是 机器人插件类 class HYPLUGIN_API HYRobotPlugin : public HYPlugin 的一个保护成员：
```cpp
std::map<std::string, std::vector<HYRobotIOTask>> task_;
```

是一个map容器，string对应的是装着HYRobotIOTask类型的vector容器。

再看看HYRobotIOTask类型：

```cpp
/// <summary>
/// 机器人IO任务
/// </summary>
struct HYRobotIOTask
{
	int Action; /// IO任务动作，@enum hy::RobotIOAction
	int Type; /// IO任务类型，@enum hy::RobotIOType
	std::string Name; /// IO名称
	double Value; /// IO值
};
```

struct在C++里默认成员都是私有的。

```json
{
    "Ready": [
    {
        "Action": 0,
        "Type": 1,
        "Name": "U_DO_00",
        "Value": 1
    },
    {
        "Action": 1,
        "Type": 1,
        "Name": "U_DO_00",
        "Value": 0
    }
    ],
}
```

读取IO是否为1，如果是然后将IO置为0.
