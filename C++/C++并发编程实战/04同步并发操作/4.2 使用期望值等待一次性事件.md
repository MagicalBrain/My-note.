# 4.2 使用期望值等待一次性事件

假设你乘飞机去国外度假。当你到达机场并办理完各种登机手续后，还需要等待机场广播通知登机时(可能要等很多个 小时)，你可能会在候机室里面找一些事情来打发时间，比如:读书，上网，或者来一杯价格不菲的机场咖啡。不过， 从根本上来说你就在等待一件事情:机场广播能够登机的时间。之前飞机的班次在之后没有可参考性，因为当你在再 次度假的时候，可能会选择等待另一班飞机。

C++标准库模型将这种一次性事件称为期望值(future)。当线程需要等待特定的一次性事件时，某种程度上来说就需 要知道这个事件在未来的期望结果。之后，这个线程会周期性(较短的周期)的等待或检查，事件是否触发(检查信息 板);检查期间也会执行其他任务(品尝昂贵的咖啡)。另外，等待任务期间它可以先执行另外一些任务，直到对应的任 务触发，而后等待期望值的状态会变为就绪(ready)。一个期望值可能是数据相关的(比如，你的登机口编号)，也可 能不是。当事件发生时(并且期望状态为就绪)，并且这个期望值就不能被重置。

C++标准库中，有两种期望值，使用两种类型模板实现，声明在 `<future>` 头文件中: 唯一期望值(unique futures)( `std::future<>` )和共享期望值(shared futures)( `std::shared_future<>` )。仿照了 `std::unique_ptr` 和 `std::shared_ptr` 。 `std::future` 的实例只能与一个指定事件相关联，而 `std::shared_future` 的实例就能关联多个事件。后者的实现中，所有实例会在同时变为就绪状态，并且他们可以访 问与事件相关的任何数据。这种数据关联与模板有关，比如 `std::unique_ptr` 和 `std::shared_ptr` 的模板参数就是 相关联的数据类型。与数据无关处，可以使用 `std::future<void>` 与 `std::shared_future<void>` 的特化模板。虽然， 我希望用于线程间的通讯，但是期望值对象本身并不提供同步访问。当多个线程需要访问一个独立期望值对象时，必 须使用互斥量或类似同步机制对访问进行保护，如在第3章所述。不过，在将要阅读到的4.2.5节中，多个线程会对一 个 `std::shared_future<>` 实例的副本进行访问，即使他们是同一个异步结果，也不需要同步期望值。

并行技术规范将这两个模板类在 `std::experimental` 命名空间中进行了扩展: `std::experimental::future<>` 和 std::experimental::shared_future<> 。这个命名空间就是为了将其与 std 命名 空间中的模板类进行区分，实验性的命名空间中为这两个模板类添加了更多的功能。尤为重要的是 std::experimental 中的内容与代码质量无关(我希望这里也会有较高质量的实现)，需要强调是这个命名空间提供 的类和函数都不是标准的，这个命名空间中类和函数的语法和语义，很可能与纳入C++标准(也就是 std 命名空间) 后有所不同。如果想要使用这两个试验性的模板类，需要包含 <experimental/future> 头文件。

最简单的一次性事件，就是一个后台运行出的计算结果。第2章中已经清楚了 std::thread 执行的任务不能有返回 值，并且我能保证，这个问题将在使用期望值解决——现在就来看看是怎么解决的。

## 4.2.1 后台任务的返回值

假设，你有一个需要长时间的运算，你需要其能计算出一个有效的值，但是你现在并不迫切需要这个值。可能你已经 找到了生命、宇宙，以及万物的答案，就像道格拉斯·亚当斯[1]一样。你可以启动一个新线程来执行这个计算，这就 意味着你需要计算的结果，因为 std::thread 并不提供直接接收返回值的机制。这里就需要 std::async 函数模板 (也是在头文 `<future>` 中声明的)。

当不着急要任务结果时，可以使用 std::async 启动一个异步任务。与 std::thread 对象等待的方式不同， std::async 会返回一个 std::future 对象，这个对象持有最终计算出来的结果。当需要这个值时，只需要调用 这个对象的get()成员函数;并且会阻塞线程直到期望值状态为就绪为止;之后，返回计算结果。下面清单中代码就 是一个简单的例子。

清单4.6 使用 std::future 从异步任务中获取返回值

```cpp
#include <future>
#include <iostream>

int find_the_answer_to_ltuae();

void do_other_stuff();

int main()
{
    std::future<int> the_answer=std::async(find_the_answer_to_ltuae);
    do_other_stuff();
    std::cout << "The answer is " << the_answer.get() << std::endl;
}
```
