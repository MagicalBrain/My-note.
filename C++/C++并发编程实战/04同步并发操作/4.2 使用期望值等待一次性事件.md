# 4.2 使用期望值等待一次性事件

假设你乘飞机去国外度假。当你到达机场并办理完各种登机手续后，还需要等待机场广播通知登机时(可能要等很多个 小时)，你可能会在候机室里面找一些事情来打发时间，比如:读书，上网，或者来一杯价格不菲的机场咖啡。不过， 从根本上来说你就在等待一件事情:机场广播能够登机的时间。之前飞机的班次在之后没有可参考性，因为当你在再 次度假的时候，可能会选择等待另一班飞机。

C++标准库模型将这种一次性事件称为期望值(future)。当线程需要等待特定的一次性事件时，某种程度上来说就需 要知道这个事件在未来的期望结果。之后，这个线程会周期性(较短的周期)的等待或检查，事件是否触发(检查信息 板);检查期间也会执行其他任务(品尝昂贵的咖啡)。另外，等待任务期间它可以先执行另外一些任务，直到对应的任 务触发，而后等待期望值的状态会变为就绪(ready)。一个期望值可能是数据相关的(比如，你的登机口编号)，也可 能不是。当事件发生时(并且期望状态为就绪)，并且这个期望值就不能被重置。

C++标准库中，有两种期望值，使用两种类型模板实现，声明在 `<future>` 头文件中: 唯一期望值(unique futures)( `std::future<>` )和共享期望值(shared futures)( `std::shared_future<>` )。仿照了 `std::unique_ptr` 和 `std::shared_ptr` 。 `std::future` 的实例只能与一个指定事件相关联，而 `std::shared_future` 的实例就能关联多个事件。后者的实现中，所有实例会在同时变为就绪状态，并且他们可以访 问与事件相关的任何数据。这种数据关联与模板有关，比如 `std::unique_ptr` 和 `std::shared_ptr` 的模板参数就是 相关联的数据类型。与数据无关处，可以使用 `std::future<void>` 与 `std::shared_future<void>` 的特化模板。虽然， 我希望用于线程间的通讯，但是期望值对象本身并不提供同步访问。当多个线程需要访问一个独立期望值对象时，必 须使用互斥量或类似同步机制对访问进行保护，如在第3章所述。不过，在将要阅读到的4.2.5节中，多个线程会对一 个 `std::shared_future<>` 实例的副本进行访问，即使他们是同一个异步结果，也不需要同步期望值。

并行技术规范将这两个模板类在 `std::experimental` 命名空间中进行了扩展: `std::experimental::future<>` 和 std::experimental::shared_future<> 。这个命名空间就是为了将其与 std 命名 空间中的模板类进行区分，实验性的命名空间中为这两个模板类添加了更多的功能。尤为重要的是 std::experimental 中的内容与代码质量无关(我希望这里也会有较高质量的实现)，需要强调是这个命名空间提供 的类和函数都不是标准的，这个命名空间中类和函数的语法和语义，很可能与纳入C++标准(也就是 std 命名空间) 后有所不同。如果想要使用这两个试验性的模板类，需要包含 <experimental/future> 头文件。

最简单的一次性事件，就是一个后台运行出的计算结果。第2章中已经清楚了 std::thread 执行的任务不能有返回 值，并且我能保证，这个问题将在使用期望值解决——现在就来看看是怎么解决的。

## 4.2.1 后台任务的返回值

假设，你有一个需要长时间的运算，你需要其能计算出一个有效的值，但是你现在并不迫切需要这个值。可能你已经 找到了生命、宇宙，以及万物的答案，就像道格拉斯·亚当斯[1]一样。你可以启动一个新线程来执行这个计算，这就 意味着你需要计算的结果，因为 std::thread 并不提供直接接收返回值的机制。这里就需要 std::async 函数模板 (也是在头文 `<future>` 中声明的)。

当不着急要任务结果时，可以使用 std::async 启动一个异步任务。与 std::thread 对象等待的方式不同， std::async 会返回一个 std::future 对象，这个对象持有最终计算出来的结果。当需要这个值时，只需要调用 这个对象的get()成员函数;并且会阻塞线程直到期望值状态为就绪为止;之后，返回计算结果。下面清单中代码就 是一个简单的例子。

清单4.6 使用 std::future 从异步任务中获取返回值

```cpp
#include <future>
#include <iostream>

int find_the_answer_to_ltuae();

void do_other_stuff();

int main()
{
    std::future<int> the_answer=std::async(find_the_answer_to_ltuae);
    do_other_stuff();
    std::cout << "The answer is " << the_answer.get() << std::endl;
}
```

与 std::thread 做的方式一样， std::async 允许你通过添加额外的调用参数，向函数传递额外的参数。当第一个 参数是一个指向成员函数的指针，第二个参数提供有这个函数成员类的具体对象(不是直接的，就是通过指针，还可以 包装在 std::ref 中)，剩余的参数可作为成员函数的参数传入。否则，第二个和随后的参数将作为函数的参数，或作 为指定可调用对象的第一个参数。就如 std::thread ，当参数为右值时，拷贝操作将使用移动的方式转移原始数据。 这就允许使用“只移动”类型作为函数对象和参数。来看一下下面的程序清单:

清单4.7 使用 std::async 向函数传递参数

```cpp
#include <string>
#include <future>

struct X
{

void foo(int,std::string const&);
std::string bar(std::string const&);
};

X x;

auto f1=std::async(&X::foo,&x,42,"hello"); // 调用p->foo(42, "hello")，p是指向x的指针
auto f2=std::async(&X::bar,x,"goodbye"); // 调用tmpx.bar("goodbye")， tmpx是x的拷贝副本
struct Y
{
    double operator()(double);
};
Y y;

auto f3=std::async(Y(),3.141); // 调用tmpy(3.141)，tmpy通过Y的移动构造函数得到
auto f4=std::async(std::ref(y),2.718); // 调用y(2.718)

X baz(X&);
std::async(baz,std::ref(x)); // 调用baz(x)

class move_only
{
public:
    move_only();
    move_only(move_only&&)
    move_only(move_only const&) = delete;
    move_only& operator=(move_only&&);
    move_only& operator=(move_only const&) = delete;

    void operator()();
};

auto f5=std::async(move_only()); // 调用tmp()，tmp是通过std::move(move_only())构造得到
```

默认情况下，期望值是否等待取决于 std::async 是否启动一个线程，或是否有任务正在进行同步。大多数情况下(估 计这就是你想要的结果)，也可以在函数调用之前向 std::async 传递一个额外参数，这个参数的类型是 std::launch ，还可以是 std::launch::defered ，表明函数调用被延迟到wait()或get()函数调用时才执行， std::launch::async 表明函数必须在其所在的独立线程上执行， std::launch::deferred | std::launch::async 表 明实现可以选择这两种方式的一种。最后一个选项是默认的，当函数调用被延迟，它可能不会在运行了。如下所示:

```cpp
auto f6=std::async(std::launch::async,Y(),1.2); // 在新线程上执行
auto f7=std::async(std::launch::deferred,baz,std::ref(x)); // 在wait()或get()调用时执行 
auto f8=std::async(
    std::launch::deferred | std::launch::async,
    baz,std::ref(x)); // 实现选择执行方式 
auto f9=std::async(baz,std::ref(x));
f7.wait(); // 调用延迟函数
```

本章的后面和第8章中，将会再次看到这段程序，使用 std::async 会更容易让算法分割到各个任务中，这样程序就能 并发的执行了。不过，这不是让 std::future 与任务实例相关联的唯一方式;你也可以将任务包装入 std::packaged_task<> 实例中，或通过编写代码的方式，使用 std::promise<> 类型模板显示设置值。

与 std::promise<> 对比， std::packaged_task<> 具有更高层的抽象，所以我们从“高抽象”的模板说起。

## 4.2.2 任务与期望值相关联

`list 4.7`

我根据win10的实际运行情况修改了一下代码

```cpp
#include "Chapter4.h"

/*
* 通过 std::async 向任务函数传递参数
*/

#include <iostream>
#include <string>
#include <future>
#include <mutex>

std::mutex lock_print;

// 定义了一个类
struct X
{
    void pIntAndString(int a, std::string const& s) {
        std::lock_guard<std::mutex> guard(lock_print);
        std::cout << s << " " << a << std::endl;
    }

    std::string pString(std::string const& s) {
        std::lock_guard<std::mutex> guard(lock_print);
        std::cout << s << std::endl;
        return s;
    }
};

struct Y
{
    double operator()(double d) {
        std::lock_guard<std::mutex> guard(lock_print);
        std::cout << d / 2.0 << std::endl;
        return d;
    }
};

class move_only
{
public:
    move_only() {
        std::lock_guard<std::mutex> guard(lock_print);
        std::cout << "move_only() constructor has been called!\n";
    }

    move_only(move_only&&) noexcept 
    {
        std::lock_guard<std::mutex> guard(lock_print);
        std::cout << "move_only(move_only&&) constructor has been called!\n";
    }
    
    move_only(move_only const&) = delete;
    
    move_only& operator=(move_only&& m) noexcept
    {
        std::lock_guard<std::mutex> guard(lock_print);
        std::cout << "move_only operator=(move_only&& m) has been called!\n";
        return m;
    }
    
    move_only& operator=(move_only const&) = delete;
    
    void operator()() {
        std::lock_guard<std::mutex> guard(lock_print);
        std::cout << "move_only operator()() has been called!\n";
    }
};

X getXx(X& x) {
    return x;
}

int list47() {
    // 实例化类对象
    X x;

    // 注意学习这里是如何通过 std::async 调用类成员函数的
    // (函数指针， 类对象指针， 参数1， 参数2)
    auto f1 = std::async(&X::pIntAndString, &x, 42, "hello");
    auto f2 = std::async(&X::pString, x, "goodbye");

    // 书上源码是：std::async(baz,std::ref(x));
    // 这里是译者修改为auto f6 的
    //auto f6=std::async(baz,std::ref(x));
    // 我重新调了一下顺序为 f5
    auto f3 = std::async(getXx, std::ref(x));

    // 实例化Y类的对象y
    Y y;

    auto f4 = std::async(Y(), 3.141);
    // 注意这种用法
    auto f5 = std::async(std::ref(y), 2.718);

    auto f6 = std::async(move_only());

    f1.get();
    f2.get();
    f3.get();
    f4.get();
    f5.get();
    f6.get();

    return 0;
}

```

运行结果可能是这样子的：

```bash
move_only() constructor has been called!
move_only(move_only&&) constructor has been called!
move_only(move_only&&) constructor has been called!
move_only(move_only&&) constructor has been called!
hello 42
goodbye
1.5705
1.359
move_only operator()() has been called!
```

## 4.2.3 使用 std::promises1
