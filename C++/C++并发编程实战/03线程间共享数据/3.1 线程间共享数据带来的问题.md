# 3.1 线程间共享数据带来的问题

涉及到共享数据时，就可能会出现因为共享数据修改所导致的问题。

如果共享数据时只读的，那么不会出现问题。
但是，当一个或者多个线程要修改共享数据时，就会产生问题。

为了方便阐述问题，我们引入了**不变量**这个概念
它是一个针对某一特定数据的断言，该断言总是成立的。

每一次数据更新，==不变量==都会遭到破坏，这之后的情况是不确定的。
可能会带来**条件竞争**的问题

## 3.1.1 条件竞争 (race condition)

条件竞争分为良性条件和恶性条件竞争。
我们只关注会出问题的恶性条件竞争。

## 3.1.2 避免恶性条件竞争

### 无锁编程

对数据结构和不变量的设计进行修改，修改完的结构必须能完成一系列不可分割的变化，即保证每个不变量保持稳定的状态

这种方式较难实现，且工作量大，涉及到内存模型的问题

### 使用“事务”的方式

使用事务的方式去处理数据结构的更新(这里的”处理”就如同对数据库进行更新一 样)。所需的一些数据和读取都存储在事务日志中，然后将之前的操作合为一步，再进行提交。当数据结构被另一个线 程修改后，或处理已经重启的情况下，提交就会无法进行，这称作为“软件事务内存”(software transactional memory (STM))。理论研究中，这是一个很热门的研究领域。

缺点：在 C++ 中 没有对STM进行直接支持

### 使用互斥量

使用C++标准库提供的互斥量是保护共享数据结构最基本的方式

标记访问该数据结构的所有代码，令各线程在其上相互排斥(mutual exclusion，略作 mutex)的同步原语[^1]



[^1]: 原语就是操作系统里的原子操作？在这个操作里不会被其它线程打断
