# 2.1 线程管理的基础

每个程序至少有一个线程:
执行main()函数的线程

其余线程有其各自的入口函数。线程与原始线程(以main()为入口函数的线程)同时运行。如同main()函数执行完会退出一样，当线程执行完入口函数后，线程也会退出。在为一个线程创建了一个 std::thread 对象后，需要等待这个线程结束;不过，线程需要先进行启动。下面就来启动线程。

### 2.1.1 启动线程

第1章中，线程在 std::thread ==对象创建(为线程指定任务)==时启动。最简单的情况下，任务也会很简单，通常是无参 数无返回的函数。这种函数在其所属线程上运行，直到函数执行完毕，线程也就结束了。

在一些极端情况下，线程运 行时，任务中的函数对象需要通过某种通讯机制进行参数的传递，或者执行一系列独立操作;可以通过通讯机制传递信 号，让线程停止。线程要做什么，以及什么时候启动，其实都无关紧要。总之，使用C++线程库启动线程，可以归结为 构造 std::thread 对象:

```cpp
void do_some_work();
std::thread my_thread(do_some_work);
```

为了让编译器识别 std::thread 类，这个简单的例子也要包含 <thread> 头文件。如同大多数C++标准库一样， std::thread 可以用可调用类型构造，将带有函数调用符类型的实例传入 std::thread 类中，替换默认的构造 函数。
  
```cpp
class background_task
{
public:
  void operator()() const
  {
    do_something();
    do_something_else();
  }
};
background_task f;
std::thread my_thread(f);
```

代码中，提供的函数对象会复制到新线程的存储空间当中，函数对象的执行和调用都在线程的内存空间中进行。函数
对象的副本应与原始函数对象保持一致，否则得到的结果会与我们的期望不同。
有件事需要注意，当把函数对象传入到线程构造函数中时，需要避免“最令人头痛的语法解析”(C++’s most
vexing parse, 中文简介)。如果你传递了一个临时变量，而不是一个命名的变量;C++编译器会将其解析为函数声 明，而不是类型对象的定义。
例如:

`std::thread my_thread(background_task());`
 
这里相当于声明了一个名为my_thread的函数，这个函数带有一个参数(函数指针指向没有参数并返回
background_task对象的函数)，返回一个 std::thread 对象的函数，而非启动了一个线程。 使用在前面命名函数对象的方式，或使用多组括号1，或使用新统一的初始化语法2，可以避免这个问题。 如下所示:

### 2.1.2 等待线程完成

如果需要等待线程，相关的 std::thread 实例需要使用join()。清单2.1中，将 my_thread.detach() 替换为 my_thread.join() ，就可以确保局部变量在线程完成后，才被销毁。在这种情况下，因为原始线程在其生命周期中 并没有做什么事，使得用一个独立的线程去执行函数变得收益甚微，但在实际编程中，原始线程要么有自己的工作要 做;要么会启动多个子线程来做一些有用的工作，并等待这些线程结束。

join()是简单粗暴的等待线程完成或不等待。当你需要对等待中的线程有更灵活的控制时，比如，看一下某个线程是 否结束，或者只等待一段时间(超过时间就判定为超时)。想要做到这些，你需要使用其他机制来完成，比如条件变量 和期待(futures)，相关的讨论将会在第4章继续。调用join()的行为，还清理了线程相关的存储部分，这样 std::thread 对象将不再与已经完成的线程有任何关联。这意味着，只能对一个线程使用一次join();一旦已经使 用过join()， std::thread 对象就不能再次加入了，当对其使用joinable()时，将返回false。

### 2.1.3 特殊情况下的等待

如前所述，需要对一个还未销毁的 std::thread 对象使用join()或detach()。如果想要分离一个线程，可以在线程 启动后，直接使用detach()进行分离。如果打算等待对应线程，则需要细心挑选调用join()的位置。当在线程运行 之后产生异常，在join()调用之前抛出，就意味着这次调用会被跳过。
避免应用被抛出的异常所终止，就需要作出一个决定。通常，当倾向于在无异常的情况下使用join()时，需要在异常 处理过程中调用join()，从而避免生命周期的问题。下面的程序清单是一个例子。

```cpp
清单 2.2 等待线程完成
struct func; // 定义在清单2.1中
void f()
{
    int some_local_state=0;
    func my_func(some_local_state);
    std::thread t(my_func);
    try
    {
        do_something_in_current_thread();
    }
    catch(...)
    {
        t.join(); // 1
        throw;
    }
    t.join(); // 2
}
```

一种方式是使用“资源获取即初始化方式”(RAII，Resource Acquisition Is Initialization)，并且提供一 个类，在析构函数中使用join()，如同下面清单中的代码。看它如何简化f()函数。

清单 2.3 使用RAII等待线程完成

```cpp
class thread_guard
{
    std::thread& t;
public:
    explicit thread_guard(std::thread& t_):
    t(t_)
    {}
    
    ~thread_guard()
    {
        if(t.joinable()) // 1
        {
            t.join(); // 2
        }
    }
    
    thread_guard(thread_guard const&)=delete; // 3

    thread_guard& operator=(thread_guard const&)=delete;
};

struct func; // 定义在清单2.1中 20.
void f()
{
    int some_local_state=0;
    func my_func(some_local_state);
    std::thread t(my_func);
    thread_guard g(t);
    do_something_in_current_thread();
}   // 4
```

当线程执行到4处时，局部对象就要被逆序销毁了。因此，thread_guard对象g是第一个被销毁的，这时线程在析构 函数中被加入2到原始线程中。即使do_something_in_current_thread抛出一个异常，这个销毁依旧会发生。
在thread_guard的析构函数的测试中，首先判断线程是否已加入1，如果没有会调用join()2进行加入。这很重 要，因为join()只能对给定的对象调用一次，所以对给已加入的线程再次进行加入操作时，将会导致错误。
拷贝构造函数和拷贝赋值操作被标记为 =delete 3，是为了不让编译器自动生成它们。直接对一个对象进行拷贝或赋 值是危险的，因为这可能会弄丢已经加入的线程。通过删除声明，任何尝试给thread_guard对象赋值的操作都会引 发一个编译错误。想要了解删除函数的更多知识，请参阅附录A的A.2节。
如果不想等待线程结束，可以分离_(_detaching)线程，从而避免异常安全(exception-safety)问题。不过，这 就打破了线程与 std::thread 对象的联系，即使线程仍然在后台运行着，分离操作也能确
保 std::terminate() 在 std::thread 对象销毁才被调用

### 2.1.4 后台运行线程


