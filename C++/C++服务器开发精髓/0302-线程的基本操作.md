## 3.2 线程的基本操作

### 创建线程

线程的创建其本质都是调用操作系统的api来进行的，所以我们分Linux和Windows来阐述这个问题。
这里只介绍了常用的函数，更多详细内容应该去Linux man手册和Windows msdn里去找。

#### 1、Linux下创建线程

在Linux上是使用`pthread_create`函数来创建线程的：

```cpp
int pthread_create(pthread_t *restrict_thread,
    const pthread_attr_t *restrict_attr,
    void *(*start_routine)(void *),
    void *restrict_arg);
```

**restrict_thread**:
输出参数，如果线程创建成功，那么可以通过这个参数获取创建成功线程的id。

**restrict_attr**:
指定线程的属性，一般设置为`NULL`。

**start_routine**：
指定了线程函数，这个函数的调用必须是`__cdecl`，这是`C Declaration`的缩写。
`__cdecl`是C/C++在定义全局函数是默认的调用方式。

**args**：
用于在创建线程的时候将某个参数传入线程函数中。
由于是`void*`类型，所以可以方便我们最大化地传入任意信息给线程函数。

**返回值**：
成功创建线程则返回0；
如果失败返回对应的错误码：
1. EAGAIN
2. EINVAL
3. EPERM

EAGAIN Insufficient resources to create another thread.

       EAGAIN A system-imposed limit on the number of threads was
              encountered.  There are a number of limits that may
              trigger this error: the RLIMIT_NPROC soft resource limit
              (set via setrlimit(2)), which limits the number of
              processes and threads for a real user ID, was reached; the
              kernel's system-wide limit on the number of processes and
              threads, /proc/sys/kernel/threads-max, was reached (see
              proc(5)); or the maximum number of PIDs,
              /proc/sys/kernel/pid_max, was reached (see proc(5)).

       EINVAL Invalid settings in attr.

       EPERM  No permission to set the scheduling policy and parameters
              specified in attr.

参考链接：
https://man7.org/linux/man-pages/man3/pthread_create.3.html

简单的示例：
@import "./code/pthread_createDemo.cpp"

输出结果：

```bash
gcc pthread_createDemo.cpp -o pthread_createDemo -lpthread
./pthread_createDemo

I am a New Thread!
I am a New Thread!
I am a New Thread!
I am a New Thread!
I am a New Thread!
^C
```

注意用gcc运行的时候要加`-lpthread`参数

#### 2、Windows下创建线程

在Windows上是使用`CreateThread`函数来创建线程的

```cpp
HANDLE CreateThread(
  LPSECURITY_ATTRIBUTES   lpThreadAttributes,
  SIZE_T                  dwStackSize,
  LPTHREAD_START_ROUTINE  lpStartAddress,
  __drv_aliasesMem LPVOID lpParameter,
  DWORD                   dwCreationFlags,
  LPDWORD                 lpThreadId
);
```

**lpThreadAttributes**:
表示线程的安全属性，一般设置为NULL

**dwStackSize**:
指的是线程的栈大小，单位为：byte，
一般为0，表示使用默认的大小

**lpStartAddress**:
为线程函数，其类型为函数指针类型`LPTHREAD_START_ROUTINE`.

`LPTHREAD_START_ROUTINE`:

```cpp
typedef DWORD (__stdcall *LPTHREAD_START_ROUTINE) (  
    [in] LPVOID lpThreadParameter  
);
```

可见，此函数的调用方式是`__stdcall`，

```cpp
// 如果不指定调用方式，则调用方式是 __cdecl
// 且无法作为调用方式为 __stdcall 的函数形参被 CreateThread 函数调用
DWORD threadfunc(LPVOID ipThreadParameter);

// 指定调用方式为 __stdcall 可以被 CreateThread 函数调用
DWORD __stdcall threadfunc(LPVOID ipThreadParameter);
```

另外，在Windows系统上，WINAPI和CALLBACK这两个宏的值都是 __stdcall
故，有的写法是：

```cpp
DWORD WINAPI threadfunc(LPVOID ipThreadParameter);
DWORD CALLBACK threadfunc(LPVOID ipThreadParameter);
```

**lpParameter**:
是传给线程函数的形参，和Linux下args一样。
而且实际上都是 `void*` 类型，`LPVOID` 实质上用typedef封装过的`void*`

**dwCreationFlags**:
32位无符号整型`DWORD`，一般被设置为0，表示一创建线程就启动该线程。

对于一些特殊的场景，我们不希望创建线程后立即开始执行，则可以将这个值设置为4，对应Windows定义的宏`CREATE_SUSPENDED`.
在之后需要的时候在使用ResumeThread这个函数来运行此线程。

**lpThreadId**:
是一个32为无符号整型的指针（`LPDWORD`），表示线程创建成功时返回的线程ID。

在Windows上是使用句柄来管理线程对象的，句柄在本质上是内核句柄表中的索引值。
如果成功创建线程，则返回该线程的句柄，否则返回`NULL`

以下代码片段演示了如何在Windows上创建线程：
@import "./code/Win-Thread.cpp"

#### 3、Windows CRT提供的线程创建函数

查阅 [CRT官方文档][CRT_beginthreadex]

[CRT_beginthreadex]:https://docs.microsoft.com/zh-cn/cpp/c-runtime-library/reference/beginthread-beginthreadex?view=msvc-160

以下代码是使用`_beginthreadex`创建线程的例子：
@import "./code/Win-CRT-Thread.cpp"

在实际开发中，许多大佬推荐使用`_beginthreadex`而不是`CreatThread`函数，不知为何

##### 为啥推荐使用`_beginthreadex`而不是`CreatThread`函数？

ToDo

#### 4、C++11 提供的std::thread类

C++11新标准引入了一个`std::thread`以解决Windows和Linux线程API的格式兼容问题。

以下代码分别创建了两个线程，线程函数签名不一致：
@import "./code/thread_std11.cpp"

**注意**：
在Linux上运行该代码命令如下：
```bash
g++ thread_std11.cpp -o thread_std11 -lpthread
```
可见还是需要`pthread`库啊。

这个使用方便，但是容易出错，即`std::thread`对象在线程函数运行期间必须是有效的。啥意思？看个例子：
@import "./code/thread_std11_Error.cpp"

main函数中调用了func函数，func函数里创建了一个线程，貌似没有问题的样子。但是实际运行的时候会崩溃。
崩溃的原因是，在func函数调用结束后，func中的局部变量t（即创建的线程）会被销毁，但此时线程函数仍然在运行。
所以在使用`std::thread`类时一定要保证线程函数运行的时候线程是有效的、没有被销毁的。
那如果我们要让线程对象销毁后，线程函数能够正常运行又该怎么办呢？

只需用`detach`方法让线程函数与线程分离即可，例如：

```cpp
void func() {
  std::thread t(threadproc);
  t.detach();
}
```

然而在实际开发中不推荐这么做，因为我们可能需要用线程对象来管理和控制线程的运行和生命周期。
所以我们的代码应该尽量保证线程对象在线程运行期间有效。

### Linux和Windows上线程函数调用方式的异同

在这里我们单独谈谈Windows上创建线程的函数和Linux的区别。

在Windows上使用该函数创建线程函数时要求其调用方式为`__stdcall`，但是定义的函数默认调用方式却是`__cdecl`。
也就是说定义的全局函数可以作为Linux`pthread_create`的线程函数，却不能作为Windows上`CreateThread`的线程函数。

举个例子：

```cpp
//不显式指定函数的调用方式，其调用方式为 __cdecl
void* start_rountine(void *arge) {}

//显式指定函数的调用方式为 __cdecl，等价于上面的代码
void* __cdecl start_routine(void *arge) {}
```

### 获取线程ID

Linux上使用`pthread_self()`来获取线程ID

Windows上使用`GetCurrentThreadID()`来获取线程ID

#### pstack命令

pstack是Linux上通过线程ID用来查看线程的命令。不仅可以查看线程数量还可以查看每个线程的调用堆栈。

使用pstack命令可以方便地排查和定位一个进程CPU使用率过高的问题。

#### Linux系统线程ID的本质

#### C++11 获取当前线程ID

### 等待线程结束
