## 3.2 线程的基本操作

### 创建线程

线程的创建其本质都是调用操作系统的api来进行的，所以我们分Linux和Windows来阐述这个问题。
这里只介绍了常用的函数，更多详细内容应该去Linux man手册和Windows msdn里去找。

#### Linux下创建线程

在Linux上是使用`pthread_create`函数来创建线程的：

```cpp
int pthread_create(pthread_t *restrict_thread,
    const pthread_attr_t *restrict_attr,
    void *(*start_routine)(void *),
    void *restrict_arg);
```

**restrict_thread**:
输出参数，如果线程创建成功，那么可以通过这个参数获取创建成功线程的id。

**restrict_attr**:
指定线程的属性，一般设置为`NULL`。

**start_routine**：
指定了线程函数，这个函数的调用必须是`__cdecl`，这是`C Declaration`的缩写。
`__cdecl`是C/C++在定义全局函数是默认的调用方式。

**args**：
用于在创建线程的时候将某个参数传入线程函数中。
由于是`void*`类型，所以可以方便我们最大化地传入任意信息给线程函数。

**返回值**：
成功创建线程则返回0；
如果失败返回对应的错误码：
1. EAGAIN
2. EINVAL
3. EPERM

EAGAIN Insufficient resources to create another thread.

       EAGAIN A system-imposed limit on the number of threads was
              encountered.  There are a number of limits that may
              trigger this error: the RLIMIT_NPROC soft resource limit
              (set via setrlimit(2)), which limits the number of
              processes and threads for a real user ID, was reached; the
              kernel's system-wide limit on the number of processes and
              threads, /proc/sys/kernel/threads-max, was reached (see
              proc(5)); or the maximum number of PIDs,
              /proc/sys/kernel/pid_max, was reached (see proc(5)).

       EINVAL Invalid settings in attr.

       EPERM  No permission to set the scheduling policy and parameters
              specified in attr.

参考链接：
https://man7.org/linux/man-pages/man3/pthread_create.3.html

简单的示例：
@import "./code/pthread_createDemo.cpp"

输出结果：

```bash
gcc pthread_createDemo.cpp -o pthread_createDemo -lpthread
./pthread_createDemo

I am a New Thread!
I am a New Thread!
I am a New Thread!
I am a New Thread!
I am a New Thread!
^C
```

注意用gcc运行的时候要加`-lpthread`参数

#### Windows下创建线程

在Windows上是使用`CreateThread`函数来创建线程的

```cpp

```

#### Windows CRT提供的线程创建函数



#### Linux和Windows上线程函数调用方式的异同

在Windows上使用该函数创建线程函数时要求其调用方式为`__stdcall`，但是定义的函数默认调用方式却是`__cdecl`。
也就是说定义的全局函数可以作为Linux`pthread_create`的线程函数，却不能作为Windows上`CreateThread`的线程函数。

举个例子：

```cpp
//不显式指定函数的调用方式，其调用方式为 __cdecl
void* start_rountine(void *arge) {}

//显式指定函数的调用方式为 __cdecl，等价于上面的代码
void* __cdecl start_routine(void *arge) {}
```

#### C++11 提供的std::thread类

### 获取线程ID
