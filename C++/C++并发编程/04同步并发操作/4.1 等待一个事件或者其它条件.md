# 4.1 等待一个事件或者其它条件

假设你在旅游，而且正在一辆在夜间运行的火车上。在夜间，如何在正确的站点下车呢?一种方法是整晚都要醒着，然后注意到了哪一站。这样，你就不会错过你要到达的站点，但是这样会让你感到很疲倦。另外，你可以看一下时间表，估计一下火车到达目的地的时间，然后在一个稍早的时间点上设置闹铃，然后你就可以安心的睡会了。这个方法听起来也很不错，也没有错过你要下车的站点，但是当火车晚点的时候，你就要被过早的叫醒了。当然，闹钟的电池也可能会没电了，并导致你睡过站。理想的方式是，无论是早或晚，只要当火车到站的时候，有人或其他东西能把你唤醒就好了。

这和线程有什么关系呢?好吧，让我们来联系一下。当一个线程等待另一个线程完成任务时，它会有很多选择。第 一，它可以持续的检查共享数据标志(用于做保护工作的互斥量)，直到另一线程完成工作时对这个标志进行重设。不 过，就是一种浪费:线程消耗宝贵的执行时间持续的检查对应标志，并且当互斥量被等待线程上锁后，其他线程就没 有办法获取锁，这样线程就会持续等待。因为以上方式对等待线程限制资源，并且在完成时阻碍对标识的设置。这种 情况类似与，保持清醒状态和列车驾驶员聊了一晚上:驾驶员不得不缓慢驾驶，因为你分散了他的注意力，所以火车 需要更长的时间，才能到站。同样的，等待的线程会等待更长的时间，这些线程也在消耗着系统资源。

第二个选择是在等待线程在检查间隙，使用 std::this_thread::sleep_for() 进行周期性的间歇(详见4.3节):

```cpp
bool flag;
std::mutex m;

void wait_for_flag()
{
    std::unique_lock<std::mutex> lk(m);
    while(!flag)
    {
        lk.unlock(); // 1 解锁互斥量 
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 2 休眠100ms 
        lk.lock(); // 3 再锁互斥量
    }
}
```

这个循环中，在休眠前2，函数对互斥量进行解锁1，并且在休眠结束后再对互斥量进行上锁，所以另外的线程就有机会获取锁并设置标识。

这个实现就进步很多，因为当线程休眠时，线程没有浪费执行时间，但是很难确定正确的休眠时间。太短的休眠和没有休眠一样，都会浪费执行时间;太长的休眠时间，可能会让任务等待线程醒来。休眠时间过长是很少见的情况，因为这会直接影响到程序的行为，当在高节奏游戏中，它意味着丢帧，或在一个实时应用中超越了一个时间片。

第三个选择(也是优先的选择)是，使用C++标准库提供的工具去等待事件的发生。通过另一线程触发等待事件的机制 是最基本的唤醒方式(例如:流水线上存在额外的任务时)，这种机制就称为“条件变量”。从概念上来说，一个条件变 量会与多个事件或其他条件相关，并且一个或多个线程会等待条件的达成。当某些线程被终止时，为了唤醒等待线程 (允许等待线程继续执行)，终止线程将会向等待着的线程广播“条件达成”的信息。

## 4.1.1 等待条件的达成

### 用条件变量来等待条件成立

list 4.1

## 4.1.2 使用条件变量构建线程安全队列


