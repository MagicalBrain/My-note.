# C++11 类默认函数的控制

## 类的默认函数

类的默认函数其实就是编译器默认生成的构造函数和运算符

在C++中声明自定义的类，编译器会默认生成一些构造函数，这些构造函数即使没有手动定义也会生成。

我们定义了一个类plugin,编译器会自动生成如下默认构造函数：

1. 构造函数
2. 拷贝构造函数
3. 拷贝赋值函数
4. 移动构造函数
5. 移动拷贝函数
6. 析构函数

此外还会生成默认操作符函数：

1. operator,
2. operator &
3. operator &&
4. operator *
5. operator ->
6. operator ->*
7. operator new
8. operator delete

一旦自定义了这些构造函数，那么编译器就不会自动生成默认构造函数

**注意**：
一旦自定义了构造函数，那么该数据类型就不是POD的了，换句话说，这个数据类型是没办法直接被C语言的函数使用的。

```cpp
#include <type_traits>
#include <iostream>

using namespace std;
class TwoCstor {

public:
    // 提供了带参数版本的构造函数，则必须自行提供
    // 不带参数版本，且TwoCstor不再是POD类型
    TwoCstor() {};
    TwoCstor(int i): data(i) {}

private:
    int data;
};

int main(){
    cout << is_pod<TwoCstor>::value << endl;     
    // 0
} 
// 编译选项:g++ -std=c++11 7-2-1.c
```

## default的作用

default关键字在这里可以重用，用来指明构造函数为默认。
通常用于扩展了类的构造函数的数据类型的类里头

```cpp
#include <type_traits>
#include <iostream>

using namespace std;

class TwoCstor {
public:

    // 提供了带参数版本的构造函数，再指示编译器
    // 提供默认版本，则本自定义类型依然是POD类型
    TwoCstor() = default;
    TwoCstor(int i): data(i) {}
private:
    int data;
};

int main(){
    cout << is_pod<TwoCstor>::value << endl;
    // 1
}
// 编译选项:g++ 7-2-2.cpp -std=c++11
```

## delete 的作用

在某些情况我们需要限制构造函数的使用，最经典的就是禁止使用这使用拷贝构造函数。

在C++98的时候我们的做法是将拷贝构造函数声明为private成员，并且不提供函数的实现。
这样一来一旦有人试图（有时候是无意的）使用拷贝构造函数，编译器就会报错。

```cpp
#include <type_traits>
#include <iostream>

using namespace std;

class NoCopyCstor {
public:
    NoCopyCstor() = default;
private:
    // 将拷贝构造函数声明为private成员并不提供实现
    // 可以有效阻止用户错用拷贝构造函数
    NoCopyCstor(const NoCopyCstor &);
};

int main(){
    NoCopyCstor a;
    NoCopyCstor b(a);    // 无法通过编译
}
// 编译选项:g++ 7-2-3.cpp -std=c++11
```

**注意：**
不生成默认函数的话，自定义该函数也是不行的。

## 在类定义的外面使用 =default 和 =delete

* =default

```cpp
class DefaultedOptr{
public:
    // 使用“= default”来产生缺省版本
    DefaultedOptr() = default;

    // 这里没使用“= default”
    DefaultedOptr & operator = (const DefaultedOptr & );
};

// 在类定义外用“= default”来指明使用缺省版本
inline DefaultedOptr &

DefaultedOptr::operator =( const DefaultedOptr & ) = default;
// 编译选项:g++ -std=c++11-c 7-2-5.cpp
```

* =deleted

不过显式删除也并非局限于成员函数，使用显式删除还可以避免编译器做一些不必要的隐式数据类型转换。我们来看看代码清单7-12所示的例子。

```cpp
class ConvType {
public:
    ConvType(int i) {};
    ConvType(char c) = delete;  // 删除char版本
};

void Func(ConvType ct) {}

int main() {
    Func(3);
    Func('a');  // 无法通过编译
    ConvType ci(3);
    ConvType cc('a');    // 无法通过编译
}
// 
```

本来char到int是隐式类型转换，是可以通过编译的，但是现在 =deleted显示删除了char类型对应的构造函数，这样隐式转换就不能通过编译了。

## explicit关键字对 =default 和 =deleted 的影响


