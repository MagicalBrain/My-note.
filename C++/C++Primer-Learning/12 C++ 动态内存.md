# 12 C++ 动态内存

## 动态内存与智能指针

动态内存的使用很容易出现问题：
1. 忘记释放内存 导致**内存泄漏**
2. 在还有指针引用的时候，就释放了它的内存空间 导致**野指针**（引用了非法内存的指针）

为了更容易，同时也是为了更安全地使用动态内存，新的标准库提供了两类**智能指针**：
1. shared_ptr
2. unique_ptr

头文件：
```cpp
#include <memory>
```

智能指针的的行为类似于普通指针，但不同的是它可以自动释放所指向的对象所占用的内存。

## shared_ptr

首先指针也是模板

检测智能指针是否为空：

```cpp
// 先检查p1是否为空，再检查它是否指向一个空的string
if (p1 && p1->emptuy())
    *p1 = "hi";     //如果 p1 指向一个空的string，解引用p1，将一个新的字符串"hi"赋予p1指向的string
```

### shared_ptr 和 unique_ptr都支持的操作

```cpp
shared_ptr<T> sp    // 空智能指针，可以指向类型为T的对象
unique_ptr<T> up

p   // 将p用作一个条件判断，若p指向一个对象，则为true
*p  // 解引用p，获得它指向的对象
p->mem  // 等价于 (*p).mem
p.get()     // 返回p中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了

swap(p, q)  // 交换p和q中的指针
p.swap(q)
```

### shared_ptr 独有的操作

```cpp
make_shared<T> args     // 返回一个shared_ptr 对象，指向一个动态分配的类型为T的对象，并使用args初始化此对象。

shared_ptr<T> p(q)      // p是shared_ptr q 的拷贝；此操作会递增q中的计数器。q中的计数器必须能转换为T*

p = q       // p和q都是shared_ptr，所保存的指针必须能相互转换。
            // 操作会递减p的引用计数，同时递增q的引用计数
            // 若p的引用计数变为0，则见其管理的内存释放

p.unique()  // 若p.use_count() = 1，返回true，否则返回false

p.use_count() // 返回 与p共享的智能指针的数量；较慢，主要用于调试（release版本建议删除）
```

### make_shared 函数

最安全的分配和使用动态内粗你的方法是调用一个`make_shared`函数

此函数在动态内存中分配一个对象并初始化它；
返回指向此对象的`shared_ptr`。

用法：

```cpp
// 指向一个值为42的int的shared_ptr
shared_ptr<int> p3 = make_shared<int>(42);

// p4指向一个值为"9999999999"的string
shared_ptr<string> p4 = make_shared<string>(10, '9');

// p5指向一个值初始化的
shared_ptr<int> p5 = make_shared<int> ();
```

### weak_ptr

## unique_ptr
