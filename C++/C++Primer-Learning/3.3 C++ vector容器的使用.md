# 3.3 C++ vector容器的使用

vector是一个表示对象的集合，其中所有的对象的类型都是相同的。

## 包含的头文件

```cpp
#include <vector>
using std::vector;
```

## vector的相关描述

vector实质是一个类模板。模板的定义比较考验个人对C++的理解，但运用不难。

模板本身不是类或函数，它应该被看作是编译器生成类或函数的一份说明书。

编译器根据模板创建类或函数的过程称为**实例化**，即当使用模板的时候应当告诉编译器应把类模板或函数模板实例化为哪种类型。

**注意**：vector里的对象类型仍然可以是vector，例如：
```cpp
vector<vector<int>> x;
```

这个定义仍然是合法的。

## vector的定义和初始化对象

vector支持的初始化方式有：
1. 列表初始化
2. 值初始化

### 3.3.1节 练习

#### 练习3.12:下列vector对象的定义有不正确的吗？如果有，请指出来。对于正确的描述其执行结果；对于不正确的，说明其错误的原因。

（a） ```vector<vector<int>> ivec;```
（b） ```vector<string> svec = ivec;```
（c） ```vector<string> svec (10,＂null＂);```

都是正确的。

a. 是定义了一个包含vector<int>类型的vector
b. 是定义了一个包含string的vecter类型的svec，并将同类型的ivec的值复制给svec
c. 定义了包含string的vecter类型svec，同时初始化其包含有10个"null"字符串

#### 练习3.13:下列的vector对象各包含多少个元素？这些元素的值分别是多少？

（a） vector<int> v1；
（b） vector<int> v2（10）；
（c） vector<int> v3 （10， 42）；
（d） vector<int> v4｛10｝；
（e） vector<int> v5｛10， 42｝；
（f） vector<string> v6（10)；
（g） vector<string> v7｛10， ＂hi＂｝；

a. 0个元素
b. 10个元素，每个元素的值为0
c. 10个元素，每个元素的值为42
d. 一个元素，值为10
e. 2个元素，值分别为10和42
f. 10个空字符串
g. 两个元素，一个是ASCII码为10的字符，另一个是"hi"字符串

3.12和3.13的代码都在`vector-initialization.cpp`里

## 向vector中添加元素

使用`vector`的`push_back`成员函数

例如：
```cpp
vector<int> v;
for (int i = 0; i < 10; i++)
{
    v.push_back(i);
}
```

### `std::Vector::push_back()`的更好替代：`std::Vector::emplace_back()`

还可以使用`std::Vector::emplace_back()`函数

`std::Vector::emplace_back()`和`std::Vector::push_back()`的作用都是在`vector`的尾部添加新元素。
`std::Vector::emplace_back()`与`std::Vector::push_back()`的区别在于性能：
1. `std::Vector::push_back()`添加元素的时候会先创建这个元素然后将要添加的元素拷贝或者移动到容器里
2. 而`std::Vector::emplace_back()`则是直接在`vector`的尾部创建这个元素，省去了拷贝或移动的过程，所以性能会高一些。

### 3.3.2节 练习

#### 练习3.14:编写一段程序，用cin读入一组整数并把它们存入一个vector对象。

**vector-pushback.cpp**

```cpp
#include <iostream>
#include <vector>

using namespace std;
using std::vector;

int main() {
    vector<int> v;
    int num;

    while (cin >> num)  //注意：在键盘上输入EOF文件终止符才会终止输入
    {
        v.push_back(num);
    }
    cout << endl;   //这一行为啥没执行？
    
    for (int i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    cout << endl;
    
    return 0;
}
```

**注意**：
windows上文件终止符是：
Linux上文件终止符是：
macOS上文件终止符是：`control + D`

有时候可能需要按两下

#### 练习3.15:改写上题的程序，不过这次读入的是字符串。

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;
using std::vector;

int main() {
    //vector<int> v;
    vector<string> v;
    //int num;
    string num;

    while (cin >> num)  //注意：在键盘上输入EOF文件终止符才会终止输入
    {
        v.push_back(num);
    }
    cout << endl;   //这一行为啥没执行？
    
    for (int i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    cout << endl;
    
    return 0;
}
```


## 其他vector操作

`v.empty()`
如果v不含有任何元素，返回真：否则返回假

`v.size()`
返回v中元素的个数

`v.push_back(t) `
向v的尾端添加一个值为t的元素

`v[n]`
返回v中第n个位置上元素的引用

`v1 = v2`
用v2中元素的拷贝替换v1中的元素

`v1= {a,b,c...} `
用列表中元素的拷贝替换v1中的元素

`v1 == v2`
v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同

`v1 != v2`


`<, <=, >, >=`
顾名思义，以字典顺序进行比较

在访问vector元素的时候，建议使用范围`for`语句，这样可以有效避免下标越界导致的**缓冲区溢出**(Buffer Overflow)

例如：
```cpp
//使用范围for语句来输出vecoter里的元素，注意这是c++11标准里才有的写法，可能会报错或者有警告
for (auto i : v)
{
    cout << i << " ";
}
```

### `v[n]`的更好替代`v.at(n)`

使用`v[n]`的时候不会检查n的合理性、是否会越界，而`v.at(n)`会检查n的合理性，如果越界将抛出`out_of_range`异常

### 3.3.3节 练习

#### 练习3.16:编写一段程序，把练习3.13中vector对象的容量和具体内容输出出来。检验你之前的回答是否正确，如果不对，回过头重新学习3.3.1节（第87页）直到弄明白错在何处为止。

**vector-check.cpp**

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;
using std::vector;

static int cnt = 1;

bool vector_check(vector<int> v) {
    cout << "cnt: " << cnt++ << endl;
    if (v.size() < 1)
        return false;
    else {
        for (auto i : v)
            cout << i << " ";
        cout << endl;
    }
    return true;
}

bool vector_check(vector<string> v) {
    cout << "cnt: " << cnt++ << endl;
    if (v.size() < 1)
        return false;
    else {
        for (auto i : v)
            cout << i << " ";
        cout << endl;
    }
    return true;
}

int main() {
    //练习 3.13
    vector<int> v1;
    vector<int> v2(10);
    vector<int> v3(10,42);
    vector<int> v4{10};
    vector<int> v5{10, 42};
    vector<string> v6{10};
    vector<string> v7{10, "hi"};
    //练习 3.16
    vector_check(v1);
    vector_check(v2);
    vector_check(v3);
    vector_check(v4);
    vector_check(v5);
    vector_check(v6);
    vector_check(v7);
    return 0;
}
```

输出结果：
```
cnt: 1
cnt: 2
0 0 0 0 0 0 0 0 0 0 
cnt: 3
42 42 42 42 42 42 42 42 42 42 
cnt: 4
10 
cnt: 5
10 42 
cnt: 6
          
cnt: 7
hi hi hi hi hi hi hi hi hi hi
```

#### 练习3.17:从cin读入一组词并把它们存入一个vector对象，然后设法把所有词都改写为大写形式。输出改变后的结果，每个词占一行。

提示：
可使用cctype头文件里的toupper()函数

**vector-string2upper.cpp**

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <cctype>

using namespace std;
using std::vector;
using std::string;

int main() {
    string in;
    vector<string> v;
    while (cin >> in)
    {
        v.push_back(in);
    }

    for (auto i : v) {
        for (auto &c : i) {
            c = toupper(c);
        }
        cout << i << endl;
    }
    
    return 0;
}
```

#### 练习3.18:下面的程序合法吗？如果不合法，你准备如何修改？

```cpp
vector<int> ivec;
ivec[0] = 42;
```

明显不合法，应改成：

```cpp
vector<int> ivec;
ivec.push_back(42);
```

因为ivec是一个初始化为空的vector对象，不能通过引用下标的方式来添加元素。

#### 练习3.19:如果想定义一个含有10个元素的vector对象，所有元素的值都是42，请列举出三种不同的实现方法。哪种方法更好呢？为什么？

```cpp
vector<int> v(10, 42);
vector<int> v = {42, …… ,42};   //花括号里有10个42
vector<int> v;
for (int i = 0; i < 10; i++) {
    v.push_back(42);
}
```

个人认为采用值初始化的方法最方便。

#### 练习3.20:读入一组整数并把它们存入一个vector对象，将每对相邻整数的和输出出来。改写你的程序，这次要求先输出第1个和最后1个元素的和，接着输出第2个和倒数第2个元素的和，以此类推。

```cpp
#include <iostream>
#include <vector>

using namespace std;
using std::vector;

int main() {
    vector<int> v;
    int num;
    while (cin >> num)
    {
        v.push_back(num);
    }
    cout << "输出相邻元素的和：" << endl;
    for (int i = 0; i < v.size(); i++) {
        cout << v[i] + v[i + 1] << " ";
    }
    cout << endl;

    cout << "输出首尾元素的和：" << endl;
    for (int i = 0, j = v.size() - 1; i < j; i++, j--)
    {
        cout << v[i] + v[j] << " ";
    }
    cout << endl;
    
    return 0;
}
```
