# 15 C++类的面向对象设计

## 15.1 OOP概述

面向对象的核心思想是：

1. 数据抽象
2. 继承
3. 动态绑定

### 继承

在继承这一层次关系中，被继承的类为==基类==，继承基类的类则称为==派生类==

派生类继承基类的接口有两种：

1. 直接继承函数
   1. 派生类可以直接将此类型的函数拿过来用而无需声明定义
2. 虚函数
   1. 基类里声明，派生类可自由覆写一个自己的版本的同名函数，但派生类必须对重新定义的函数进行声明

任何非构造函数的非静态函数都可以是虚函数。

关键字`virtual`只能出现在类内部的声明里而不能出现在类外的函数定义

如果一个基类把一个函数声明为虚函数，那么在其派生类里该函数也是一个隐式的虚函数。

### 动态绑定

动态绑定就是用一段代码实现分别处理Quote类和Bulk_quote类的对象。即虚函数

由于运行那个虚函数的版本是由实参决定的，即在运行时选择函数的版本，所以动态绑定又称之为运行时绑定

在C++中，当我们通过基类的引用或者指针调用一个虚函数时将会发生动态绑定。

### 例子

```cpp
class Quote {
public:
    std::string isbn() const;
    virtual double net_price(std::size_t n) const;
};

class Bulk_quote : public Quote
{
public:
    double net_price(std::size_t) const override;
};
```

net_price既能被Quote类的对象调用也可以被Bulk_quote类的对象调用

## 15.2 定义基类和派生类

### 15.2.1 定义基类

```cpp
class Quote {
public:
    Quote() = defaule;
    Quote(const std::string &book, double sales_price) :
        bookNo(book), 
        price(sales_price) 
    {}
    virtual ~Quote() = default;

    std::string isbn() const {return bookNo};
    
    virtual double net_price(std::size_t n) const {return n * price};

private:
    std::string bookNo;

protected:
    double price = 0.0;
};
```

### 例子

## 15 练习

### 15.2.1 练习

#### 练习 15.1 什么是虚成员？

#### 练习 15.2 protected访问说明符于private有何区别

#### 练习 15.3 定义自己的Quote类和print_total函数

## 15.2.2 练习
