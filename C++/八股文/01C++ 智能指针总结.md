# 01C++ 智能指针总结

## 什么是智能指针？

## 为什么要用智能指针？

智能指针的作用其实就是管理一个指针，避免申请的内存空间在函数结束的时候忘记释放，造成内存泄漏这种情况发生。

## 智能指针的常用接口

```cpp
T* get();
T& operator*();
T* operator->();
T& operator=(const T& val);
T* release();

void reset(T* ptr = nullptr);
```

* T是模板参数，也就是传入的类型
* get()用来获取`auto_ptr`封装在内部的指针，也就是获取原生指针
* 重载了`->, =`
* release()将auto_ptr封装在内部的指针置为nullptr，但并不会破坏指针所指向的内容，函数返回的是内部指针置空之前的值。
* 直接释放封装内部指针所指向的内存，如果指定了ptr的值，则将内部指针初始化为该值（否则将其设置为nullptr）

## auto_ptr

在C++98中提出，但在C++11已被抛弃

采用的是所谓**所有权模式**

```cpp
// SmartPtr.cpp
#include <iostream>
#include <string>
#include <memory>

int main()
{
    std::cout << "Hello World!\n";

    std::auto_ptr<std::string> p1(new std::string("hello"));
    std::auto_ptr<std::string> p2;
    
    // 执行结束这条语句后p1对象的所有权就交到了p2的手上
    p2 = p1;

    // 访问p2没有问题
    std::cout << p2->c_str() << std::endl;
    // 访问p1会触发中断，因为此时p1已没有对象的所有权了
    std::cout << p1->c_str() << std::endl;
    return 0;
}
```

上面这个例子说明了auto_ptr如果没有被正确的使用会触发内存崩溃问题

## unique_ptr

这个是用来替换auto_ptr的，它可以实现独占拥有某个资源，用来保证同一时间内只有一个智能指针可以指向该对象的时候特别有用，可以很好地避免资源泄露。

使用上是一样的，但是比auto_ptr 更安全

```cpp
std::unique_ptr<std::string> p1(new std::string("hello"));
std::unique_ptr<std::string> p2;

// 这句就编译器就直接报错了，编译不通过，无法运行
p2 = p1;

// 后面的代码都不执行了
std::cout << p2->c_str() << std::endl;
std::cout << p1->c_str() << std::endl;
```

## shared_ptr（共享型，强引用）

shared_ptr 实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在 “最后一个引用被销毁”时候释放。从名字 share 就可以看出了资源可以被多个指针共享，它使 用计数机制来表明资源被几个指针共享。

`use_count()`
可以通过成员函数 use_count() 来查看资源的所有者个数，除了可以通过 new 来构造，还可 以通过传入auto_ptr, unique_ptr,weak_ptr 来构造。当我们调用 release() 时，当前指针会释放 资源所有权，计数减一。当计数等于 0 时，资源会被释放。

shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性 (auto_ptr 是独占的)，在使用引用 计数的机制上提供了可以共享所有权的智能指针。

```cpp
#include <iostream>
#include <memory>
#include <thread>
#include <chrono>
#include <mutex>
 
struct Base
{
    Base() { std::cout << "  Base::Base()\n"; }
    // 注意：此处非虚析构函数 OK
    ~Base() { std::cout << "  Base::~Base()\n"; }
};
 
struct Derived: public Base
{
    Derived() { std::cout << "  Derived::Derived()\n"; }
    ~Derived() { std::cout << "  Derived::~Derived()\n"; }
};
 
void thr(std::shared_ptr<Base> p)
{
    std::this_thread::sleep_for(std::chrono::seconds(1));
    std::shared_ptr<Base> lp = p; // 线程安全，虽然自增共享的 use_count
    {
        static std::mutex io_mutex;
        std::lock_guard<std::mutex> lk(io_mutex);
        std::cout << "local pointer in a thread:\n"
                  << "  lp.get() = " << lp.get()
                  << ", lp.use_count() = " << lp.use_count() << '\n';
    }
}
 
int main()
{
    std::shared_ptr<Base> p = std::make_shared<Derived>();
 
    std::cout << "Created a shared Derived (as a pointer to Base)\n"
              << "  p.get() = " << p.get()
              << ", p.use_count() = " << p.use_count() << '\n';
    std::thread t1(thr, p), t2(thr, p), t3(thr, p);
    p.reset(); // 从 main 释放所有权
    std::cout << "Shared ownership between 3 threads and released\n"
              << "ownership from main:\n"
              << "  p.get() = " << p.get()
              << ", p.use_count() = " << p.use_count() << '\n';
    t1.join(); t2.join(); t3.join();
    std::cout << "All threads completed, the last one deleted Derived\n";
}
```

```
  Base::Base()
  Derived::Derived()
Created a shared Derived (as a pointer to Base)
  p.get() = 00E42F5C, p.use_count() = 1
Shared ownership between 3 threads and released
ownership from main:
  p.get() = 00000000, p.use_count() = 0
local pointer in a thread:
  lp.get() = 00E42F5C, lp.use_count() = 6
local pointer in a thread:
  lp.get() = 00E42F5C, lp.use_count() = 4
local pointer in a thread:
  lp.get() = 00E42F5C, lp.use_count() = 2
  Derived::~Derived()
  Base::~Base()
All threads completed, the last one deleted Derived
```

### 循环引用造成的内存泄露问题

例子：

```cpp
#include <iostream>
#include <memory>

class B;
class A
{
public:
	A() {
		std::cout << "A()" << std::endl;
	}
	~A() {
		std::cout << "~A()" << std::endl;
	}
public:
	std::shared_ptr<B> spa;
};
class B
{
public:
	B() {
		std::cout << "B()" << std::endl;
	}
	~B() {
		std::cout << "~B()" << std::endl;
	}
public:
	std::shared_ptr<A> spb;
};

int main()
{
	std::shared_ptr<A> pa(new A());
	std::shared_ptr<B> pb(new B());
	pa->spa = pb;
	pb->spb = pa;
	return 0;
}
```

运行结果如下：

![](C++%20智能指针总结.asset/shared_ptr_lock.png)

## weak_ptr

weak_ptr 是一种不控制对象生命周期的智能指针，它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。

weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另 一个 weak_ptr 对象构造,，它的构造和析构不会引起引用记数的增加或减少。

weak_ptr 是用来解决 shared_ptr 相互引用时的~~死锁~~内存泄漏问题，如果说两个 shared_ptr 相互引用， 那么这两个指针的引用计数永远不可能下降为0，也就是资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和 shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调用 lock 函数来获得shared_ptr。

当两个智能指针都是 shared_ptr 类型的时候，析构时两个资源引用计数会减一，但是两者引 用计数还是为 1，导致跳出函数时资源没有被释放(的析构函数没有被调用)，解决办法:把 其中一个改为weak_ptr就可以。

将上面的循环引用代码改为：

```cpp
#include <iostream>
#include <memory>

class B;
class A
{
public:
	A()
	{
		std::cout << "A()" << std::endl;
	}
	~A()
	{
		std::cout << "~A()" << std::endl;
	}
public:
	std::shared_ptr<B> spa;
};
class B
{
public:
	B()
	{
		std::cout << "B()" << std::endl;
	}
	~B()
	{
		std::cout << "~B()" << std::endl;
	}
public:
	//std::shared_ptr<A> spb;
	std::weak_ptr<A> spb;
};

int main()
{
	std::shared_ptr<A> pa(new A());
	std::shared_ptr<B> pb(new B());
	pa->spa = pb;
	pb->spb = pa;
	return 0;
}
```

输出结果：

![](C++%20智能指针总结.asset/weak_ptr.png)

## 总结

||auto_ptr|unique_ptr|shared_ptr|weak_ptr|
|--|--|--|--|--|
|对象管理所有权|||||

## 智能指针和普通指针相互转换

### shared_ptr与普通指针互转

* shared_ptr 转 普通指针

```cpp
// shared_ptr to 普通指针
// 定义一个shared_ptr并分配内存资源
std::shared_ptr<type> sptr = std::make_shared<type>();

// 可以通过shared_ptr::get()接口来直接获得
type* cptr = sptr.get();
```

* 普通指针 转 shared_ptr

```cpp
// 普通指针 to shared_ptr
// 定义一个shared_ptr
std::shared_ptr<std::string> str_sptr;

// 定义一个普通指针并分配内存
std::string* str_ptr = new std::string("a string");

// 调用 shared_ptr::reset() 来将普通指针赋值給它
str_sptr.reset(str_ptr);

// 注意要和new成对使用
delete str_ptr;
```
