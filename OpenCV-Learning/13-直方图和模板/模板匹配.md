# openCV里的模板匹配

## matchTemplate()

openCV自带的模板匹配函数，声明如下：

```cpp
void cv::matchTemplate(	
    InputArray 	image,
    InputArray 	templ,
    OutputArray 	result,
    int 	method,
    InputArray 	mask = noArray() 
)	
```

包含头文件：
```
#include <opencv2/imgproc.hpp>
```

Compares a template against overlapped image regions.
比较图像中和模板重叠的区域。

The function slides through image , compares the overlapped patches of size $(w \times h)$ against templ using the specified method and stores the comparison results in result . 
这个函数通过在图像中滑动模板、比较与模板相同的尺寸下重叠的区域，并使用特定的方法比较，存储结果。

**TemplateMatchModes** describes the formulae for the available comparison methods ( $(I)$ denotes image, $(T)$ template, $(R)$ result, $(M)$ the optional mask ). 
模板匹配模式描述的是可使用的匹配方法的公式。

The summation is done over template and/or the image patch: $(x' = 0...w-1, y' = 0...h-1)$

After the function finishes the comparison, the best matches can be found as global minimums (when TM_SQDIFF was used) or maximums (when TM_CCORR or TM_CCOEFF was used) using the minMaxLoc function. In case of a color image, template summation in the numerator and each sum in the denominator is done over all of the channels and separate mean values are used for each channel. That is, the function can take a color template and a color image. The result will still be a single-channel image, which is easier to analyze.

## Parameters

image	Image where the search is running. It must be 8-bit or 32-bit floating-point.

templ	Searched template. It must be not greater than the source image and have the same data type.

result	Map of comparison results. It must be single-channel 32-bit floating-point. If image is \(W \times H\) and templ is \(w \times h\) , then result is \((W-w+1) \times (H-h+1)\) .

method	Parameter specifying the comparison method, see TemplateMatchModes

mask	Optional mask. It must have the same size as templ. It must either have the same number of channels as template or only one channel, which is then used for all template and image channels. If the data type is CV_8U, the mask is interpreted as a binary mask, meaning only elements where mask is nonzero are used and are kept unchanged independent of the actual mask value (weight equals 1). For data tpye CV_32F, the mask values are used as weights. The exact formulas are documented in TemplateMatchModes.

## Examples:

samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp.

```cpp
#include "opencv2/imgcodecs.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/imgproc.hpp"
#include <iostream>

using namespace std;
using namespace cv;

bool use_mask;

Mat img; 
Mat templ; 
Mat mask; 
Mat result;

const char* image_window = "Source Image";
const char* result_window = "Result window";

int match_method;
int max_Trackbar = 5;

void MatchingMethod( int, void* );

int main( int argc, char** argv )
{
    if (argc < 3)
    {
        cout << "Not enough parameters" << endl;
        cout << "Usage:\n" << argv[0] << " <image_name> <template_name> [<mask_name>]" << endl;
        return -1;
    }
    img = imread( argv[1], IMREAD_COLOR );
    templ = imread( argv[2], IMREAD_COLOR );
    if(argc > 3) {
        use_mask = true;
        mask = imread( argv[3], IMREAD_COLOR );
    }
    if(img.empty() || templ.empty() || (use_mask && mask.empty()))
    {
        cout << "Can't read one of the images" << endl;
        return EXIT_FAILURE;
    }

    namedWindow( image_window, WINDOW_AUTOSIZE );
    namedWindow( result_window, WINDOW_AUTOSIZE );
    
    const char* trackbar_label = "Method: \n 0: SQDIFF \n 1: SQDIFF NORMED \n 2: TM CCORR \n 3: TM CCORR NORMED \n 4: TM COEFF \n 5: TM COEFF NORMED";
    
    createTrackbar( trackbar_label, image_window, &match_method, max_Trackbar, MatchingMethod );
    MatchingMethod( 0, 0 );
    waitKey(0);
    return EXIT_SUCCESS;
}

void MatchingMethod( int, void* )
{
    Mat img_display;
    
    img.copyTo( img_display );
    
    int result_cols =  img.cols - templ.cols + 1;
    int result_rows = img.rows - templ.rows + 1;
    
    result.create( result_rows, result_cols, CV_32FC1 );
    
    bool method_accepts_mask = (TM_SQDIFF == match_method || match_method == TM_CCORR_NORMED);
    
    if (use_mask && method_accepts_mask)
    { 
        matchTemplate( img, templ, result, match_method, mask); 
    }
    else
    { 
        matchTemplate( img, templ, result, match_method); 
    }
    
    normalize( result, result, 0, 1, NORM_MINMAX, -1, Mat() );
    
    double minVal;
    double maxVal; 
    
    Point minLoc;
    Point maxLoc;
    Point matchLoc;
    
    minMaxLoc( result, &minVal, &maxVal, &minLoc, &maxLoc, Mat() );
    
    if( match_method  == TM_SQDIFF || match_method == TM_SQDIFF_NORMED )
    { 
        matchLoc = minLoc; 
    }
    else
    { 
        matchLoc = maxLoc; 
    }
  
    rectangle( img_display, matchLoc, Point( matchLoc.x + templ.cols , matchLoc.y + templ.rows ), Scalar::all(0), 2, 8, 0 );
    rectangle( result, matchLoc, Point( matchLoc.x + templ.cols , matchLoc.y + templ.rows ), Scalar::all(0), 2, 8, 0 );
    imshow( image_window, img_display );
    imshow( result_window, result );
    return;
}
```
