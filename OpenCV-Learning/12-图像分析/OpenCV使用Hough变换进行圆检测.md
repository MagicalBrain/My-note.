# OpenCV使用Hough变换进行圆检测

Hough变换有很多种，这里主要介绍圆变换。

## 基本原理

与霍夫线变换的原理类似，只不过从累加平面面积变成了累加三维体积。
这样做会大大增加内存消耗，降低运算速度，但是opencv使用了一种名为霍夫梯度的方法来避免这些问题。

### 霍夫梯度法

Hough梯度法工作过程如下：
1. 对图像进行边缘检测（这里使用cv::Canny（）） ；
2. 然后，对每个轮廓图像中的非零点，考虑局部梯度（我们通过首先通过cv::sobel（）计算－阶Sobel x-导数和y-导数来计算梯度） 。
3. 通过这个梯度，我们沿着这个斜率表示的线在累加器内从一个最小值到一个最大值遍历每个点，同时，记录轮廓图像中每个非零像素所在的位置。
4. 然后候选圆心就从这些（二维）累加器中分离出来，这些点都高于一个阈值且同时大于其所有直接相邻的点。这些点根据其累加器值的降序排列，使得最有可能是圆心的点排在前面。
5. 然后，对于每个圆心，考虑所有非零像素点（之前已经构建好该列表） ，将这些像素根据离圆心的距离排序。从最小距离到最大半径中选择一个最好的值作为圆的半径。如果有足够数量的点组合成一个圆并且其圆心与之前选中圆心的距离足够大，就保留这个圆心。

这种实现使得算法有足够的速度，更重要的是克服了三维累加器的其他稀疏群体问题，避免了大量噪声的产生。

#### 需要注意的问题

**1、sobel导数计算局部梯度**：

应该期望在输出中产生噪音？

**2、考虑候选圆心的时候**：
要考虑所有非零像素点，因此阈值过低，算法运行就越慢。

**3、同心圆问题**
如果出现了同心圆，最终只能获得一个圆。

**4、算法更倾向于保留大的圆**

## Hough圆变换的使用

### cv::HoughCircles

**`cv::HoughCircles`的声明**

```cpp
void cv::HoughCircles	(	
    InputArray 	image,
    OutputArray 	circles,
    int 	method,
    double 	dp,
    double 	minDist,
    double 	param1 = 100,
    double 	param2 = 100,
    int 	minRadius = 0,
    int 	maxRadius = 0 
)	
```

### 使用cv::cuda::HoughCirclesDetector类来进行圆检测


