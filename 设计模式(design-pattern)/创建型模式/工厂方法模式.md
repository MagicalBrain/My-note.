# 工厂方法模式(Factory Method Pattern)

工厂方法模式又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。

## 基本介绍

假设现在的场景是 `简单工厂模式.md` 里的水果工厂

我们现在不仅对对水果进行抽象，还对工厂进行抽象，使得一个具体工厂生产一个具体水果。

但我们新增水果的时候，除了新的水果类，我们还需要新的具体工厂类。

这样一来我们发现，每当新增一种水果，类的个数就会成倍增加，导致类越来越多，增加维护成本。
但是好处就是符合开闭原则

## 实例代码

```cpp
// 工厂方法模式
// Factory Method Pattern
// 
// 这里用一个水果公司的例子来说明
//

#pragma once

#include <iostream>
#include "SimpleFactoryPattern.hpp"



/// @brief 水果工厂类 abstract
class AbstractFruitFactory
{
public:
	AbstractFruitFactory() = default;
	~AbstractFruitFactory() = default;

	virtual Fruit* CreatFruit() = 0;

private:

};

/// @brief 苹果工厂
class AppleFactory : public AbstractFruitFactory
{
public:
	AppleFactory() = default;
	~AppleFactory() = default;

	virtual Fruit* CreatFruit() {
		return new Apple;
	}

private:

};

/// @brief 香蕉工厂
class BananaFactory : public AbstractFruitFactory
{
public:
	BananaFactory() = default;
	~BananaFactory() = default;

	virtual Fruit* CreatFruit() {
		return new Banana;
	}

private:

};

/// @brief 鸭梨工厂
class PearFactory : public AbstractFruitFactory
{
public:
	PearFactory() = default;
	~PearFactory() = default;

	virtual Fruit* CreatFruit() {
		return new Pear;
	}

private:

};

void testFactoryMethodPattern() {
	AbstractFruitFactory* factory = nullptr;
	Fruit* fruit = nullptr;

	// 吃苹果
	factory = new AppleFactory;
	fruit = factory->CreatFruit();
	fruit->showName();

	// 吃香蕉
	factory = new BananaFactory;
	fruit = factory->CreatFruit();
	fruit->showName();

	// 吃鸭梨
	factory = new PearFactory;
	fruit = factory->CreatFruit();
	fruit->showName();

	delete factory;
	delete fruit;
}

```

## 总结

工厂方法模式 = 简单工厂模式 + 开闭原则

优点：
1. 不需要去记类名，甚至参数名也不需要记忆
2. 实现了对象创建和使用的分离
3. 系统的可扩展性也就变得非常好，无需修改接口和原先的类

缺点：
1. 增加系统中的类的个数，复杂度、抽象性和理解难度都增加了
2. 
