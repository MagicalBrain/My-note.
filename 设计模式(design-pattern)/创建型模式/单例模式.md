# 单例模式

单例模式(Singleton Pattern，也称为单件模式)

使用最广泛的设计模式之一。其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。

定义一个单例类：

1. 构造函数私有化
   1. 私有化它的构造函数，以防止外界创建单例类的对象；
2. 增加静态私有的当前类的指针变量
   1. 使用类的私有静态指针变量指向类的唯一实例；
3. 提供静态对外接口
   1. 可以让用户使用一个公有的静态方法获取该实例。
4. 

## 懒汉版

（Lazy Singleton）
教学版，即懒汉版（Lazy Singleton）：单例实例在第一次被使用时才进行初始化，这叫做延迟初始化。

```cpp
// version 1.0
class Singleton
{
private:
	static Singleton* instance;
private:
	Singleton() {};
	~Singleton() {};
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
public:
	static Singleton* getInstance() 
        {
		if(instance == NULL) 
			instance = new Singleton();
		return instance;
	}
};

// init static member
Singleton* Singleton::instance = NULL;
```

### 问题1：Lazy Singleton存在内存泄露的问题，有两种解决方法：

使用智能指针
使用静态的嵌套类对象
对于第二种解决方法，代码如下：

```cpp
// version 1.1
class Singleton
{
private:
	static Singleton* instance;
private:
	Singleton() { };
	~Singleton() { };
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
private:
	class Deletor {
	public:
		~Deletor() {
			if(Singleton::instance != NULL)
				delete Singleton::instance;
		}
	};
	static Deletor deletor;
public:
	static Singleton* getInstance() {
		if(instance == NULL) {
			instance = new Singleton();
		}
		return instance;
	}
};

// init static member
Singleton* Singleton::instance = NULL;
```

在程序运行结束时，系统会调用静态成员deletor的析构函数，该析构函数会删除单例的唯一实例。使用这种方法释放单例对象有以下特征：

1. 在单例类内部定义专有的嵌套类。
2. 在单例类内定义私有的专门用于释放的静态成员。
3. 利用程序在结束时析构全局变量的特性，选择最终的释放时机。

在单例类内再定义一个嵌套类，总是感觉很麻烦。

### 问题2：这个代码在单线程环境下是正确无误的，但是当拿到多线程环境下时这份代码就会出现race condition

注意version 1.0与version 1.1都不是线程安全的。要使其线程安全，能在多线程环境下实现单例模式，我们首先想到的是利用同步机制来正确的保护我们的shared data。可以使用双检测锁模式（DCL: Double-Checked Locking Pattern）：

```cpp
static Singleton* getInstance() {
	if(instance == NULL) {
		Lock lock;  // 基于作用域的加锁，超出作用域，自动调用析构函数解锁
        if(instance == NULL) {
        	instance = new Singleton();
        }
	}
	return instance;
}
```

注意，线程安全问题仅出现在第一次初始化（new）过程中，而在后面获取该实例的时候并不会遇到，也就没有必要再使用lock。双检测锁很好地解决了这个问题，它通过加锁前检测是否已经初始化，避免了每次获取实例时都要首先获取锁资源。

加入DCL后，其实还是有问题的，关于memory model。在某些内存模型中（虽然不常见）或者是由于编译器的优化以及运行时优化等等原因，使得instance虽然已经不是nullptr但是其所指对象还没有完成构造，这种情况下，另一个线程如果调用getInstance()就有可能使用到一个不完全初始化的对象。换句话说，就是代码中第2行：if(instance == NULL)和第六行instance = new Singleton();没有正确的同步，在某种情况下会出现new返回了地址赋值给instance变量而Singleton此时还没有构造完全，当另一个线程随后运行到第2行时将不会进入if从而返回了不完全的实例对象给用户使用，造成了严重的错误。在C++11没有出来的时候，只能靠插入两个memory barrier（内存屏障）来解决这个错误，但是C++11引进了memory model，提供了Atomic实现内存的同步访问，即不同线程总是获取对象修改前或修改后的值，无法在对象修改期间获得该对象。

因此，在有了C++11后就可以正确的跨平台的实现DCL模式了，利用atomic，代码如下：

```cpp
atomic<Widget*> Widget::pInstance{ nullptr };
Widget* Widget::Instance() {
    if (pInstance == nullptr) { 
        lock_guard<mutex> lock{ mutW }; 
        if (pInstance == nullptr) { 
            pInstance = new Widget(); 
        }
    } 
    return pInstance;
}
```

Best of All:

C++11规定了local static在多线程条件下的初始化行为，要求编译器保证了内部静态变量的线程安全性。在C++11标准下，《Effective C++》提出了一种更优雅的单例模式实现，使用函数内的 local static 对象。这样，只有当第一次访问getInstance()方法时才创建实例。这种方法也被称为Meyers' Singleton。C++0x之后该实现是线程安全的，C++0x之前仍需加锁。

```cpp
// version 1.2
class Singleton
{
private:
	Singleton() { };
	~Singleton() { };
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
public:
	static Singleton& getInstance() 
        {
		static Singleton instance;
		return instance;
	}
};
```

```cpp
#include <iostream>
#include <cassert>

class Singleton
{
public:
    static Singleton& Instance()
    {
        static Singleton instance;
        return instance;
    }

public:
    Singleton(const Singleton&) = delete;
    Singleton(Singleton&&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    Singleton& operator=(Singleton&&) = delete;

private:
    Singleton() = default;
    ~Singleton() = default;
};

int main()
{
    auto& a = Singleton::Instance();
    auto& b = Singleton::Instance();
    assert(&a == &b);

    return 0;
}
```

## 饿汉版

饿汉版（Eager Singleton）：指单例实例在程序运行时被立即执行初始化

```cpp
// version 1.3
class Singleton
{
private:
	static Singleton instance;
private:
	Singleton();
	~Singleton();
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
public:
	static Singleton& getInstance() {
		return instance;
	}
}

// initialize defaultly
Singleton Singleton::instance;
```

## 懒汉版和饿汉版的区别

说白了就是单例实例指针是否立即初始化。

懒汉版对静态类指针的初始化是在第一次调用`getInstance()`的时候进行，延迟初始化

而饿汉版对静态类指针的初始化则是在类外初始化的，比main函数还要早，立即初始化

## 单例模式下对象的释放问题

一般我们会想直接提供一个release接口来释放对象，例如：

```cpp
/// @brief 单例类A
/// @details 最基础的单例类
class SingletonA
{
public:
	static SingletonA* getInstance() {
		if (a == nullptr)
			a = new SingletonA;
		return a;
	}

	static void releaseInstance() {
		delete a;
	}

private:
	SingletonA() = default;
	~SingletonA() = default;

private:
	static SingletonA* a;
};
SingletonA* SingletonA::a = nullptr;
```


但是在团队协作开发的过程中，如果别的同事给你释放掉了内存，你不知道，那么整个软件会崩掉连错误日志都没有，你怎么debug可能都找不到原因。

==所以提供release接口太危险了==

接下来我们要考虑的是在单例模式中由于对象只有一个，那么是不是不释放内存空间也是可以呢？
不释放程序运行肯定也是不会有问题的。

但我们再考虑一下，如果

## 单例模式的使用场景

如果你需要一个类有且只有一个对象，那么就可以考虑用单例模式

## 单例模式的注意事项

定义单例类的时候注意：

1. 确保这个类是线程安全的
2. 注意初始化，不要让对象有可能为Null
3. 确保仅仅创建一个对象
4. 尽量想办法释放对象的内存
5. 尽量保证单例类暂用的内存不要太大

千万不要用单例类做以下事情：

1. 保存数据

## 补充：C++中static对象的初始化

non-local static对象（函数外）

C++规定，non-local static 对象的初始化发生在main函数执行之前，也即main函数之前的单线程启动阶段，所以不存在线程安全问题。但C++没有规定多个non-local static 对象的初始化顺序，尤其是来自多个编译单元的non-local static对象，他们的初始化顺序是随机的。

local static 对象（函数内）

对于local static 对象，其初始化发生在控制流第一次执行到该对象的初始化语句时。多个线程的控制流可能同时到达其初始化语句。

在C++11之前，在多线程环境下local static对象的初始化并不是线程安全的。具体表现就是：如果一个线程正在执行local static对象的初始化语句但还没有完成初始化，此时若其它线程也执行到该语句，那么这个线程会认为自己是第一次执行该语句并进入该local static对象的构造函数中。这会造成这个local static对象的重复构造，进而产生内存泄露问题。所以，local static对象在多线程环境下的重复构造问题是需要解决的。

而C++11则在语言规范中解决了这个问题。C++11规定，在一个线程开始local static 对象的初始化后到完成初始化前，其他线程执行到这个local static对象的初始化语句就会等待，直到该local static 对象初始化完成。

## 参考链接

[逼乎](https://zhuanlan.zhihu.com/p/37469260#:~:text=%E5%9C%A8C%2B%2B11%E6%A0%87%E5%87%86%E4%B8%8B%EF%BC%8C%E3%80%8AEffective%20C%2B%2B%E3%80%8B%E6%8F%90%E5%87%BA%E4%BA%86%E4%B8%80%E7%A7%8D%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%86%85%E7%9A%84%20local%20static,%E5%AF%B9%E8%B1%A1%E3%80%82%20%E8%BF%99%E6%A0%B7%EF%BC%8C%E5%8F%AA%E6%9C%89%E5%BD%93%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AE%BF%E9%97%AE%20getInstance%20%28%29%20%E6%96%B9%E6%B3%95%E6%97%B6%E6%89%8D%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E3%80%82)
