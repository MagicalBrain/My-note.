# CSharp多线程编程

## 线程的基本操作

### 创建线程

创建线程之前得先定义一个线程绑定的函数或方法，因为创建线程的时候需要绑定一个函数。例如：

```csharp
// 创建一个函数
        static void WriteY()
        {
            for (int i = 0; i < 10; ++i)
                Console.WriteLine("Y");
        }

        static public void ThreadDemo()
        {
            // 创建一个线程，并绑定线程函数
            Thread t = new Thread(WriteY);

            t.Start();
            
            for (int i = 0; i < 10; ++i)
                Console.WriteLine("X");

        }
```

在单核计算机上，操作系统会为每一个线程划分时间片（Windows系统的典型值为20毫秒）来模拟并发执行。
因此上述代码会出现连续的x和y。
而在一个多核心的机器上，两个线程可以并行执行（会和机器上其他执行的进程进行竞争）.
虽然我们还是会得到连续的x和y，但这却是由于Console处理并发请求的机制导致的。

线程一旦启动，其IsAlive属性就会返回true，直至线程停止。
当Thread的构造函数接收的委托执行完毕之后，线程就会停止。
线程停止之后就无法再启动了。

每一个线程都有一个Name属性用作调试用途。
这个属性在Visual Studio中尤其有用，因为线程的名称会显示在“Thread”窗口和“DebugLocation”工具栏上。
线程的名称只能够设置一次，试图修改线程的名称会抛出异常。

静态属性Thread.CurrentThread将返回当前正在执行的线程：
```csharp
Console.WriteLine(Thread.CurrentThread);
```

### 等待线程休眠

```csharp
Thread.Join()
```

### 暂停线程的操作

```csharp
Thread.Sleep()
```

### 线程的阻塞

当线程由于特定原因暂停执行，那么它就是阻塞的。例如，调用Sleep休眠或者Join等待其他线程执行结束。阻塞的线程会立刻交出它的处理器时间片，并从此开始不再消耗处理器时间。直至阻塞条件结束。可以使用ThreadState属性测试线程的阻塞状态：

```csharp
bool blocked = (t.ThreadState & ThreadState.WaitSleepJoin) != 0;
```

ThreadState限定为以下四个有用的值之一：Unstarted、Running、WaitSleepJoin、Stopped：

```csharp

```

ThreadState属性适用于诊断调试工作，但是不适合实现同步。因为线程的状态可能在测试ThreadState和获取这个信息的时间段内发生变化。当线程被阻塞或者解除阻塞时，操作系统就会进行一次上下文切换（context switch）。这会导致细小的开销，一般在1到2毫秒左右。

## I/O密集和计算密集

如果一个操作的绝大部分时间都在等待事件的发生，则称为I/O密集，例如下载网页或者调用Console.ReadLine。
（I/O密集操作一般都会涉及输入或者输出，但是这并非硬性要求。例如Thread.Sleep也是一种I/O密集的操作）。

而相反的，如果操作的大部分时间都用于执行大量的CPU操作，则称为计算密集。

### 阻塞与自旋

I/O密集操作主要表现为以下两种形式：
要么在当前线程同步进行等待，直至操作完成（例如Console.ReadLine、Thread.Sleep以及Thread.Join）；
要么异步进行操作，在操作完成的时候或者之后某个时刻触发回调函数（之后将详细介绍）。

同步的I/O密集操作的大部分时间都花费在阻塞线程上，但是也可能在一个定期循环中自旋：

```csharp
while (DateTime.Now < nextStartTime)
    Thread.Sleep(100);
```

虽然有更好的办法实现这种效果（例如使用定时器或者使用信号发送结构），但另外一种选择是令线程持续性自旋：

```csharp
while (DateTime.Now < nextStartTime)
```

一般来说，上述做法非常浪费处理器时间。因为CLR和操作系统都会认为这个线程正在执行重要的运算，因此就会为其分配相应的资源。因此从效果上来说我们将一个I/O密集的操作转变成了一个计算密集型操作

自旋与阻塞有一些细微的差别。首先，非常短暂的自旋在条件可以很快得到满足的场景（例如几毫秒）下是非常高效的，因为它避免了上下文切换带来的延迟和开销。.NET Framework提供了一些特殊的辅助方法和类来进行这一操作，请参见http://albahari.com/threading/的SpinLockand SpinWait。

其次，阻塞并非零开销。这是因为每一个线程在存活时会占用1MB的内存，并对CLR和操作系统带来持续性的管理开销。因此，阻塞可能会给繁重的I/O密集型程序（例如要处理成百上千的并发操作）带来麻烦。因此，这些程序更适于使用回调的方式，在等待时完全解除这些线程。我们将在后面讨论异步模式的时候介绍这种方法。

## 异常处理

## 前台线程与后台线程

一般情况下，显式创建的线程称为前台线程（Foreground thread）。
只要有一个前台线程还在运行，应用程序就仍然保持运行状态。

而后台线程（background thread）则不然。
当所有前台线程结束时，应用程序就会停止，且所有运行的后台线程也会随之终止。

线程的前台/后台状态和线程的优先级（执行时间的分配）无关。可以使用线程的IsBackground属性来查询或修改线程的前后台状态：

```csharp

```

## 富客户端应用程序的线程

## 任务

线程是创建并发的底层工具，因此它有一定的局限性。
特别是：
1. 虽然在线程启动时不难向其中传递数据，但是当线程Join后却难以从中得到“返回值”。通常不得不创建一些共享字段（来得到“返回值”）。此外，捕获和处理线程中操作抛出的异常也是非常麻烦的。· 
2. 在线程完成之后，就无法再次启动它，相反只能够将其Join（并阻塞当前操作线程）。这些局限性会影响细粒度并发性的实现。换言之，这种方式难以将小的并发组合成为大的并发操作（这对于异步编程而言非常重要，后面的章节将对此进行介绍），并会增加手动同步处理（例如使用锁、信号发送等）的依赖，而且很容易造成问题。

Task类型可以解决所有这些问题。
与线程相比，Task是一个更高级的抽象概念，它代表了一个并发操作，而该操作并不一定依赖线程来完成。
Task是可以组合（compositional）的（你可以将它们通过延续（continuation）操作串联在一起）。它们可以使用线程池减少启动延迟，也可以通过TaskCompletionSource采用回调的方式避免多个线程同时等待I/O密集型操作。

Task类型是Framework 4.0时，作为并行编程库的组成部分引入的。然而它们后来经历了许多改进（通过使用awaiter），从而在常见的并发场景中发挥了越来越大的作用。

Task类型也是C#异步功能的基础类型。

## 任务的基本操作

### 创建任务

**无返回值的方法**：

1、
```csharp
static public void CreateTask1()
{
    var t1 = new Task(
        () => {
            Console.WriteLine("任务开始工作……");
            //模拟工作过程, 休眠5秒
            Thread.Sleep(5000);
        }
    );

    t1.Start();
            
    Task.WaitAll(t1);
}
```

2、

## 并发与异步


