# 伯朗特机器人插件分析

## 文件结构

**include**
头文件
1. BorunteRobotPlugin.h

**src**
实现代码
1. BorunteRobotPlugin.cpp

**其他**


### BorunteRobotPlugin.h

```cpp
#pragma once
#include <robot/HYRobotPlugin.hpp>
#include <common/HYPluginFactory.hpp>
#include <io/TCPClient.h>

class BorunteRobotPlugin :public hy::HYRobotPlugin
{
public:
	BorunteRobotPlugin();
	virtual ~BorunteRobotPlugin();
public:
	virtual int initialize() override;
	virtual void release() override;
	virtual int connect() override;
	virtual void disconnect() override;
	virtual bool ready() override;
	virtual int pose(std::vector<double>& loc, int type = hy::ROBOT_POSE_TCP) override;
	virtual int move(const std::vector<double>& loc, int type = hy::ROBOT_POSE_TCP) override;
	virtual int navigation(const hy::NavigationParam& param, int type = hy::ROBOT_POSE_TCP) override;
	virtual bool reached() override;
	virtual void stop() override;
	virtual int run(const std::string& task) override;
	virtual bool connected() override;

private:
	hy::TCPClient::Ptr client_;
	const static size_t buffer_length_ = 1024;
	//char response_buff_[buffer_length_] = { 0 };

private:
	bool getDO(const int board_index, const int do_index, int& val);
	bool setDO(const int board_index, const int do_index, const int state);
	int decodeIOState(char data[], int position); ///< 解析字符串，获得指定位IO的状态 ///
	double decodeCoordinate(char data[]); ///< 解析字符串，获得Borunte机械臂坐标 ///

private:
	int trigger_do_index_ = 4; ///< Borunte中触发DO的索引，即该位DO置1时，软件应取图进行识别 ///
	int transferred_do_index_ = 5; ///< 数据传输完毕标志位DO的索引，点位数据传输完成后，该标志位将被置1 ///
	int arrival_do_index_ = 7; ///< Borunte中机器人抵达标志位DO的索引，即机器人抵达目标点后，机器人将该DO置为1 ///
};
HYPLUGIN_REGISTER("BorunteRobotPlugin", BorunteRobotPlugin);
```

### BorunteRobotPlugin.cpp

#### 包含的头文件以及命名空间

```cpp
#include "include/BorunteRobotPlugin.h"
#include <stdexcept>
#include "common/LoggerHelper.hpp"
#include <bitset>

using namespace hy;
```

#### BorunteRobotPlugin类定义

```cpp
BorunteRobotPlugin::BorunteRobotPlugin()
{
	//borunte机器人为服务端，pick为客户端
	//borunte为服务端时，默认通信端口 9760
	name_ = "Borunte";
	version_ = "1.0.0";
	host_ = "192.168.10.188";
	port_ = 9760;
	client_.reset(new TCPClient);
}
BorunteRobotPlugin::~BorunteRobotPlugin() {}
```

##### initialize

```cpp
int BorunteRobotPlugin::initialize()
{
	if (initialize_)
	{		
		return PLUGIN_ERROR_SUCESS;
	}
	if (PLUGIN_ERROR_SUCESS==check("IOTaskFile"))
	{
		load(workspace_ + '/' + kv_["IOTaskFile"], task_);
	}
	initialize_ = true;
	HY_LOG_SEV(info) << boost::format("Initialization was successful");
	return PLUGIN_ERROR_SUCESS;
	/*if (HY_SUCESS == client_->connect(host_, port_))
	{
		initialize_ = true;
		HY_LOG_SEV(info) << boost::format("Initialization was successful");
		return PLUGIN_ERROR_SUCESS;
	}
	HY_LOG_SEV(error) << "initialize robot fail, error ";
	return PLUGIN_ERROR_FAIL;*/
}
```

##### release

```cpp
void BorunteRobotPlugin::release()
{
	if (!initialize_)
	{
		return;
	}
	initialize_ = false;
	HY_LOG_SEV(info) << boost::format("borunte robot plugin was relese");
	return;
}
```

##### connect

```cpp
//连接机器人
int BorunteRobotPlugin::connect()
{
	if (!initialize_)
	{
		HY_LOG_SEV(error) << boost::format("Attempt to connect without initialization");
		return PLUGIN_ERROR_FAIL;
	}
	if (this->connected())
	{
		return PLUGIN_ERROR_SUCESS;
	}
	else
	if (HY_SUCESS == client_->connect(host_, port_))
	{
		connected_ = true;
		HY_LOG_SEV(info) << boost::format("Connect the robot successfully");
		return PLUGIN_ERROR_SUCESS;
	}
	HY_LOG_SEV(error) << boost::format("Failed to connect robot");
	return PLUGIN_ERROR_FAIL;
}
```

##### disconnect
```cpp
//与机器人断开连接
void BorunteRobotPlugin::disconnect()
{
	if (!initialize_)
		HY_LOG_SEV(error) << boost::format("Attempt to disconnect without initialization");
		return;

	if (client_ != nullptr && client_->isOpen())
	{
		client_->close();
		connected_ = false;
		HY_LOG_SEV(info) << boost::format("socket was close and connection is broken");
	}
}
```

##### ready

```cpp
bool BorunteRobotPlugin::ready()
{
	if (!connected_)
	{
		HY_LOG_SEV(error) << boost::format("Failed to connect robot");
		return false;
	}
	if (PLUGIN_ERROR_SUCESS==this->run("Ready"))
	{
		return true;
	}
	else
	{
		return false;
	}
	//获取软件取图触发位IO状态，如果为1，则软件进行取图识别
	/*int val = 0;
	bool ret = getDO(0, trigger_do_index_,val);
	if (ret&&val==1)
	{
		HY_LOG_SEV(info) << boost::format("Take photos by projector");
		setDO(0, trigger_do_index_, 0);
	}
	return ret;*/
}
```

##### pose

```cpp
/*********************************************************
 * @brief      获取borunte机器人当前世界坐标
 * @details   默认是法兰盘中心坐标 borunte工具端标定在机器人控制器内
 * @author    Yongchao Gan
 * @date      2021/03/31
 ********************************************************/
int BorunteRobotPlugin::pose(std::vector<double>& loc, int type /*= hy::ROBOT_POSE_TCP*/)
{
	if (!this->connected())
	{
		HY_LOG_SEV(error) << "robot is not connected";
		return PLUGIN_ERROR_FAIL;
	}
	loc.clear();

	//如果当前坐标系为关节坐标则获取关节坐标，默认为世界坐标
	if (type == ROBOT_POSE_JOINT)
	{
		//获取机器人六轴关节的坐标
		for (int i = 0; i < 6; ++i)
		{
			boost::format command = boost::format("{\"dsID\":\"HCRemoteMonitor\",\"cmdType\" : \"query\",\"queryAddr\" : [\"axis-%1%\"]}  ")
				% i;
			client_->write(command.str().c_str(), command.str().length());
			char buffer[buffer_length_] = { 0 };
			client_->read(buffer, buffer_length_);
			loc.push_back(decodeCoordinate(buffer));
		}
		HY_LOG_SEV(info) << "get robot joints pose " << loc;
		return PLUGIN_ERROR_SUCESS;
	}
	//0-5 对应 x,y,z,rx,ry,rz
	for (int i = 0; i < 6; ++i)
	{
		boost::format command = boost::format("{\"dsID\":\"HCRemoteMonitor\",\"cmdType\" : \"query\",\"queryAddr\" : [\"world-%1%\"]}  ")
			% i;
		client_->write(command.str().c_str(), command.str().length());
		char buffer[buffer_length_] = { 0 };
		client_->read(buffer, buffer_length_);
		loc.push_back(decodeCoordinate(buffer));
	}
	HY_LOG_SEV(info) << "get robot tcp pose " << loc;
	return PLUGIN_ERROR_SUCESS;
}
```

##### move

```cpp
/*********************************************************
 * @brief     远程发送要运动的点位loc (mm)给borunte
 * @details   以绝对坐标直线运动方式运动
 * @author    Yongchao Gan
 * @date      2021/03/31
 ********************************************************/
int BorunteRobotPlugin::move(const std::vector<double>& loc, int type /*= hy::ROBOT_POSE_TCP*/)
{
	if (!this->connected())
	{
		HY_LOG_SEV(error) << "robot is not connected";
		return PLUGIN_ERROR_FAIL;
	}

	int move_register_address = 1100; //存放move点寄存器起始地址
	//设置成1100，会报错；
	//后来试了一下800，没报错，但是机器人还是没动

	char command_string[255] = { 0 };

	//发送运动坐标
	for (int i = 0; i < 6; i++)
	{
		int move_coordinate;
	    //转换成微米
		move_coordinate = static_cast<int>(loc[i] * 1000);
		/*memset(command_string, 0, 255);
		sprintf_s(command_string, "{\"dsID\":\"HCRemoteMonitor\",\"cmdType\" : \"command\",\"cmdData\" : [\"rewriteData\", \"%d\", \"%d\", \"0\"]}   ", move_register_address + i, move_coordinate);*/
		//sendAll(command_string, strlen(command_string));
		//receiveAll(); //发送后需要接收回复，避免后续造成干扰
		char buffer[buffer_length_] = { 0 };
		boost::format command = boost::format("{\"dsID\":\"HCRemoteMonitor\",\"cmdType\" : \"command\",\"cmdData\" : [\"rewriteData\", \"%d\", \"%d\", \"0\"]}   ")
			% (move_register_address + i) % move_coordinate;
		client_->write(command.str().c_str(), command.str().length());
		client_->read(buffer, buffer_length_);
		//解析接收到的字符串
		decodeCoordinate(buffer);
	}
	HY_LOG_SEV(info) << boost::format("move to coordinate %1%") % loc;
	return PLUGIN_ERROR_SUCESS;
}
```

##### navigation

###### 21/04/06

```cpp
/*********************************************************
 * @brief      抓取程序函数，由HyPick调用，完成后触发软件取图信号
 * @details   
 * @author    Yongchao Gan
 * @date      2021/04/06
 ********************************************************/
int BorunteRobotPlugin::navigation(const hy::NavigationParam& param, int type /*= hy::ROBOT_POSE_TCP*/)
{
	if (!this->connected())
	{
		HY_LOG_SEV(error) << "robot is not connected";
		return PLUGIN_ERROR_FAIL;
	}
	int target_register_address = 800; //存放target_location的寄存器起始地址
	int transition_register_address = 810; //存放transition_location的寄存器起始地址   
	//抓取过程 过渡点--抓取点--过渡点--放料点，每次运动需要发送六次数据
	//int target_coordinate, transition_coordinate,position_coordinate;

	//定义起始点
	std::vector<double> start_loc;
	this->pose(start_loc);
	this->run("Put");
	std::vector<double> target_coordinate, transition_coordinate, position_coordinate;
	target_coordinate.resize(6);
	transition_coordinate.resize(6);
	position_coordinate.resize(6);
	
	this->move(param.Transition);
	this->move(param.Destination);
	this->run("Get");
	this->move(param.Transition);

	//运动到放料点
	if (param.Position >= 0)
	{
		if (param.Position >= coordinate_.Positions.size()) {
			HY_LOG_SEV(error) << boost::format("position %1% out of total positions index %2%") % param.Position % coordinate_.Positions.size();
			return PLUGIN_ERROR_FAIL;
		}

		if (PLUGIN_ERROR_SUCESS != this->move(coordinate_.Positions[param.Position]))
		{
			HY_LOG_SEV(error) << boost::format("move to %1% failed") % coordinate_.Positions[param.Position];
			return PLUGIN_ERROR_FAIL;
		}
		this->run("Put");
		this->move(start_loc);
		this->run("Done");//在done中，将软件拍照触发位至1
	}
	//没有设置放料点就运动回起始点
	else
	{
		if (PLUGIN_ERROR_SUCESS != this->move(start_loc, false))
		{
			HY_LOG_SEV(error) << boost::format("move to %1% failed") % start_loc;
			return PLUGIN_ERROR_FAIL;
		}
	}
	return PLUGIN_ERROR_SUCESS;

	//for (int i = 0; i < param.Destination.size(); i++)
	//{
	//	int target_coordinate, transition_coordinate;
	//	target_coordinate = static_cast<int>(param.Destination[i] * 1000); //将单位由毫米转换为微米
	//	transition_coordinate = static_cast<int>(param.Transition[i] * 1000);

	//	char buffer[buffer_length_] = { 0 };
	//	boost::format command = boost::format("{\"dsID\":\"HCRemoteMonitor\",\"cmdType\" : \"command\",\"cmdData\" : [\"rewriteData\", \"%d\", \"%d\", \"0\"]}   ")
	//		% (target_register_address + i) % target_coordinate;
	//	client_->write(command.str().c_str(), command.str().length());
	//	client_->read(buffer, buffer_length_);
	//	decodeCoordinate(buffer);

	//	command = boost::format("{\"dsID\":\"HCRemoteMonitor\",\"cmdType\" : \"command\",\"cmdData\" : [\"rewriteData\", \"%d\", \"%d\", \"0\"]}   ")
	//		% (transition_register_address + i) % transition_coordinate;
	//	client_->write(command.str().c_str(), command.str().length());
	//	client_->read(buffer, buffer_length_);
	//	decodeCoordinate(buffer);
	//}

	//if (param.Position != -1)
	//{
	//	std::bitset<2> binary_object_type(param.Position); //Borunte机器人没有寄存器，只能将类别信息存放到输出IO口，这里使用2个输出口以表示至多4种物品类型
	//	setDO(1, 1, (int)binary_object_type[0]);
	//	setDO(1, 2, (int)binary_object_type[1]);
	//}

	//setDO(0, transferred_do_index_, 1); //设置标志位，通知机械臂数据传输完毕
}
```

###### 21/04/20

```cpp
/*********************************************************
 * @brief      抓取程序函数，由HyPick调用，完成后触发软件取图信号
 * @details
 * @author    Yongchao Gan
 * @date      2021/04/20
 ********************************************************/
int BorunteRobotPlugin::navigation(const hy::NavigationParam& originParam, int type /*= hy::ROBOT_POSE_TCP*/)
{
	if (!this->connected())
	{
		HY_LOG_SEV(error) << "robot is not connected";
		return PLUGIN_ERROR_FAIL;
	}

	hy::NavigationParam limitedParam;
	checkoutAxisConfig(originParam, limitedParam);

	hy::NavigationParam param = limitedParam;

	//定义起始点
	std::vector<double> start_loc;
	//获取当前的位置为起始位置
	this->pose(start_loc);
	//张开电爪
	this->run("Put");
	
	if (PLUGIN_ERROR_FAIL == this->setPos(start_loc, start_pos_addr_))
		return PLUGIN_ERROR_FAIL;
	if (PLUGIN_ERROR_FAIL == this->setPos(param.Transition, transition_addr_))
		return PLUGIN_ERROR_FAIL;
	if (PLUGIN_ERROR_FAIL == this->setPos(param.Destination, target_addr_))
		return PLUGIN_ERROR_FAIL;
	if (PLUGIN_ERROR_FAIL == this->setPos(coordinate_.Positions[param.Position], put_pos_addr_))
		return PLUGIN_ERROR_FAIL;

	//开始
	this->run("MoveStartFlag");

	//等待机器人完成抓取并反馈
	using namespace std::literals::chrono_literals;
	while (!this->run("MoveDoneFlag"))
	{
		std::this_thread::sleep_for(100ms);
	}
	this->run("Done");
	return PLUGIN_ERROR_SUCESS;
}
```

##### reached

```cpp
bool BorunteRobotPlugin::reached()
{
	if (!this->connected())
	{
		return false;
	}
	int val = 0;
	bool ret = getDO(0, arrival_do_index_,val);
	if (ret==true&&val==1)
	{
		setDO(0, arrival_do_index_, 0); //复位标志位
	}
	return ret;
}
```

##### stop

```cpp
void BorunteRobotPlugin::stop()
{
	return;
}
```

##### run

机器人运动到点位后，执行抓取或者放下的命令

```cpp
int BorunteRobotPlugin::run(const std::string& task)
{
	if (task_.find(task)==task_.end())
	{
		HY_LOG_SEV(error) << boost::format("no io task key match %1%") % task;
		return PLUGIN_ERROR_FAIL;
	}
	int code, status = PLUGIN_ERROR_FAIL;
	int val = 0;
	for (HYRobotIOTask t : task_[task])
	{
		status = PLUGIN_ERROR_FAIL;
		try
		{
			if (t.Type != ROBOT_IO_TYPE_DO && t.Type != ROBOT_IO_TYPE_DI)
				return PLUGIN_ERROR_FAIL;

			switch (t.Action)
			{
			case ROBOT_IO_ACTION_SET:
				if (t.Type == ROBOT_IO_TYPE_DO)
				{
					code = this->setDO(0, std::stoi(t.Name), t.Value);
					if (code != 1)
					{
						HY_LOG_SEV(error) << boost::format("set do %1% to %2% fail, error code %3%") % t.Name % status % code;
					}
					else
						status = PLUGIN_ERROR_SUCESS;
				}
				break;
			case ROBOT_IO_ACTION_GET:
				code = getDO(0, std::stoi(t.Name),val);
				if (code != 1)
				{
					HY_LOG_SEV(error) << boost::format("get %1% io %2% status fail, error code %3%") % t.Type % t.Name % code;
				}
				else if (val == t.Value)
				{
					status = PLUGIN_ERROR_SUCESS;
				}
				break;
			case ROBOT_IO_ACTION_WAIT_MS:
				std::this_thread::sleep_for(std::chrono::milliseconds((long)t.Value));
				status = PLUGIN_ERROR_SUCESS;
				break;
			default:
				break;
			}
		}
		catch (const std::exception& ex)
		{
			HY_LOG_SEV(error) << boost::format("run io task, action %1%, type %2%, name %3%, value %4% catch exception: %5%")
				% t.Action % t.Type % t.Name % t.Value % ex.what();
			return PLUGIN_ERROR_FAIL;
		}

		if (status != PLUGIN_ERROR_SUCESS)
			break;
	}
	return status;
}
```

##### connected

检查机器人是否已连接上

```cpp
bool BorunteRobotPlugin::connected()
{
	if (client_!=nullptr&& client_->isOpen())
	{
		return true;
	}
	else
	{
		return false;
	}
}
```

##### setPos

```cpp
/*********************************************************
 * @brief      给定坐标和寄存器地址发送到borunte
 * @details   需要事先在borunte上定义好对应寄存器地址和数据类型
 * @author    Yongchao Gan
 * @date      2021/04/19
 ********************************************************/
int BorunteRobotPlugin::setPos(const std::vector<double>& loc, int addr, int type /*= hy::ROBOT_POSE_TCP*/)
{
	if (!this->connected())
	{
		HY_LOG_SEV(error) << "robot is not connected";
		return PLUGIN_ERROR_FAIL;
	}

	char command_string[255] = { 0 };

	for (int i = 0; i < 6; i++)
	{
		int move_coordinate;
		//转换成微米
		move_coordinate = static_cast<int>(loc[i] * 1000);
		/*memset(command_string, 0, 255);
		sprintf_s(command_string, "{\"dsID\":\"HCRemoteMonitor\",\"cmdType\" : \"command\",\"cmdData\" : [\"rewriteData\", \"%d\", \"%d\", \"0\"]}   ", move_register_address + i, move_coordinate);*/
		//sendAll(command_string, strlen(command_string));
		//receiveAll(); //发送后需要接收回复，避免后续造成干扰
		char buffer[buffer_length_] = { 0 };
		boost::format command = boost::format("{\"dsID\":\"HCRemoteMonitor\",\"cmdType\" : \"command\",\"cmdData\" : [\"rewriteData\", \"%d\", \"%d\", \"0\"]}   ")
			% (addr + i) % move_coordinate;
		client_->write(command.str().c_str(), command.str().length());
		client_->read(buffer, buffer_length_);
		//解析接收到的字符串
		decodeCoordinate(buffer);
	}
	HY_LOG_SEV(info) << boost::format("move to coordinate %1%") % loc;
	return PLUGIN_ERROR_SUCESS;
}
```

##### getDO

获取IO状态信息

```cpp
bool BorunteRobotPlugin::getDO(const int board_index, const int do_index,int& val)
{
	//检查是否连接机器人，未连接就返回false
	if (!this->connected())
	{
		HY_LOG_SEV(error) << "robot is not connected";
		return false;
	}

	char buffer[buffer_length_] = { 0 };
	boost::format command = boost::format("{\"dsID\":\"HCRemoteMonitor\",\"cmdType\" : \"query\",\"queryAddr\" : [\"output-%d\"]}  ")
		% board_index;
	client_->write(command.str().c_str(), command.str().length());
	client_->read(buffer, buffer_length_);
	val = decodeIOState(buffer, do_index) == 1;
	return true;
}
```

##### setDO

设置IO状态

```cpp
bool BorunteRobotPlugin::setDO(const int board_index, const int do_index, const int state)
{
	if (!this->connected())
	{
		HY_LOG_SEV(error) << "robot is not connected";
		return false;
	}

	char buffer[buffer_length_] = { 0 };
	boost::format command = boost::format("{\"dsID\":\"HCRemoteMonitor\",\"cmdType\" : \"command\",\"cmdData\" : [\"modifyOutput\",\"%d\",\"%d\",\"%d\"]}   ")
		% board_index % do_index % state;
	client_->write(command.str().c_str(), command.str().length());
	client_->read(buffer, buffer_length_);

	HY_LOG_SEV(info) << boost::format("set board_index %1% do %2% state %3%") % board_index % do_index % state;
	return true;
}
```

##### decodeIOState

解码IO状态

```cpp
int BorunteRobotPlugin::decodeIOState(char data[], int position)
{
	int result = static_cast<int>(decodeCoordinate(data));
	std::bitset<16> binary_result(result);
	//判断2进制中某位是否为1
	int base = static_cast<int>(pow(2, position));
	int io_value = static_cast<int>(result / base % 2);
	HY_LOG_SEV(info) << boost::format("get do %1% state is : %2%") % position % io_value;
	return io_value;
}
```

##### decodeCoordinate

```cpp
/*********************************************************
 * @brief     解析接收到的字符串
 * @details   解析坐标
 * @author    Yongchao Gan
 * @date      2021/03/31
 ********************************************************/
double BorunteRobotPlugin::decodeCoordinate(char data[])
{
	std::string result = "";
	int index_end = 0;
	for (int i = 0; i < 200; i++)
	{
		if (data[i] == ']')
		{
			index_end = i - 2;
			break;
		}
	}
	int index_start = 0;
	for (int j = index_end; j > 0; j--)
	{
		if (data[j] == '\"')
		{
			index_start = j + 1;
			break;
		}
	}
	for (int k = index_start; k < 200; k++)
	{
		if (data[k] == '\"')
			break;
		result = result + data[k];
	}
	HY_LOG_SEV(info) << boost::format("decode info : %1%") % result;
	return atof(result.c_str());;
}
```

##### 被废止的成员函数

如果要恢复，别忘了在头文件里添加到类定义里去。

```cpp
/*********************************************************
 * @brief      给定坐标和寄存器地址发送到borunte
 * @details   需要事先在borunte上定义好对应寄存器地址和数据类型
 * @author    Yongchao Gan
 * @date      2021/04/19
 ********************************************************/
int BorunteRobotPlugin::moveto(const std::vector<double>& loc, int addr, int type /*= hy::ROBOT_POSE_TCP*/)
{
	if (!this->connected())
	{
		HY_LOG_SEV(error) << "robot is not connected";
		return PLUGIN_ERROR_FAIL;
	}

	char command_string[255] = { 0 };

	for (int i = 0; i < 6; i++)
	{
		int move_coordinate;
		//转换成微米
		move_coordinate = static_cast<int>(loc[i] * 1000);
		/*memset(command_string, 0, 255);
		sprintf_s(command_string, "{\"dsID\":\"HCRemoteMonitor\",\"cmdType\" : \"command\",\"cmdData\" : [\"rewriteData\", \"%d\", \"%d\", \"0\"]}   ", move_register_address + i, move_coordinate);*/
		//sendAll(command_string, strlen(command_string));
		//receiveAll(); //发送后需要接收回复，避免后续造成干扰
		char buffer[buffer_length_] = { 0 };
		boost::format command = boost::format("{\"dsID\":\"HCRemoteMonitor\",\"cmdType\" : \"command\",\"cmdData\" : [\"rewriteData\", \"%d\", \"%d\", \"0\"]}   ")
			% (addr + i) % move_coordinate;
		client_->write(command.str().c_str(), command.str().length());
		client_->read(buffer, buffer_length_);
		//解析接收到的字符串
		decodeCoordinate(buffer);
	}
	HY_LOG_SEV(info) << boost::format("move to coordinate %1%") % loc;
	return PLUGIN_ERROR_SUCESS;
}
```