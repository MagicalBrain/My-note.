# NEU CS 真题 2016

## 第一部分C语言程序设计（75分）

### 一、简答题，每题5分。

#### 1、请简要说明 while语句与do -while-语句的异同。

#### 2、请简要说明 static局部变量和自动变量的异同。

#### 3、请简要说明定义 ```int *[4]```与定义```int (*P)[4]```的区别。

### 二、给出程序运行结果，每题5分。

#### 1、

```c
#include <stdio.h>
void main()
{
    int i,s=0,a[]={1,2,3,4,5,6,7,8,9,10};
    for(i=2;i<7;i++){
        a[i]=a[i-1]+a[i+1];
        s+=a[i];
    }
    printf("%d\n", s );
}
```


2、

```c
#include <stdio.h> 
void main()
{ 
    int sub(int i ,int j );
    printf("num is %d\n",sub(16,36));
}

int sub(int i ,int j ) 
{ 
    int k;
    if (i<j){k=i;i=j;j=k;}
    if (i%j==0)return(j);
    else return (sub(j ,i % j) );
}
```

3、
```c
#include <stdio.h> 
int a =500;
void f(void) 
{ 
    static a = 200;a++;
    printf("%d",a);
}
void main () 
{ int i ;
    for (i=0;i<3;i++){
        a++;
        printf("%d",a);
        f();
    }
}
```

4 、

```c
#include <stdio.h>
void f(char * x,char * y) 
{ 
    int t ;
    t =*x;
    *x=*y;
    *y=t;
}

void main()
{ char * p,* q,a[9 ]="ABCDEFGH";
    int i ;
    p =a;
    q =&a[7]; 
    f(p,q);
    for (i=0;i<8;i++)
        printf("%c",a[i]) ;
}
```

### 三、编程题

#### 1、编写程序:求$s=1+2x3+4x5x6+7x8x9x10+11x12x13x14x15+ \cdots$

求前n项之和，由键盘输入数据n。（12分）

#### 2、某歌咏比赛中，有8个评委对20位选手进行评分，选手按1~20号进行编号，每个评委给出1~10的分数，在统计分数时要除去一个最低分和最高分，计算出其他评委给出分数的平均分作为选手的最后得分。编写程序实现以下功能:评委输入，按评分输出得分最高的3位选手的编号和分数，要求程序执行时间最少。（12分）


#### 3、编写程序，查找给定字符在字符串中首次出现的位置。
要求:不使用有关字符串处理的库函数；
（1）主函数中键盘输入字符串以及查找的字符，调用子函数；
（2）子函数完成查找任务，如果字符串中包含所查找的字符，则返回该字符在字符串首次出现的位置，否则返回0。（15分）

## 第二部分数据结构（75分）

### 一、简答题（每小题8分）

#### 1、有两个有序线性表分别具有n个和m个元素，现将其归并成一个有序表，求用最少的比较次数

#### 2、设有10x10的对称矩阵A采用压缩方式进行存储，按行优先顺序存放其下三角矩阵，假设起始元素a的地址为1，每个数据元素占两个字节，求$a_{62}$的地址是多少。

#### 3、设用通信的电文由10个字母组成，字母在电文中出现的频度2，7，15，19，28，39，59，67，88，100，构造哈夫曼树并给出对应字母的哈夫曼编码。

#### 4、下图是一个无向图:
（1）请画出以定点①为根的广度优先生成树；
（2）将该树转换为孩子兄弟链表表示的二叉树。


#### 5、希尔排序和快速排序是不稳定的排序方法，试举例说明。


### 二、编写算法题（每小题12分）

#### 1、设计一个实现下述要求的locate运算的函数，设有一个带表头结点的双向链表L，每个结点有4个数据成员；指向前驱节点的指针prior，指向后继节点的指针next，存放数据的成员data和访问频度freq，所有结点的freq初始值都为0每当在链表上进行一次Locate（lx）操作时，令元素值为x的结点访问频度freq加1，同时调整链表中结点间的顺序。使链表中所有结点按访问频度递减的顺序排列。
（1）写出算法的基本思想；
（2）写出算法实现。

**基本思想**：
1. 先遍历链表，找到对应的结点，
2. 然后修改这个结点的freq值+1
3. 将这个结点插入到表头

**算法实现**：

```c
void Locate(DLinkList L, int x)
{
    if (L == NULL)
        return ;
    
    DLinkList p = L;
    while(p != NULL)
    {
        if (p->data == x)
        {
            //freq数据域加一
            p->freq++;

            //从链表中退出该节点
            p->prior->next = p->next;
            p->next->prior = p->prior;

            //将该节点加入表头
            p->next = L->next;
            L->next = p;
            p->prior = L;

            break;
        }
    }
    puts("表中不存在值为x的结点！");
}
```

#### 2、已知二叉树采用二叉链表存储结构，设计算法求二叉树中指定结点所在的层数。

（1）写出算法的基本思想；
（2）写出算法实现。

**基本思想**：

1. 使用层次遍历将所有结点放入一个数组中，包括空结点（存入一个‘#’）
2. 然后根据结点的下标值来计算其高度（层次）

**算法实现**：

```c

```

#### 3、设计算法，求邻接表存储结构的无向图的连通分量的个数，并输出每个连通分量的顶点集。
（1）写出算法的基本思想；
（2）写出算法实现。

**基本思想**：


**算法实现**：





