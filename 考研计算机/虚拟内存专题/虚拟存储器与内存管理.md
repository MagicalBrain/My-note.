# 虚拟存储器

## 基本概念

**页式、段式、段页式**都是**非连续型内存管理方式**

实地址=主存页号 + 页内（字）地址

虚地址=虚存页号+页内（字）地址

辅存地址=磁盘号+盘面号+磁道号+扇区号

## 页式存储器（基本分页存储管理）

**页框：**
内存中被分为一个个大小相等的分区
**页框=页帧=内存块=物理块=物理页面=实页**
**页框号=页帧号=内存块号=物理块号=物理页号=实页号**

**页面（页）：**
逻辑地址空间（虚拟地址空间）中也分为与页框大小相等的部分，即页面

**页表**：
是记录虚页调入主存时被放入主存的位置，一般永久保存在内存中（断电失效？）
通常保存在PCB中

**页表项**
1. 装入位（1：已在内存中功能；0：不在内存，启动I/O掉入内存）有时题目会给，有时不会给，因为这是在操作系统里详细说明的
2. 虚页号（标记、页号、页面号）
3. 块号（实页号、主存块号、页框号）

**进程与页表的关系**
1. 一个进程对应一张页表
2. 进程的每一个页面对应一个页表项（每个页表项长度相同）

### 虚实地址转换

$页表项地址 = 页表起始地址+虚页号$

通过页表地址（页框号）去页表里找到对应的实页号

实页号+页内地址=实地址

优点：
1. 页面长度固定
2. 页表简单
3. 调入方便

缺点：
1. 最后一页的零头可能无法完全利用（操作系统：产生内部碎片）而造成浪费
2. 页不是逻辑上的独立实体，所以处理、保护和共享都不及段式存储器方便

## 段式存储器

**段：**
段是按程序中的逻辑结构（例如：有多少个子程序、多少个栈？）来划分的
段的长度因程序而异

**段表：**
一个进程一张

**段表项：**

|段号|段长|段在主存的地址|
|---|---|---|

$虚拟地址 = 段号+段内地址（段内偏移量）$

相比于页式存储器（存储管理方式），段号、段内偏移量必须由**用户显式提供**，而在高级编程语言中则是由**编译程序**提供

### 地址变换机构

**地址空间维度：** 二维的

**段表寄存器：**
存放段表始址和段表长度

**地址变换过程：**

### 段的共享

**段的共享：**
两个作业的段表的表项指向被共享的段的同一个物理副本
不能修改的代码和数据可以共享。
不能共享的代码称为**纯代码**或**可重入代码**，但**不是临界资源**
可修改的代码和数据不能共享

### 段的保护

与分页管理类似，有两种保护方法

#### 存取控制保护



#### 地址越界保护

将逻辑地址中的段号与段表寄存器中的段表长度比较，判断是否越界，是则触发越界中断

```flow
    st=>start: 取段号
    
    op=>operation: 取段表长度
    op1=>operation: 取段内位移
    op2=>operation: 取段长
    op0=>operation: 不触发中断

    cond=>condition: 是否越界？
    cond1=>condition: 是否越界？
    e=>end: 触发越界中断
    e1=>end: 触发越界中断

    st->op->cond
    
    op1->op2
    op2->cond1
    cond1(yes)->e
    cond1(no)->op0

    cond(yes)->e1
    cond(no)->op1
```

## 段页式存储器

先分段，再每一段分页
融合了分页、分段两种方法的优点：
1. 分页内存利用率高
2. 段式体现了程序的逻辑结构且方便共享

**地址空间：** 二维的（同段式）

### **逻辑地址结构：**

|段号|页号|页内偏移量|
|---|---|---|

### 地址变换过程

一次访问三次访主存

## 快表（TLB）

在一段时间总是访问某些页，快表就是存放这些页的页表项以提高效率，相应的比放在主存中的页表称之为**慢表**。快表只是慢表一部分的副本

快表**根据内容指定地址**，故使用**相联存储器**

### 查表过程

快、慢表同时查找

访问顺序：
TLB->页表、Cache、主存

# 虚拟内存技术的实现

## 传统内存管理方式的特征

1. 一次性：作业必须一次全部装入内存后才可运行
2. 驻留性：作业被装入内存后，就一直驻留在内存，不会被换出

三种方式：
1. 请求分页存储管理（**重点**）
2. 请求分段存储管理
3. 请求段页式存储管理

## 请求分页存储管理

### 请求分页存储管理的页表机制

**请求分页的页表项：**


|  页号  | 物理块号   | 状态位 P  | 访问字段A   |  修改位M  | 外存地址   |
| --- | --- | --- | --- | --- | --- |

即在基本分页存储管理的页表项的页框号后面增加了四项：

1. 状态位P（即机组提到的装入位）
2. 访问字段A
3. 修改位M
4. 外存地址

### 缺页中断机制

当要访问的页面不在内存，便产生中断，即缺页中断（机组：装入位为0，启动I/O系统，启动I/O系统通常都会触发中断）

**该机制执行过程：**
1. 保护CPU环境（关中断、保存断点）
2. 分析中断原因
3. 转入执行中断处理程序
4. 恢复CPU环境

**与一般中断的区别：**
1. 属于内部中断
2. 一条指令在执行期间，可能会触发多次缺页中断

### 地址变换机构

是一上面的基本分页存储地址转换机构为基础
增加了一些功能：

### 页面置换算法

**注意**与计组中的Cache中主存块的替换算法的概念区分开

Cache中主存块的替换算法：是主存与Cache中的主存块进行替换；
而这里的页面替换算法是辅村与主存替换

#### 最佳置换算法（OPT）

#### 先进先出置换算法（FIFO）

#### 最近最久未使用（LRU）

#### 时钟置换（最近未用，NRU）

## 页面分配策略



# 相关计算问题

## 每个页表占多少字节

## 如何实现地址的转换

## 如何确定一个逻辑地址所对应的页号、页内偏移量

