# 2.1 数制与码制

## 进位技术制及其相互转换

### 二进制转十进制

简单，$(1.1)_2$从小数点前一位开始数第$n$位的位权是$2^{n-1}$，小数点后则是第$m$位的位权为$2^{-m}$

相加即可

### 二进制转八进制和十六进制

例题：$1111\ 0000\ 10.01101$分别转成八进制和十六进制

转八进制：
原数化为$$001\ 111\ 000\ 010.011\ 010$$

每三位表示一个八进制数，少的补0，即$$(1702.32)_8$$

转十六进制：
$$0011\ 1100\ 0010.0110\ 1000$$
同理，每四位表示一个十六进制数，少的补0，即$$(3C2.68)_{16}$$

## 真值和机器数

## BCD码

表示十进制数的编码

### 8321码

就是正常的逻辑，每四位来表示一个二进数

### 余3码

### 2421码

与8421类似但位权不同，每四位表示一个十进制数，位权为2、4、2、1

$$(5)_{10} = (1011)_{2421码}$$

## 字符与字符串

### ASCII码

7位的。

由于以字节为单位，在计算机里表示最左边要补0

### 汉字的编码

**GB2312**：每个编码用2个字节（16位）表示

**GB18030**：1B、2B、4B

## 校验码

**码距**：两个合法码的最少变化位数

**校验位**

**校验码的正确性**：由校验位的位数和码距同时决定

### 奇偶校验

#### 奇校验码

有奇数个1则无错

#### 偶校验码

有偶数个1则无错

#### 共同缺陷：

1、不能检测出偶数位的错误（如果数据有偶数位出现错误则无法检出，例如同时有2、4、6、8……位出错则无法检出。）

2、无法纠错（即使知道有错，也不知道错在哪里，所以没办纠正）

**实际上奇偶校验是一回事的**

### 海明码校验

本质：多重奇偶校验

能检出2位错，纠正一位错。（知道有2位错了，且知道其中1位的位置）

#### 海明码的计算：

有效位数n为4，检验位数k为3，计算1011的海明码

n、k满足$n + k \leq 2^k - 1$



### CRC校验码（循环冗余校验码）

#### 计算方法：

1、求出生成多项式对应的码值，其最高幂次为R
2、信息码左移R位
3、将3中得到的数与生成多项式的码进行异或除法
4、余数保留R位
5、CRC码即信息码后面加上余数

#### 检错方法

余数为0则无错，否则有错

#### 纠错方法

余数的数值（十进制）即为出错的位，取反即可

#### 优点

1、根据多项式的设置，可以检验并纠正多位

2、计算速度快，适合大量数据的检验

# 2.2 定点数的表示与运算

## 无符号数与有符号数

## 机器数的表示

### 原码

最左边的一位是符号位：0为正数；1为负数

**0有两种表示**
$0000\ 0000$
$1000\ 0000$

表示范围：
以8位为例$$max = 2^7-1$$ $$min = -(2^7-1)$$是关于原点对称的

### 反码

反码是原码到补码的过渡

正数同原码

负数是原码的按位取反（除了符号位）

**真值0表示不唯一(同原码)**

表示范围（同原码）：
$$max = 2^7 -1$$ $$min = -(2^7 -1)$$

### 补码

加减法比较简便，符号位可直接参与计算。

正数同原码

负数是反码+1（末位+1）

表示范围：对于n位
$$max = 2^{n-1}-1$$ $$min = -2^{n-1}$$

#### 对于补码最小值比原码还小的理解：

由于原码最小值（8位）为$-127 = 1111\ 1111$
转换成补码：$-127 = 1000\ 0001$

而$1000\ 0001 - 1= 1000\ 0000 = -128$仍然是负数的补码，且-128转换成原码会溢出（上溢出）变成127

#### 补码表示的最大负数（小数）：

$$-0.5 = 1.100\ 0000$$

$$-0.25 = 1.110\ 0000$$

越多0，负数就越小

### 移码

补码的符号位取反即移码

移码的计算：$$[x]_真 = x + M$$
M偏置值为$2^{n-1}$

## 定点运算

### 移位运算

#### 算术移位

原码：正负都补0

补码：正补0；负数：左0右1（左移同原码，右移同反码）

反码：正0负1

**符号位不变**

#### 逻辑移位

无符号位（原来有的则参与运算），无论左移还是右移都补0

#### 循环移位

##### 大循环

带进位

##### 小循环

移位的时候不带进位，但是要**注意**，移位之前要把最高位放进进位标志位里

### 加减法运算

#### 原码的加减法

注意溢出，左边最高位产生的溢出位要丢掉，例如：
$$(0111\ 1111)_{yuan} + 1 = (0000\ 0000)_{yuan}$$

#### 补码的加减法

符号位参与计算

减法就是被减数加上减数的负数

### 符号扩展

8位数与32位数相加，相加前要符号扩展

正数都添0

负数：原码：都添1
        补码：整数添1，小数添0

### 溢出判断

#### 采用1位符号位

设两加数的符号位分别为$A_s$，$B_s$；运算结果符号位为$S_s$，溢出表达式为：

$$V = A_s B_s \overline{S_s} + \overline{A_s B_s} S_s$$

$V = 0$ 无溢出
$V=1$ 有溢出

#### 采用双符号位

两符号位同则未溢出，两符号异则溢出

#### 一位符号位，据数据位的进位来判断

最高位$C_0$ 符号位进位$C_s$
$$V = C_0 \oplus C_s$$

V=1 为溢出

### 乘法运算

#### 原码一位乘法

$$ 
\begin{array}{rl}  
0,10 &  \\  
\times 0,10 & \\  
\hline & \\
0,100 &    
\end{array}  
 $$

#### 补码一位乘法

#### 乘法总结

|码制|符号位|部分积|乘数|累加次数|移位方向|次数|每位次数|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|||||||||

### 除法运算

#### 原码除法（不恢复余数）

#### 补码除法（加减交替法）

#### 补码不恢复除法

## 强制类型转换

# 2.3 浮点数的表示与计算

## 浮点数的表示

### 规格化浮点数

目的：为有效利用位数，最高为必须为一个有效值

原码：
正数：为0.1……
负数为1.1……

补码：
正数：0.1……
负数：1.0……
（最高位为有效位，补码负数的有效数字是1）

### 浮点数的表示范围

### 浮点数的溢出

### IEEE 754 标准

国际通用的一个浮点数标准，电脑里的默认是按IEEE754来存浮点数的

#### 单精度浮点数

共32位，1位符号位、8位阶码、23位数值位

例如：
$$1\ 1110\ 0000.0000\ 0000\ 0000\ 0000\ 0000\ 000$$

符号位为1，则为负数；阶码为$1110\ 0000$则为$128 + 64 + 32 - 127 = 97$，后面全为0，就是$-1.0 \times 2^{97}$（隐藏了1）

还要注意其特殊的值：

无穷:$E = 255, M = 0$，正负看符号位
Nan$E = 255, M \neq 0$
0：E= 0，Ｍ= 0

非规格化：$E = 0, M \neq 0$

#### 双精度浮点数

共64位，1位符号位、11位阶码、52位尾数

同单精度浮点一个道理，只是位数不同

### 定点数与浮点数的区别

## 浮点运算

### 浮点加减运算

 计算步骤：
 
#### 1、对阶

先判断两个数的阶码谁大，小的向大的对齐。对齐的时候，阶码+1，尾数得右移；阶码-1，尾数得左移。

#### 2、尾数求和

如果是减法就加其负数
 
#### 3、规格化

**注意：不同的码制，规格化规则不同**

检查计算出来的结果
 如果符号位为10或01则溢出，需要右移
 如果最高位和符号位一样则需要左移
 
#### 4、舍入

如果最后规格化移位的时候舍去的是0则无需改变
 
#### 5、溢出判断

看看最后的结果是否溢出（符号位？）

### 强制类型转换

范围从小到大：

Char, short, int, long, float, double

#### int与float互转

int转float：
大小不变，但可能会出现数据舍入

float转int：
精度损失，或溢出

#### int和unsigned int互转

int转unsigned int：
负数会溢出

unsigned int转int：
可能会溢出，例如：
```
unsigned int i = 128;
(int)i = -128
```

#### int,long

#### float,double

# 2.4 算数逻辑单元（ALU）

## 加法器

### 一位全加器

### 串行加法器

### 并行加法器

#### 串行进位

#### 并行进位

完全采用并行进位不现实，因为随着位数的增加，电路会越来越复杂

##### 单级先行进位

##### 多级先行进位

## 算数逻辑单元的功能与结构

### 74181（并行加法器）和74182（先行进位芯片）的组合

