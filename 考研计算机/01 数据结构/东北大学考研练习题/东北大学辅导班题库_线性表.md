## 1、从顺序表中删除第i个元素

**要点：**
删除其实就是将第i个元素后面的所有元素前移覆盖掉被删除的元素；然后再将顺序表长度-1即可。

<details>
<summary>点击查看代码</summary>

```c
/*
* author:HRL
*
* date:09/28/2020
* 
* description:
* 1、从顺序表中删除第i个元素
*/

#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct SqList
{
	ElemType *pSqList;
	int Length;	//存储元素的个数
	int Size;	//总共的存储空间大小
}SqList;

Status delete_Item(SqList *L,int i)
{
	if (NULL == L->pSqList)
		return false;
	if (i >= L->Length)
		return false;
	for (int j = i+1;j < L->Length;j++)
	{
		L->pSqList[j-1] = L->pSqList[j];
	}
	L->Length -= 1;
	return true;
}

int main()
{
	int n,i;
	puts("请输入正整数n：\n");
	scanf("%d",&n);
	ElemType *p = (ElemType*) malloc (n * sizeof(ElemType));
	
	for (int j = 0; j < n;j++)
		p[j] = j;

	for (int j = 0;j < n;j++)
		printf("%d ",p[j]);
	puts("");

	SqList L;
	L.pSqList = p;
	L.Length = n;
	L.Size = n;

	puts("请输入要删除的元素序号i：");
	scanf("%d",&i);
	
	if (delete_Item(&L,i) == true)
	{
		printf("顺序表长度为：%d\n",L.Length);
		for (int j = 0; j < L.Length;j++)
			printf("%d ",p[j]);
			puts("");
	}
	else
		puts("无法处理！");

	return 0;
};

```
</details>

## 2、在第i个元素前插入e

**要点：**
1. 将第i个元素后移的时候，别忘了将第i个元素本身也后移；
2. 如果存储空间不够记得先对长度+1进行判断，如果长度不够要重新开辟空间将原来的数组拷贝过去

<details>
<summary>点击查看代码</summary>

```c

```
</details>

## 3、从顺序表中删除最小元素，空出的位置由最后一个元素补上

**要点；**
1. 先找最小元素，找到获取其数组下标
2. 将最后一个元素赋值过去
3. 最后别忘了将顺序表长度-1！

<details>
<summary>点击查看代码</summary>

```c
/*
* author:HRL
*
* date:09/28/2020
* 
* description:
* 3、从顺序表中删除最小元素，空出的位置由最后一个元素补上
*/

#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct SqList
{
	ElemType *pSqList;
	int Length;
	int Size;
}SqList;

Status func03(SqList *L)
{
    if (NULL == L)
        return false;
    
    int min = L->pSqList[0],id_min = 0;
    for (int i = 1; i < L->Length; i++)
    {
        if (min > L->pSqList[i])
        {
            min = L->pSqList[i];
            id_min = i;
        }
    }
    L->pSqList[id_min] = L->pSqList[L->Length-1];
    L->Length -= 1;
    return true;
}

int main()
{
	int n,i;
	SqList L;
	ElemType e;
	
	puts("请输入正整数n：");
	scanf("%d",&n);
	
	ElemType *p = (ElemType*) malloc (n * sizeof(ElemType));
	L.pSqList = p;
	L.Length = n;
	L.Size = MAX_SIZE;
	
    puts("请输入顺序表元素值：");
	for (int j = 0; j < L.Length;j++)
		scanf("%d",&L.pSqList[j]);

    if (func03(&L) == true)
    {
        for (int j = 0;j < L.Length;j++)
		printf("%d ",L.pSqList[j]);
	    puts("");
    }
    else
    {
        puts("处理失败！");
    }
       
	return 0;
}
```
</details>

## 4、在无序顺序表中删除值在s和t之间的所有元素

<details>
<summary>点击查看代码</summary>

```c
/*
* author:HRL
*
* date:09/28/2020
* 
* description:
* 4、在无序顺序表中删除值在s和t之间的所有元素
*/

#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct SqList
{
	ElemType *pSqList;
	int Length;
	int Size;
}SqList;

Status func04(SqList *L,int s,int t)
{
    if (NULL == L || NULL == L->pSqList)
        return false;
    
    if (s > t)
    {
        int tmp = t;
        t = s;
        s = tmp;
    }
    ElemType *tmp = (ElemType*) malloc (L->Length * sizeof(ElemType));
    int len = 0;
    for (int i = 0; i < L->Length; i++)
    {
        if (L->pSqList[i] < s || L->pSqList[i] > t)
            tmp[len++] = L->pSqList[i];
    }
    L->pSqList = tmp;
    L->Length = len;
    return true;
}

int main()
{
	int n,i,s,t;
	SqList L;
	ElemType e;
	
	puts("请输入正整数n：\n");
	scanf("%d",&n);
	
	ElemType *p = (ElemType*) malloc (n * sizeof(ElemType));
	L.pSqList = p;
	L.Length = n;
	L.Size = MAX_SIZE;
	
	for (int j = 0; j < L.Length;j++)
		L.pSqList[j] = j;

    for (int j = 0;j < L.Length;j++)
		printf("%d ",L.pSqList[j]);
	puts("");

    puts("请输入要删除的元素值的范围：s,t（s<e<t）");
    scanf("%d%d",&s,&t);

    if (func04(&L,s,t) == true)
    {
        printf("%d\n",L.Length);
        for (int j = 0;j < L.Length;j++)
		    printf("%d ",L.pSqList[j]);
	    puts("");
    }
    else
    {
        puts("处理失败！");
    }
	
	return 0;
}

```
</details>

## 5、在有序顺序表中删除值在s和t之间的所有元素

<details>
<summary>点击查看代码</summary>

```c
/*
* author:HRL
*
* date:09/28/2020
* 
* description:
* 5、在有序顺序表中删除值在s和t之间的所有元素
*/

#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct SqList
{
	ElemType *pSqList;
	int Length;
	int Size;
}SqList;

Status func05(SqList *L,int s,int t)
{
    if (NULL == L || NULL == L->pSqList)
        return false;
    
    if (s > t)
    {
        int tp = t;
        t = s;
        s = t;
    }

    int i1 = 0,i2 = L->Length - 1;
    while (L->pSqList[i1] < s)
        i1++;

    while (L->pSqList[i2] > t)
        i2--;
    
    int l0 = t - s + 1;
    for (int i = i1; i < L->Length - l0; i++)
    {
        L->pSqList[i] = L->pSqList[i+l0];
    }
    L->Length -= l0;
    
    return true;
}

int main()
{
	int n,i,s,t;
	SqList L;
	ElemType e;
	
	puts("请输入正整数n：");
	scanf("%d",&n);
	
	ElemType *p = (ElemType*) malloc (n * sizeof(ElemType));
	L.pSqList = p;
	L.Length = n;
	L.Size = MAX_SIZE;
	
	for (int j = 0; j < L.Length;j++)
		L.pSqList[j] = j;

    for (int j = 0;j < L.Length;j++)
		printf("%d ",L.pSqList[j]);
	puts("");

    puts("请输入要删除的元素值的范围：s,t（s<e<t）");
    scanf("%d%d",&s,&t);
    
    if (func05(&L,s,t) == true)
	{
        for (int j = 0;j < L.Length;j++)
		printf("%d ",L.pSqList[j]);
	    puts("");
    }
	return 0;
}

```
</details>

## 6、将一个升序顺序表和一个降序顺序表合并成一个升序顺序表

**要点：**
1. 设置两个指针分别对升序顺序表和降序顺序表进行遍历。
2. 考虑到两个顺序表的长度不一样，遍历之后要将多的顺序表的元素插入回去，不能漏
3. 注意2中插入的数组边界，不要越界也不能漏了元素


<details>
<summary>点击查看代码</summary>

```c
/*
* author:HRL
*
* date:09/28/2020
* 
* description:
* 6、将一个升序顺序表和一个降序顺序表合并成一个升序顺序表
*/

#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct SqList
{
	ElemType *pSqList;
	int Length;
	int Size;
}SqList;

Status func06(SqList *L1, SqList *L2)
{
    if (NULL == L1 || NULL == L2)
        return false;
    if (NULL == L1->pSqList || NULL == L2->pSqList)
        return false; 

    SqList re;
    re.Length = L1->Length + L2->Length;
    re.pSqList = (ElemType*) malloc (re.Length * sizeof(ElemType));
    re.Size = L1->Size;
    
    if (L2->pSqList[L2->Length - 1] > L1->pSqList[L1->Length - 1])
    {
        int i,j;
        for (i = 0; i < L1->Length; i++)
        {
            re.pSqList[i] = L1->pSqList[i];
        }
        for ( j = 0; j < L2->Length; j++)
        {
            re.pSqList[i++] = L2->pSqList[L2->Length - j -1];
        }
    }
    if (L2->pSqList[0] < L1->pSqList[0])
    {
        int i,j;
        for (i = 0; i < L2->Length; i++)
        {
            re.pSqList[i] = L2->pSqList[i];
        }
        for ( j = 0; j < L1->Length; j++)
        {
            re.pSqList[i++] = L1->pSqList[j];
        }
    }

    int i1 = 0, i2 = L2->Length - 1,i = 0;
    
    while (i1 < L1->Length && i2 >= 0)
    {
        if (L1->pSqList[i1] < L2->pSqList[i2])
        {
            re.pSqList[i++] = L1->pSqList[i1];
            i1++;
        }
        else 
        {
            re.pSqList[i++] = L2->pSqList[i2];
            i2--;
        }
        
    }

    if (i1 < L1->Length)
    {
        while (i1 < L1->Length)
        {
            re.pSqList[i++] = L1->pSqList[i1++];
        }
        
    }

    if (i2 > -1)
    {
        while (i2 > -1)
        {
            re.pSqList[i++] = L2->pSqList[i2--];
        }
    }
    
    *L1 = re;
    return true;
}

int main()
{
	int n1,n2,l1,l2;
	SqList L1,L2;
	ElemType e;
	
	puts("请输入升序顺序表1的长度 l1：");
	scanf("%d",&l1);
    puts("请输入升序顺序表2的长度 l2：");
	scanf("%d",&l2);

    puts("请输入升序顺序表1的起始元素值（最小值） n1：");
	scanf("%d",&n1);
    puts("请输入升序顺序表2的起始元素值（最大值） n2：");
	scanf("%d",&n2);
	
	ElemType *p1 = (ElemType*) malloc (l1 * sizeof(ElemType));
    ElemType *p2 = (ElemType*) malloc (l2 * sizeof(ElemType));
	
    L1.pSqList = p1;
	L1.Length = l1;
	L1.Size = MAX_SIZE;

    L2.pSqList = p2;
	L2.Length = l2;
	L2.Size = MAX_SIZE;
	
	for (int j = 0; j < L1.Length;j++)
		L1.pSqList[j] = j + n1;

    for (int j = 0; j < L2.Length;j++)
		L2.pSqList[j] = n2--;

    for (int j = 0;j < L1.Length;j++)
		printf("%d ",L1.pSqList[j]);
	puts("");

	for (int j = 0;j < L2.Length;j++)
		printf("%d ",L2.pSqList[j]);
	puts("");

    if (func06(&L1,&L2) == true)
    {
        printf("顺序表长度为：%d\n",L1.Length);
        for (int j = 0;j < L1.Length;j++)
		    printf("%d ",L1.pSqList[j]);
	    puts("");
    }
    else
    {
        puts("处理失败！");
    }

	return 0;
}

```
</details>

## 7、单链表访问第i个元素

<details>
<summary>点击查看代码</summary>

```c
Status func07(LinkList L, int i)
{
    int id = 0;
    if (NULL == L)
        return false;
    LNodes *p = L->next;
    while (NULL != p && id < i)
    {
        p = p->next;
        id++;
    }
    if (NULL == p)
        return false;
    printf("第i个结点的数据为：%d\n",p->data);
    return true;
}
```
</details>

<details>
<summary>点击查看测试代码</summary>

```c
/*
* author:HRL
*
* date:09/29/2020
* 
* description:
* 7、单链表访问第i个元素
*/

#include <stdio.h>
#include <stdlib.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0();

LinkList LinkListCreat_Head01(ElemType *data,int n);

Status func07(LinkList L, int i)
{
    int id = 0;
    if (NULL == L)
        return false;
    LNodes *p = L->next;
    while (NULL != p && id < i)
    {
        p = p->next;
        id++;
    }
    if (NULL == p)
        return false;
    printf("第i个结点的数据为：%d\n",p->data);
    return true;
}

int main()
{
	int n,i;	
	ElemType *data;
	LinkList L = (LinkList) malloc (sizeof(LinkList));
	LNodes *p = NULL;

	puts("输入随机数的个数");
	scanf("%d",&n);

	data = CreatRand01(n,0);

	for (int j = 0;j < n;j++)
		printf("%d ",data[j]);
	puts("");

	L = LinkListCreat_Head01(data,n);
	p = L->next;

	while (NULL != p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	puts("");

    puts("请输入要访问的结点序号i：");
    scanf("%d",&i);
	
    if (func07(L,i) == false)
        puts("寻找失败了！");
	return 0;
}


//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0() 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  
       
    ElemType x;                         //x为链表数据域中的数据  
    while(scanf("%d",&x) != EOF) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = x;                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}   

LinkList LinkListCreat_Head01(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  

	int i = 0;                //x为链表数据域中的数据  
    while(i < n) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i++];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}  
```
</details>

## 8、在第i个位置前插入元素e

**要点：**
注意审题，是在第i个**前**插入！

<details>
<summary>点击查看代码</summary>

```c
Status func08(LinkList L,int i,ElemType e)
{
    if (NULL == L)
        return false;
    
    LNodes *pre = L,*p = L->next,*q;
    int id = 0;
    while (NULL != p && id < i)
    {
        pre = pre->next;
        p = p->next;
        id++;
    }
    if (NULL == p)
        return false;
    
    q = (LNodes*) malloc (sizeof(LNodes));
    q->data = e;

    q->next = pre->next;
    pre->next = q;
    return true;
}
```
</details>

<details>
<summary>点击查看测试代码</summary>

```c
/*
* author:HRL
*
* date:09/29/2020
* 
* description:
* 8、在第i个位置前插入元素e
*/

#include <stdio.h>
#include <stdlib.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0();

LinkList LinkListCreat_Head01(ElemType *data,int n);

Status func08(LinkList L,int i,ElemType e)
{
    if (NULL == L)
        return false;
    
    LNodes *pre = L,*p = L->next,*q;
    int id = 0;
    while (NULL != p && id < i)
    {
        pre = pre->next;
        p = p->next;
        id++;
    }
    if (NULL == p)
        return false;
    
    q = (LNodes*) malloc (sizeof(LNodes));
    q->data = e;

    q->next = pre->next;
    pre->next = q;
    return true;
}

int main()
{
	int n, i;	
	ElemType *data, e;
	LinkList L = (LinkList) malloc (sizeof(LinkList));
	LNodes *p = NULL;

	puts("输入随机数的个数");
	scanf("%d",&n);

	data = CreatRand01(n,0);

	for (int j = 0;j < n;j++)
		printf("%d ",data[j]);
	puts("");

	L = LinkListCreat_Head01(data,n);
	p = L->next;

	while (NULL != p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	puts("");
	
    puts("请输入要插入的结点序号i：");
    scanf("%d",&i);
    puts("请输入要插入的元素e的值：");
    scanf("%d",&e);
	
    if (func08(L,i,e) == false)
        puts("寻找失败了！");

    p = L->next;
	while (NULL != p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	puts("");
    
	return 0;
}


//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0() 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  
       
    ElemType x;                         //x为链表数据域中的数据  
    while(scanf("%d",&x) != EOF) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = x;                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}   

LinkList LinkListCreat_Head01(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  

	int i = 0;                //x为链表数据域中的数据  
    while(i < n) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i++];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}  
```
</details>

## 9、单链表删除第i个元素，用e返回

<details>
<summary>点击查看代码</summary>

```c
Status func09(LinkList L,int i,ElemType *e)
{
    if (NULL == L)
        return false;
    
    LNodes *pre = L,*p = L->next,*q;
    int id = 0;
    while (NULL != p && id < i)
    {
        pre = pre->next;
        p = p->next;
        id++;
    }
    if (NULL == p)
        return false;
    
    q = p;
    *e = q->data;
    p = p->next;
    pre->next = p;
    free(q);
    
    return true;
}
```
</details>

<details>
<summary>点击查看测试代码</summary>

```c
/*
* author:HRL
*
* date:09/29/2020
* 
* description:
* 9、单链表删除第i个元素，用e返回
*/

#include <stdio.h>
#include <stdlib.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0();

LinkList LinkListCreat_Head01(ElemType *data,int n);

Status func09(LinkList L,int i,ElemType *e)
{
    if (NULL == L)
        return false;
    
    LNodes *pre = L,*p = L->next,*q;
    int id = 0;
    while (NULL != p && id < i)
    {
        pre = pre->next;
        p = p->next;
        id++;
    }
    if (NULL == p)
        return false;
    
    q = p;
    *e = q->data;
    p = p->next;
    pre->next = p;
    free(q);
    
    return true;
}

int main()
{
	int n, i;	
	ElemType *data, *e;
	LinkList L = (LinkList) malloc (sizeof(LinkList));
	LNodes *p = NULL;

	puts("输入随机数的个数");
	scanf("%d",&n);

	data = CreatRand01(n,0);

	for (int j = 0;j < n;j++)
		printf("%d ",data[j]);
	puts("");

	L = LinkListCreat_Head01(data,n);
	p = L->next;

	while (NULL != p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	puts("");

    puts("请输入要删除的结点序号i：");
    scanf("%d",&i);
	
    if (func09(L,i,e) == false)
        puts("删除失败了！");
    else
    {
        printf("被删除的结点的数据为：%d\n",*e);
    }
    
	return 0;
}


//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0() 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  
       
    ElemType x;                         //x为链表数据域中的数据  
    while(scanf("%d",&x) != EOF) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = x;                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}   

LinkList LinkListCreat_Head01(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  

	int i = 0;                //x为链表数据域中的数据  
    while(i < n) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i++];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}  
```
</details>

## 10、la和lb按值非递减，归并la和lb，得到新的单链表lc，使得lc也按值非递减，并占用原来的空间

**要点：**
1. 首先应注意到两个单链表的结点数据域是升序的，故只要将第一个链表的头结点拆出来作为要返回结果的新链表的头结点，剩下的就是遍历两个链表的结点比较大小，谁小谁先插入到新链表的头结点。
2. 当插入新链表接受后，可能会有一个链表还未全部插入进去，这是只要把该链表的第一个结点插入到新链表后面即可。无需搞太复杂，继续遍历再单个结点插入什么的，这是容易出错的做法。

<details>
<summary>点击查看代码</summary>

```c
Status func10(LinkList L1,LinkList L2)
{
    if (NULL == L1 || NULL == L2)
        return false;

    LNodes *pre1, *p1 = L1->next, *pre2 = L2, *p2 = L2->next;
    L1->next = NULL;
    pre1 = L1;
    while (NULL != p1 && NULL != p2)
    {
        if (p1->data < p2->data)
        {
            LNodes *tmp = p1;
            p1 = p1->next;
            tmp->next = pre1->next;
            pre1->next = tmp;
           
        }
        else
        {
            LNodes *tmp = p2;
            p2 = p2->next;
            tmp->next = pre1->next;
            pre1->next = tmp;
        
        }
         pre1 = pre1->next;
    }
    if (NULL != p2)
    {
        pre1->next = p2;
    }

    if (NULL != p1)
    {
        pre1->next = p1;
    }
    
    return true;
}
```
</details>

<details>
<summary>点击查看测试代码</summary>

```c
/*
* author:HRL
*
* date:09/29/2020
* 
* description:
* 10、la和lb按值非递减，归并la和lb，得到新的单链表lc，使得lc也按值非递减，并占用原来的空间
*/

#include <stdio.h>
#include <stdlib.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0();

LinkList LinkListCreat_Head01(ElemType *data,int n);

Status func10(LinkList L1,LinkList L2)
{
    if (NULL == L1 || NULL == L2)
        return false;

    LNodes *pre1, *p1 = L1->next, *pre2 = L2, *p2 = L2->next;
    L1->next = NULL;
    pre1 = L1;
    while (NULL != p1 && NULL != p2)
    {
        if (p1->data < p2->data)
        {
            LNodes *tmp = p1;
            p1 = p1->next;
            tmp->next = pre1->next;
            pre1->next = tmp;
           
        }
        else
        {
            LNodes *tmp = p2;
            p2 = p2->next;
            tmp->next = pre1->next;
            pre1->next = tmp;
        
        }
         pre1 = pre1->next;
    }
    if (NULL != p2)
    {
        pre1->next = p2;
    }

    if (NULL != p1)
    {
        pre1->next = p1;
    }
    
    return true;
}

int main()
{
	int n1, n2;	
	ElemType *data1,*data2;
	LinkList L1, L2;
	LNodes *p1 = NULL, *p2 = NULL;

	puts("输入第一个非递减单链表的结点个数");
	scanf("%d",&n1);
    puts("输入第二个非递减单链表的结点个数");
	scanf("%d",&n2);

	data1 = CreatRand01(n1,1);
    data2 = CreatRand01(n2,1);

	L1 = LinkListCreat_Head01(data1,n1);
	p1 = L1->next;
    puts("打印第一个单链表：");
	while (NULL != p1)
	{
		printf("%d ",p1->data);
		p1 = p1->next;
	}
	puts("");

    L2 = LinkListCreat_Head01(data2,n2);
	p2 = L2->next;
    puts("打印第二个单链表：");
	while (NULL != p2)
	{
		printf("%d ",p2->data);
		p2 = p2->next;
	}
	puts("");

    if (func10(L1,L2) == false)
        puts("合并失败了！");
    else
    {
        puts("合并成功了！");
        p1 = L1->next;
        puts("打印第一个单链表：");
	    while (NULL != p1)
	    {
		    printf("%d ",p1->data);
		    p1 = p1->next;
	    }
	    puts("");

        p2 = L2->next;
        puts("打印第二个单链表：");
	    while (NULL != p2)
	    {
		    printf("%d ",p2->data);
		    p2 = p2->next;
	    }
	    puts("");
    }
	
	return 0;
}


//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0() 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  
       
    ElemType x;                         //x为链表数据域中的数据  
    while(scanf("%d",&x) != EOF) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = x;                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}   

LinkList LinkListCreat_Head01(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  

	int i = n;                //x为链表数据域中的数据  
    while(i > 0) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i--];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}  
```
</details>

## 11、通过一趟遍历确定链表中值最大的结点

**要点：**
一趟遍历获取单链表中数据域最大的结点是很容易的，但问题的关键在于如何通过函数将其返回函数外。可能由于前面的题目我写函数的定义时写多了：```Status func()```，返回值类型为Status，没有想到要将结点作为返回值。
应使用下面代码中所写的函数定义。

<details>
<summary>点击查看代码</summary>

```c
LinkList func11(LinkList L)
{
    if (NULL == L)
        return NULL;

    LNodes *p = L->next;
    LinkList max = p;
    p = p->next;
    while (NULL != p)
    {
        if (p->data > max->data)
        {
            max = p;
        }
        p = p->next;
    }
    return max;
}
```
</details>

<details>
<summary>点击测试查看代码</summary>

```c
/*
* author:HRL
*
* date:09/29/2020
* 
* description:
* 11、通过一趟遍历确定链表中值最大的结点
*/

#include <stdio.h>
#include <stdlib.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0();

LinkList LinkListCreat_Head01(ElemType *data,int n);

LinkList func11(LinkList L)
{
    if (NULL == L)
        return NULL;

    LNodes *p = L->next;
    LinkList max = p;
    p = p->next;
    while (NULL != p)
    {
        if (p->data > max->data)
        {
            max = p;
        }
        p = p->next;
    }
    return max;
}

int main()
{
	int n;	
	ElemType *data;
	LinkList L = (LinkList) malloc (sizeof(LinkList));
	LNodes *p = NULL, *max;

	puts("输入随机数的个数");
	scanf("%d",&n);

	data = CreatRand01(n,0);

	L = LinkListCreat_Head01(data,n);
	p = L->next;
    puts("打印单链表各结点：");
	while (NULL != p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	puts("");

    max = func11(L);
    if (max == NULL)
        puts("查找最大值失败了！");
    else
    {
        puts("查找最大值成功了！");
        printf("最大值为：%d\n",max->data);
    }
	
	return 0;
}


//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0() 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  
       
    ElemType x;                         //x为链表数据域中的数据  
    while(scanf("%d",&x) != EOF) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = x;                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}   

LinkList LinkListCreat_Head01(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  

	int i = 1;                //x为链表数据域中的数据  
    while(i < n) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i++];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}  
```
</details>

## 12、将链表中值最小的结点移动到链表的最前面

**要点：**
1. 需使用四个指针，两个指针用于遍历整个单链表并记录访问结点的前驱；另两个指针用于记录数据域最小的结点及其指针。
2. 当遍历结束后可使用记录数据域最小结点的指针及其前驱指针进行删除、插入到头结点后的操作。

<details>
<summary>点击查看代码</summary>

```c
Status func12(LinkList L)
{
    if (NULL == L)
        return false;

    LNodes *pre = L, *p = L->next, *min_pre, *min = L->next;
    p = p->next;
    pre = pre->next;
    min_pre = L;
    while (NULL != p)
    {
        if (p->data < min->data)
        {
            min_pre = pre;
            min = p;
        }
        pre = pre->next;
        p = p->next;
    }
    
    min_pre->next = min->next;
    min->next = L->next;
    L->next = min;
    
    return true;
}
```
</details>

<details>
<summary>点击查看测试代码</summary>

```c
/*
* author:HRL
*
* date:09/29/2020
* 
* description:
* 12、将链表中值最小的结点移动到链表的最前面
*/

#include <stdio.h>
#include <stdlib.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0();

LinkList LinkListCreat_Head01(ElemType *data,int n);

Status func12(LinkList L)
{
    if (NULL == L)
        return false;

    LNodes *pre = L, *p = L->next, *min_pre, *min = L->next;
    p = p->next;
    pre = pre->next;
    min_pre = L;
    while (NULL != p)
    {
        if (p->data < min->data)
        {
            min_pre = pre;
            min = p;
        }
        pre = pre->next;
        p = p->next;
    }
    
    min_pre->next = min->next;
    min->next = L->next;
    L->next = min;
    
    return true;
}

int main()
{
	int n;	
	ElemType *data;
	LinkList L = (LinkList) malloc (sizeof(LinkList));
	LNodes *p = NULL;

	puts("输入随机数的个数");
	scanf("%d",&n);

	data = CreatRand01(n,0);

	for (int j = 0;j < n;j++)
		printf("%d ",data[j]);
	puts("");

	L = LinkListCreat_Head01(data,n);
	p = L->next;
    puts("打印单链表各结点：");
	while (NULL != p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	puts("");

    if (func12(L) == false)
        puts("移动最小值失败了！");
    else
    {
        puts("移动最小值成功了！");
        p = L->next;
        puts("打印单链表各结点：");
	    while (NULL != p)
	    {
		    printf("%d ",p->data);
		    p = p->next;
	    }
	    puts("");
    }
	
	return 0;
}


//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0() 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  
       
    ElemType x;                         //x为链表数据域中的数据  
    while(scanf("%d",&x) != EOF) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = x;                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}   

LinkList LinkListCreat_Head01(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  

	int i = 1;                //x为链表数据域中的数据  
    while(i < n) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i++];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}  
```
</details>

## 13、对链表使用冒泡排序

**要点：**
1. 由于单链表的是只能单向遍历，且访问某一结点必须要先访问该结点前面的所有的结点，故冒泡排序的终止边界确定很困难。唯有采用一个死循环，当某一遍历过程中没有发生结点数据域交换则可知冒泡排序已结束。
2. 排序单链表时，由于只要求数据域有序，故只需交换数据域即可
3. 遍历时需使用两个指针，使用一个也可单要注意遍历的边界不是最后一个结点，而是倒数第二个，因为需要通过该指针指向的结点的后驱来访问最后一个结点的数据域。

<details>
<summary>点击查看代码</summary>

```c
Status func13(LinkList L)
{
    if (NULL == L)
        return false;

    LNodes *pre, *p;
    Status flag = false;
    
    while (1)
    {
        pre = L->next;
        p = pre->next;
        flag = false;
        while (p != NULL)
        {
            if (pre->data > p->data)
            {
                ElemType t = p->data;
                p->data = pre->data;
                pre->data = t;
                flag = true;
            }
            p = p->next;
            pre = pre->next;
        }
        if (flag == false)
            return true;
    }
    
    return true;
}
```
</details>

<details>
<summary>点击查看测试代码</summary>

```c
/*
* author:HRL
*
* date:09/29/2020
* 
* description:
* 13、对链表使用冒泡排序
*/

#include <stdio.h>
#include <stdlib.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0();

LinkList LinkListCreat_Head01(ElemType *data,int n);

Status func13(LinkList L)
{
    if (NULL == L)
        return false;

    LNodes *pre, *p;
    Status flag = false;
    
    while (1)
    {
        pre = L->next;
        p = pre->next;
        flag = false;
        while (p != NULL)
        {
            if (pre->data > p->data)
            {
                ElemType t = p->data;
                p->data = pre->data;
                pre->data = t;
                flag = true;
            }
            p = p->next;
            pre = pre->next;
        }
        if (flag == false)
            return true;
    }
    
    return true;
}

int main()
{
	int n;	
	ElemType *data;
	LinkList L = (LinkList) malloc (sizeof(LinkList));
	LNodes *p = NULL;

	puts("输入随机数的个数");
	scanf("%d",&n);

	data = CreatRand01(n,0);

	for (int j = 0;j < n;j++)
		printf("%d ",data[j]);
	puts("");

	L = LinkListCreat_Head01(data,n);
	p = L->next;
    puts("打印单链表各结点：");
	while (NULL != p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	puts("");

    if (func13(L) == false)
        puts("排序失败了！");
    else
    {
        puts("排序成功了！");
        p = L->next;
        puts("打印单链表各结点：");
	    while (NULL != p)
	    {
		    printf("%d ",p->data);
		    p = p->next;
	    }
	    puts("");
    }
	
	return 0;
}


//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0() 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  
       
    ElemType x;                         //x为链表数据域中的数据  
    while(scanf("%d",&x) != EOF) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = x;                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}   

LinkList LinkListCreat_Head01(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  

	int i = 1;                //x为链表数据域中的数据  
    while(i < n) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i++];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}  
```
</details>

## 14、升序链表中去掉值相同的元素

<details>
<summary>点击查看代码</summary>

```c
Status func14(LinkList L)
{
    if (NULL == L)
        return false;

    LNodes *pre = L, *p = L->next;
    while (p != NULL)
    {
        while (p->data == pre->data)
        {
            LNodes *tmp = p;
            pre->next = p->next;
            p = pre->next;
            free(tmp);
        }
        
        p = p->next;
        pre = pre->next;
    }
    
    return true;
}
```
</details>

<details>
<summary>点击查看测试代码</summary>

```c
/*
* author:HRL
*
* date:09/30/2020
* 
* description:
* 14、升序链表中去掉值相同的元素
*/

#include <stdio.h>
#include <stdlib.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0();

LinkList LinkListCreat_Head01(ElemType *data,int n);

Status func14(LinkList L)
{
    if (NULL == L)
        return false;

    LNodes *pre = L, *p = L->next;
    while (p != NULL)
    {
        while (p->data == pre->data)
        {
            LNodes *tmp = p;
            pre->next = p->next;
            p = pre->next;
            free(tmp);
        }
        
        p = p->next;
        pre = pre->next;
    }
    
    return true;
}

int main()
{
	int n;	
	ElemType *data;
	LinkList L = (LinkList) malloc (sizeof(LinkList));
	LNodes *p = NULL;

	puts("输入随机数的个数");
	scanf("%d",&n);

	data = CreatRand01(n,1);

	for (int j = 0;j <= n;j++)
		printf("%d ",data[j]);
	puts("");

	L = LinkListCreat_Head01(data,n);
	p = L->next;
    puts("打印单链表各结点：");
	while (NULL != p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	puts("");

    if (func14(L) == false)
        puts("删除失败了！");
    else
    {
        puts("删除成功了！");
        p = L->next;
        puts("打印单链表各结点：");
	    while (NULL != p)
	    {
		    printf("%d ",p->data);
		    p = p->next;
	    }
	    puts("");
    }
	
	return 0;
}


//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0() 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  
       
    ElemType x;                         //x为链表数据域中的数据  
    while(scanf("%d",&x) != EOF) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = x;                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}   

LinkList LinkListCreat_Head01(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  

	int i = 1;                //x为链表数据域中的数据  
    while(i < n) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i++];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}  
```
</details>

## 15、将一个升序链表和一个降序链表合并成一个有序链表

<details>
<summary>点击查看代码</summary>

```c
Status func15(LinkList L1,LinkList L2)
{
    if (NULL == L1 || NULL == L2)
        return false;

    //先将降序的单链表转成升序的
    LNodes *pre1 = L1->next, *p1,
    *pre2 = L2->next, *p2;

    p1 = pre1->next;
    p2 = pre2->next;

    if (pre1->data > p1->data)
    {
        //L2是降序的，对L2进行处理：
        L1->next = NULL;
        while (NULL != pre1)
        {
            p1 = pre1;
            pre1 = pre1->next;

            p1->next = L1->next;
            L1->next = p1;
        }
        
    }

    if (pre2->data > p2->data)
    {
        //L2是降序的，对L2进行处理：
        L2->next = NULL;
        while (NULL != pre2)
        {
            p2 = pre2;
            pre2 = pre2->next;

            p2->next = L2->next;
            L2->next = p2;
        }
    }

    //全部转成升序后，重置指针指向的结点，开始合并
    pre1 = L1;
    p1 = L1->next;

    pre2 = L2;
    p2 = L2->next;

    L1->next = NULL;

    while (NULL != p1 && NULL != p2)
    {
        if (p1->data > p2->data)
        {
            pre2->next = p2->next;

            p2->next = pre1->next;
            pre1->next = p2;

            p2 = pre2->next;
        }
        else
        {
            LNodes *tmp = p1->next;

            p1->next = pre1->next;
            pre1->next = p1;

            p1 = tmp;
        }
        pre1 = pre1->next;
    }
    if (NULL != p1)
    {
        pre1->next = p1;
    }
    if (NULL != p2)
    {
        pre1->next = p2;
    }
    
    return true;
}
```
</details>

<details>
<summary>点击查看测试代码</summary>

```c
/*
* author:HRL
*
* date:09/30/2020
* 
* description:
* 15、将一个升序链表和一个降序链表合并成一个有序链表
*/

#include <stdio.h>
#include <stdlib.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0();

LinkList LinkListCreat_Head01(ElemType *data,int n);

Status func15(LinkList L1,LinkList L2)
{
    if (NULL == L1 || NULL == L2)
        return false;

    //先将降序的单链表转成升序的
    LNodes *pre1 = L1->next, *p1,
    *pre2 = L2->next, *p2;

    p1 = pre1->next;
    p2 = pre2->next;

    if (pre1->data > p1->data)
    {
        //L2是降序的，对L2进行处理：
        L1->next = NULL;
        while (NULL != pre1)
        {
            p1 = pre1;
            pre1 = pre1->next;

            p1->next = L1->next;
            L1->next = p1;
        }
        
    }

    if (pre2->data > p2->data)
    {
        //L2是降序的，对L2进行处理：
        L2->next = NULL;
        while (NULL != pre2)
        {
            p2 = pre2;
            pre2 = pre2->next;

            p2->next = L2->next;
            L2->next = p2;
        }
    }

    //全部转成升序后，重置指针指向的结点，开始合并
    pre1 = L1;
    p1 = L1->next;

    pre2 = L2;
    p2 = L2->next;

    L1->next = NULL;

    while (NULL != p1 && NULL != p2)
    {
        if (p1->data > p2->data)
        {
            pre2->next = p2->next;

            p2->next = pre1->next;
            pre1->next = p2;

            p2 = pre2->next;
        }
        else
        {
            LNodes *tmp = p1->next;

            p1->next = pre1->next;
            pre1->next = p1;

            p1 = tmp;
        }
        pre1 = pre1->next;
    }
    if (NULL != p1)
    {
        pre1->next = p1;
    }
    if (NULL != p2)
    {
        pre1->next = p2;
    }
    
    return true;
}

int main()
{
	int n1, n2;	
	ElemType *data1,*data2;
	LinkList L1, L2;
	LNodes *p1 = NULL, *p2 = NULL;

	puts("输入第一个升序单链表的结点个数");
	scanf("%d",&n1);
    puts("输入第二个降序单链表的结点个数");
	scanf("%d",&n2);

	data1 = CreatRand01(n1,1);
    data2 = CreatRand01(n2,-1);

	L1 = LinkListCreat_Head01(data1,n1);
	p1 = L1->next;
    puts("打印第一个单链表：");
	while (NULL != p1)
	{
		printf("%d ",p1->data);
		p1 = p1->next;
	}
	puts("");

    L2 = LinkListCreat_Head01(data2,n2);
	p2 = L2->next;
    puts("打印第二个单链表：");
	while (NULL != p2)
	{
		printf("%d ",p2->data);
		p2 = p2->next;
	}
	puts("");

    if (func15(L1,L2) == false)
        puts("合并失败了！");
    else
    {
        puts("合并成功了！");
        p1 = L1->next;
        puts("打印第一个单链表：");
	    while (NULL != p1)
	    {
		    printf("%d ",p1->data);
		    p1 = p1->next;
	    }
	    puts("");

        p2 = L2->next;
        puts("打印第二个单链表：");
	    while (NULL != p2)
	    {
		    printf("%d ",p2->data);
		    p2 = p2->next;
	    }
	    puts("");
    }
	
	return 0;
}


//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0() 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  
       
    ElemType x;                         //x为链表数据域中的数据  
    while(scanf("%d",&x) != EOF) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = x;                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}   

LinkList LinkListCreat_Head01(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  

	int i = n;                //x为链表数据域中的数据  
    while(i > 0) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i--];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}  
```
</details>

## 16、设有一个非递减的正整数序列组成一个单链表（有重复数），设计算法确定比x小的数有几个

<details>
<summary>点击查看代码</summary>

```c
int func16(LinkList L,ElemType x)
{
    int re = 0;
    if (NULL == L)
        return 0;

    LNodes *p = L->next;
    while (NULL != p && p->data < x)
    {
        re += 1;
        p = p->next;
    }
    
    return re;
}
```
</details>

<details>
<summary>点击查看测试代码</summary>

```c
/*
* author:HRL
*
* date:09/30/2020
* 
* description:
* 16、设有一个非递减的正整数序列组成一个单链表（有重复数），
设计算法确定比x小的数有几个
*/

#include <stdio.h>
#include <stdlib.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0();

LinkList LinkListCreat_Head01(ElemType *data,int n);

int func16(LinkList L,ElemType x)
{
    int re = 0;
    if (NULL == L)
        return 0;

    LNodes *p = L->next;
    while (NULL != p && p->data < x)
    {
        re += 1;
        p = p->next;
    }
    
    return re;
}

int main()
{
	int n;	
	ElemType *data,x;
	LinkList L = (LinkList) malloc (sizeof(LinkList));
	LNodes *p = NULL;

	puts("输入随机数的个数");
	scanf("%d",&n);

	data = CreatRand01(n,1);

	for (int j = 0;j <= n;j++)
		printf("%d ",data[j]);
	puts("");

	L = LinkListCreat_Head01(data,n);
	p = L->next;
    puts("打印单链表各结点：");
	while (NULL != p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	puts("");

    puts("请输入要比较的的x：");
    scanf("%d",&x);

    int re = func16(L,x);
    if (re == 0)
        puts("查找失败了！");
    else
    {
        puts("查找成功了！");
        printf("比x小的有%d个\n",re);
        p = L->next;
        puts("打印单链表各结点：");
	    while (NULL != p)
	    {
		    printf("%d ",p->data);
		    p = p->next;
	    }
	    puts("");
    }
	
	return 0;
}


//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0() 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  
       
    ElemType x;                         //x为链表数据域中的数据  
    while(scanf("%d",&x) != EOF) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = x;                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}   

LinkList LinkListCreat_Head01(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  

	int i = n;                //x为链表数据域中的数据  
    while(i > 0) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i--];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}   
```
</details>

## 17、已知指针la和lb分别指向两个无头结点的单链表的首个结点。编写函数完成从la中删除第j个元素开始的共len个元素，并将这len个元素插入到表lb中第j个元素之前

**注意：**
有问题，大多数情况下没有问题，但是当j取的比较极端的时候就不行

<details>
<summary>点击查看代码</summary>

```c
LinkList get_Ith_Node(LinkList L,int i)
{
    if (NULL == L)
        return NULL;
    
    int cnt = 0;
    LNodes *p = L,*pre = NULL;
    while (NULL != p && cnt < i)
    {
        pre = p;
        p = p->next;
        cnt++;
    }
    if (NULL == p)
        return NULL;

    return pre;
}

Status func17(LinkList la,LinkList lb,int j,int len)
{
    if (NULL == la || NULL == lb)
        return false;

    LNodes *pb_pre, *tmp1_pre, *tmp1,*pb, *tmp2_pre,*tmp2;
    
    //给原本没有头结点的单链表加上头结点
    LinkList head_la,head_lb;
    head_la = (LinkList) malloc (sizeof(LNodes));
    head_lb = (LinkList) malloc (sizeof(LNodes));
    head_la->next = la;
    head_lb->next = lb;

    //先找la中第j个结点：
    tmp1_pre = get_Ith_Node(head_la,j);
    tmp1 = tmp1_pre->next;
    if (tmp1 == NULL)
        return false;
    printf("tmp1:%d\n",tmp1->data);

    //再找la中第j+len个结点：
    tmp2_pre = get_Ith_Node(tmp1_pre,len);
    tmp2 = tmp2_pre->next;
    if (tmp2 == NULL)
    {
        return false;
    }
    else
    {
        printf("tmp2:%d\n",tmp2->data);
        tmp1_pre->next = tmp2->next;
        //tmp2->next = NULL;
    }
    
    
    pb_pre = get_Ith_Node(head_lb,j);
    pb = pb_pre->next;
    printf("pb_pre_next:%d\n",pb->data);
    if (pb == NULL)
        return false;
    else
    {
        puts("插入lb了！");
        tmp2->next = pb_pre->next;
        pb_pre->next = tmp1;
    }
    

    la = head_la->next;
    lb = head_lb->next;
    //head_la->next = NULL;
    //head_lb->next = NULL;
    free(head_la);
    free(head_lb);
    return true;
}
```
</details>

<details>
<summary>点击查看测试代码</summary>

```c
/*
* author:HRL
*
* date:09/30/2020
* 
* description:
* 17、已知指针la和lb分别指向两个无头结点的单链表的首个结点。
编写函数完成从la中删除第j个元素开始的共len个元素，
并将这len个元素插入到表lb中第j个元素之前
*/

#include <stdio.h>
#include <stdlib.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0();

LinkList LinkListCreat_01(ElemType *data,int n);

LinkList get_Ith_Node(LinkList L,int i)
{
    if (NULL == L)
        return NULL;
    
    int cnt = 0;
    LNodes *p = L,*pre = NULL;
    while (NULL != p && cnt < i)
    {
        pre = p;
        p = p->next;
        cnt++;
    }
    if (NULL == p)
        return NULL;

    return pre;
}

Status func17(LinkList la,LinkList lb,int j,int len)
{
    if (NULL == la || NULL == lb)
        return false;

    LNodes *pb_pre, *tmp1_pre, *tmp1,*pb, *tmp2_pre,*tmp2;
    
    //给原本没有头结点的单链表加上头结点
    LinkList head_la,head_lb;
    head_la = (LinkList) malloc (sizeof(LNodes));
    head_lb = (LinkList) malloc (sizeof(LNodes));
    head_la->next = la;
    head_lb->next = lb;

    //先找la中第j个结点：
    tmp1_pre = get_Ith_Node(head_la,j);
    tmp1 = tmp1_pre->next;
    if (tmp1 == NULL)
        return false;
    printf("tmp1:%d\n",tmp1->data);

    //再找la中第j+len个结点：
    tmp2_pre = get_Ith_Node(tmp1_pre,len);
    tmp2 = tmp2_pre->next;
    if (tmp2 == NULL)
    {
        return false;
    }
    else
    {
        printf("tmp2:%d\n",tmp2->data);
        tmp1_pre->next = tmp2->next;
        //tmp2->next = NULL;
    }
    
    
    pb_pre = get_Ith_Node(head_lb,j);
    pb = pb_pre->next;
    printf("pb_pre_next:%d\n",pb->data);
    if (pb == NULL)
        return false;
    else
    {
        puts("插入lb了！");
        tmp2->next = pb_pre->next;
        pb_pre->next = tmp1;
    }
    

    la = head_la->next;
    lb = head_lb->next;
    //head_la->next = NULL;
    //head_lb->next = NULL;
    free(head_la);
    free(head_lb);
    return true;
}

int main()
{
	int n1, n2, j, len;	
	ElemType *data1,*data2;
	LinkList la, lb;
	LNodes *p1 = NULL, *p2 = NULL;

	puts("输入第一个单链表la的结点个数");
	scanf("%d",&n1);
    puts("输入第二个单链表lb的结点个数");
	scanf("%d",&n2);

	data1 = CreatRand01(n1,0);
    data2 = CreatRand01(n2,0);

	la = LinkListCreat_01(data1,n1);
	p1 = la;
    puts("打印第一个单链表la：");
	while (NULL != p1)
	{
		printf("%d ",p1->data);
		p1 = p1->next;
	}
	puts("");

    lb = LinkListCreat_01(data2,n2);
	p2 = lb;
    puts("打印第二个单链表lb：");
	while (NULL != p2)
	{
		printf("%d ",p2->data);
		p2 = p2->next;
	}
	puts("");

    puts("请输入删除la中结点开始的序号j：");
    scanf("%d",&j);
     puts("请输入删除la中结点的个数len：");
    scanf("%d",&len);

    if (func17(la,lb,j,len) == false)
        puts("删除失败了！");
    else
    {
        puts("删除成功了！");
        p1 = la;
        puts("打印第一个单链表la：");
	    while (NULL != p1)
	    {
		    printf("%d ",p1->data);
		    p1 = p1->next;
	    }
	    puts("");

        p2 = lb;
        puts("打印第二个单链表lb：");
	    while (NULL != p2)
	    {
		    printf("%d ",p2->data);
		    p2 = p2->next;
	    }
	    puts("");
    }
	
	return 0;
}


//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0() 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  
       
    ElemType x;                         //x为链表数据域中的数据  
    while(scanf("%d",&x) != EOF) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = x;                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}   

//单链表（不带头结点）的建立1，头插法建立单链表
LinkList LinkListCreat_01(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请首结点空间  
    L->data = data[n];
    L->next = NULL;                      //初始化一个空链表  

	int i = n - 1;                //x为链表数据域中的数据  
    while(i > 0) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i--];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}  
```
</details>

## 18、设单链表表头指针为L，节点数据域为字符。设计时间复杂度最低的算法判断前n个字符是否中心对称，例如：xyx和xyyx均对称

**要点：**
1. 使用一个栈来存链表中前一半的数据
2. 对后一半链表继续遍历，并与栈中的数据进行比较

<details>
<summary>点击查看代码</summary>

```c
Status func18(LinkList L,int n)
{
    if (NULL == L)
        return false;

    ElemType *t = (ElemType*) malloc ( (n / 2) * sizeof(ElemType));
    LNodes *p = L->next;
    int cnt = 0,flag = 0;
    while (NULL != p && cnt < n/2)
    {
        t[cnt++] = p->data;
        p = p->next;
    }
    if (n % 2 != 0)
        p = p->next;
    
    while (NULL != p)
    {
        if (t[--cnt] != p->data)
            flag++;
        p = p->next;
    }
    
    if (flag > 0)
        return false;
    else
        return true;
}
```
</details>

<details>
<summary>点击查看测试代码</summary>

```c
/*
* author:HRL
*
* date:10/02/2020
* 
* description:
* 设单链表表头指针为L，节点数据域为字符。设计时间复杂度最低的算法判断前n个字符是否中心对称，
例如：xyx和xyyx均对称
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType char

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head01(ElemType *data,int n);

Status func18(LinkList L,int n)
{
    if (NULL == L)
        return false;

    ElemType *t = (ElemType*) malloc ( (n / 2) * sizeof(ElemType));
    LNodes *p = L->next;
    int cnt = 0,flag = 0;
    while (NULL != p && cnt < n/2)
    {
        t[cnt++] = p->data;
        p = p->next;
    }
    if (n % 2 != 0)
        p = p->next;
    
    while (NULL != p)
    {
        if (t[--cnt] != p->data)
            flag++;
        p = p->next;
    }
    
    if (flag > 0)
        return false;
    else
        return true;
}

int main()
{
	int n;	
	ElemType data[20], x;
	LinkList L = (LinkList) malloc (sizeof(LinkList));
	LNodes *p = NULL;

	puts("输入一个要存入单链表的字符串");
	gets(data);
    n = strlen(data);
	puts(data);

	L = LinkListCreat_Head01(data,n);
	p = L->next;
	 puts("打印单链表各结点：");
	while (NULL != p)
	{
		printf("%c",p->data);
		p = p->next;
	}
	puts("");

    if (func18(L,n) == false)
        puts("不是中心对称的！");
    else
    {
       puts("是中心对称的！");
    }
    
	return 0;
}


//单链表（带头结点）的建立1，尾插法建立循环单链表  
LinkList LinkListCreat_Head01(ElemType *data,int n) 
{  
    LNodes *L,*pre;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  
    pre = L;

	int i = 0;                //x为链表数据域中的数据  
    while(i < n) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i++];                     //结点数据域赋值   
        p->next = pre->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        pre->next = p;
        pre = pre->next;   
    }  
    return L;   
}  
```
</details>

## 19、设L为单链表的头结点地址，其数据结点都是正整数且无相同的，设计一个空间复杂度最低的算法，利用直接插入排序把该链表整理成有序递增的链表

<details>
<summary>点击查看代码</summary>

```c
Status func19(LinkList L)
{
    if (NULL == L)
        return false;

    LNodes *tmp, *p = L->next;
    L->next = NULL;

    while (NULL != p)
    {
        LNodes *move = L->next,*move_pre = L;
        while (NULL != move && p->data > move->data)
        {
            move_pre = move;
            move = move->next;
        }
        tmp = p;
        p = p->next;
        tmp->next = move_pre->next;
        move_pre->next = tmp;
    }
     
    return true;
}
```
</details>

<details>
<summary>点击查看测试代码</summary>

```c
/*
* author:HRL
*
* date:10/02/2020
* 
* description:
* 19、设L为单链表的头结点地址，其数据结点都是正整数且无相同的，
设计一个空间复杂度最低的算法，利用直接插入排序把该链表整理成有序递增的链表
*/

#include <stdio.h>
#include <stdlib.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head01(ElemType *data,int n);

Status func19(LinkList L)
{
    if (NULL == L)
        return false;

    LNodes *tmp, *p = L->next;
    L->next = NULL;

    while (NULL != p)
    {
        LNodes *move = L->next,*move_pre = L;
        while (NULL != move && p->data > move->data)
        {
            move_pre = move;
            move = move->next;
        }
        tmp = p;
        p = p->next;
        tmp->next = move_pre->next;
        move_pre->next = tmp;
    }
     
    return true;
}

int main()
{
	int n;	
	ElemType *data;
	LinkList L = (LinkList) malloc (sizeof(LinkList));
	LNodes *p = NULL;

	puts("输入随机数的个数");
	scanf("%d",&n);

	data = CreatRand01(n,0);

	for (int j = 0;j < n;j++)
		printf("%d ",data[j]);
	puts("");

	L = LinkListCreat_Head01(data,n);
	p = L->next;
	puts("打印单链表各结点：");
	while (NULL != p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	puts("");

    if (func19(L) == false)
        puts("处理失败！");
    else
    {
        p = L->next;
	    puts("打印单链表各结点：");
	    while (NULL != p)
	    {
		    printf("%d ",p->data);
		    p = p->next;
	    }
	    puts("");
    }
	
	return 0;
}


//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0() 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  
       
    ElemType x;                         //x为链表数据域中的数据  
    while(scanf("%d",&x) != EOF) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = x;                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}   

LinkList LinkListCreat_Head01(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  

	int i = n;                //x为链表数据域中的数据  
    while(i > 0) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i--];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}  


```
</details>

## 20、设计一个算法，判断L1是否为L2的子链，子链的定义为L1中的从前到后的所有数据域都按照原有顺序出现在L2中

<details>
<summary>点击查看代码</summary>

```c
Status func20(LinkList L1,LinkList L2)
{
    if (NULL == L1 || NULL == L2)
        return false;

    LNodes *st = L2->next;
    while (NULL != st)
    {
        LNodes *p1 = L1->next, *p2 = st;
        while (NULL != p1 && p1->data == p2->data)
        {
            p1 = p1->next;
            p2 = p2->next;        
        }
        if (NULL == p1)
            return true;
        st = st->next;
    }
    
    return false;
}
```
</details>

<details>
<summary>点击查看测试代码</summary>

```c
/*
* author:HRL
*
* date:10/02/2020
* 
* description:
* 20、设计一个算法，判断L1是否为L2的子链，
子链的定义为L1中的从前到后的所有数据域都按照原有顺序出现在L2中
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType char

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head01(ElemType *data,int n);

Status func20(LinkList L1,LinkList L2)
{
    if (NULL == L1 || NULL == L2)
        return false;

    LNodes *st = L2->next;
    while (NULL != st)
    {
        LNodes *p1 = L1->next, *p2 = st;
        while (NULL != p1 && p1->data == p2->data)
        {
            p1 = p1->next;
            p2 = p2->next;        
        }
        if (NULL == p1)
            return true;
        st = st->next;
    }
    
    return false;
}

int main()
{
	int n1, n2;	
	ElemType data1[MAX_SIZE], data2[MAX_SIZE];
	LinkList L1, L2;
	LNodes *p1 = NULL, *p2 = NULL;

    puts("请输入被查找的字符串：");
    gets(data2);
    puts("请输入要查找的子串：");
    gets(data1);

    n1 = strlen(data1);
    n2 = strlen(data2);

	L1 = LinkListCreat_Head01(data1,n1);
	p1 = L1->next;
    puts("打印第一个单链表：");
	while (NULL != p1)
	{
		printf("%c",p1->data);
		p1 = p1->next;
	}
	puts("");

    L2 = LinkListCreat_Head01(data2,n2);
	p2 = L2->next;
    puts("打印第二个单链表：");
	while (NULL != p2)
	{
		printf("%c",p2->data);
		p2 = p2->next;
	}
	puts("");

    if (func20(L1,L2) == false)
        puts("L1不是L2的子链！");
    else
    {
        puts("L1是L2的子链！");
    }
	
	return 0;
}


//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head01(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  

	int i = n-1;                //x为链表数据域中的数据  
    while(i >= 0) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i--];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}  
```
</details>

## 21、L1与L2分别为两单链表头结点，地址指针，且两表中数据结点的数据域均为一个字母，且L2中不会有重复子串，例如：abeabc，ab为重复子串。设计在L1中，把L1与L2中数据相同子链的顺序完全倒置的算法。

例如：L1（a,b,c,a,b,e）L2(a,b,c,b,e)
逆置后的L1为(c,b,a,a,e,b)

```c
 typedef struct LinkNode｛
	 ElemType data；
 	struct LinkNode ＊next＿node；
 ｝LinkNode；
//依次在LI中匹配与L2相同的子链。如果L1中子链 substr1长度大于一
则将子链进行逆置。遇置过程如下:获得p的前驱结点pre，将p之外的 substr1结点依次插入到pre之后。
 status reverseSimilarNode（LinkNode ＊L1， LinkNode ＊L2）
｛
	 if （NULL = L1 NULL = L2）
｛
	 return FALSE；
｝

 LinkNode ＊pre1=L1；
 LinkNode ＊p1 =L1->next node；
 while （NULL ！ p1）
｛
	//11在L2中找到与p1结点相同的结点p2，p2可能是相同子链的第一个结点
1找到第一个相同结点后，后面的结点继续相同则断链取出，再插入到pre后
 LinkNode＊2=l2->next＿node；
 while（NULL ！ p2 ＆ p2->data ！ p1->data）｛
 p2=p2->next＿node；
｝
11子链长度大于1，在L1中依次取相同结点插入到pre后进行遇置。子链含有一个结点不需要置 if （p2 ！ NULL）｛
 LinkNode＊t1=p1->next＿node；1从第二个相同结点开始置，第一个结点不需要动 LinkNode ＊t2 =p2->next＿node；
1从第二个相同结点开始，依次将相同结点断链后取出，再插入到pre后
 while（null=ti＆＆ NULL=t2＆＆t1->data==t2->data）｛
p->next＿node=t->next＿node；//将L1待插入的相同结点取出，断链
t1->next＿node=pre->next＿node；//插入到pre后
 pre1->next＿node t1；
∥/取下一个相同结点
t1=p1->next＿node；//取出相同结点后，p1是下一个待处理结点的前驱
t2=t2->next＿node；//L2没有取出任何结点，直接取下一个待比较的结点
｝
｝
操作完成后，下一个待插入的pre是逆置子链的最后一个结点，即是p1
 prel =p1；
 p1 p1->next node；
 return TRUE；

```

## 22、设计算法将循环单链表中结点p的直接前驱删除

<details>
<summary>点击查看代码</summary>

```c
Status func18(LinkList L,ElemType x)
{
    if (NULL == L)
        return false;

    LNodes *pre,*p;
    pre = L;
    p = L->next;

    while (p->next->data != x)
    {
        pre = p;
        if (NULL == p->next)
        {
            pre = L;
            p = L->next;
        }
        else
            p = p->next;
    }
    if (pre->next == L)
        return false;

    pre->next = p->next;
    free(p);
    
    return true;
}
```
</details>

<details>
<summary>点击查看测试代码</summary>

```c
/*
* author:HRL
*
* date:10/02/2020
* 
* description:
* 18、设计算法将循环单链表中结点p的直接前驱删除
*/

#include <stdio.h>
#include <stdlib.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head0();

LinkList LinkListCreat_Head01(ElemType *data,int n);

Status func18(LinkList L,ElemType x)
{
    if (NULL == L)
        return false;

    LNodes *pre,*p;
    pre = L;
    p = L->next;

    while (p->next->data != x)
    {
        pre = p;
        if (NULL == p->next)
        {
            pre = L;
            p = L->next;
        }
        else
            p = p->next;
    }
    if (pre->next == L)
        return false;

    pre->next = p->next;
    free(p);
    
    return true;
}

int main()
{
	int n;	
	ElemType *data, x;
	LinkList L = (LinkList) malloc (sizeof(LinkList));
	LNodes *p = NULL;

	puts("输入随机数的个数");
	scanf("%d",&n);

	data = CreatRand01(n,0);

	for (int j = 0;j < n;j++)
		printf("%d ",data[j]);
	puts("");

	L = LinkListCreat_Head01(data,n);
	p = L->next;
	 puts("打印单链表各结点：");
	while (NULL != p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	puts("");

    puts("请输入要删除直接前驱的结点的数据域的值：");
	scanf("%d",&x);
    if (func18(L,x) == false)
        puts("删除失败！");
    else
    {
        p = L->next;
	    puts("打印删除后的循环单链表各结点：");
	    while (NULL != p)
	    {
		    printf("%d ",p->data);
		    p = p->next;
	    }
	    puts("");

    }
    
	return 0;
}


//单链表（带头结点）的建立1，尾插法建立循环单链表  
LinkList LinkListCreat_Head01(ElemType *data,int n) 
{  
    LNodes *L,*pre;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  
    pre = L;

	int i = n;                //x为链表数据域中的数据  
    while(i > 0) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i--];                     //结点数据域赋值   
        p->next = pre->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        pre->next = p;
        pre = pre->next;   
    }  
    return L;   
}  
```
</details>

## 23、设计算法将一个含有数字、字母、其他字符组成的循环链表拆分成三个循环链表，每条链表中都只包含一种类型的字符

<details>
<summary>点击查看代码</summary>

```c
Status func23(LinkList L1,LinkList *L2, LinkList *L3)
{
    if (NULL == L1)
        return false;

    LNodes *p = L1->next, *pre = L1;
    L1->next = L1;
    
    *L2 = (LinkList) malloc (sizeof(LNodes)); 
    (*L2)->next = *L2;
    
    *L3 = (LinkList) malloc (sizeof(LNodes)); 
    (*L3)->next = *L3;
    while (L1 != p)
    {
        LNodes *tmp;
        tmp = p->next;
        if (p->data >= '0' && p->data <= '9')
        {
            printf("找到数字了:%c\n",p->data);
            pre->next = p->next;
            p->next = (*L2)->next;
            (*L2)->next = p;
            p = tmp;
        }
        else if ( (p->data >= 'a' && p->data <= 'z')
        || (p->data >= 'A' && p->data <= 'Z'))
        {
            printf("找到字母了:%c\n",p->data);
            pre->next = p->next;
            p->next = (*L3)->next;
            (*L3)->next = p;
            p = tmp;
        }
        else
        {
            printf("找到其他字符了:%c\n",p->data);
            p = p->next;
            pre = pre->next;
        }   
    }
    return true;
}
```
</details>

<details>
<summary>点击查看测试代码</summary>

```c
/*
* author:HRL
*
* date:10/02/2020
* 
* description:
* 23、设计算法将一个含有数字、字母、其他字符组成的循环链表拆分成三个循环链表，
每条链表中都只包含一种类型的字符
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType char

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head01(ElemType *data,int n);

Status func23(LinkList L1,LinkList *L2, LinkList *L3)
{
    if (NULL == L1)
        return false;

    LNodes *p = L1->next, *pre = L1;
    L1->next = L1;
    
    *L2 = (LinkList) malloc (sizeof(LNodes)); 
    (*L2)->next = *L2;
    
    *L3 = (LinkList) malloc (sizeof(LNodes)); 
    (*L3)->next = *L3;
    while (L1 != p)
    {
        LNodes *tmp;
        tmp = p->next;
        if (p->data >= '0' && p->data <= '9')
        {
            printf("找到数字了:%c\n",p->data);
            pre->next = p->next;
            p->next = (*L2)->next;
            (*L2)->next = p;
            p = tmp;
        }
        else if ( (p->data >= 'a' && p->data <= 'z')
        || (p->data >= 'A' && p->data <= 'Z'))
        {
            printf("找到字母了:%c\n",p->data);
            pre->next = p->next;
            p->next = (*L3)->next;
            (*L3)->next = p;
            p = tmp;
        }
        else
        {
            printf("找到其他字符了:%c\n",p->data);
            p = p->next;
            pre = pre->next;
        }   
    }
    return true;
}

int main()
{
	int n;	
	ElemType data[MAX_SIZE];
	LinkList L1, L2, L3;
	LNodes *p1 = NULL, *p2 = NULL, *p3 = NULL;

    puts("请输入被处理的字符串：");
    gets(data);

    n = strlen(data);

	L1 = LinkListCreat_Head01(data,n);
	p1 = L1->next;
    puts("打印第一个单链表：");
	while (L1 != p1)
	{
		printf("%c",p1->data);
		p1 = p1->next;
	}
	puts("");

    L2 = (LinkList) malloc (sizeof(LNodes));
    L2->next = L2;

    L3 = (LinkList) malloc (sizeof(LNodes));
    L3->next = L3;

    if (func23(L1,&L2,&L3) == false)
        puts("处理失败！");
    else
    {
        puts("------输出结果------");
        p1 = L1->next;
        puts("打印第1个单链表：");
        if (L1 == p1)
            puts("该链表为空！");
        else
        {
            while (L1 != p1)
	        {
		        printf("%c",p1->data);
		        p1 = p1->next;
	        }
	        puts("");
        }
        
        p2 = L2->next;
        puts("打印第2个单链表：");
        if (L2 == p2)
            puts("该链表为空！");
        else
        {
            while (L2 != p2)
	        {
		        printf("%c",p2->data);
		        p2 = p2->next;
	        }
	        puts("");
        }
	    
        p3 = L3->next;
        puts("打印第3个单链表：");
        if (L3 == p3)
            puts("该链表为空！");
        else
        {
            while (L3 != p3)
	        {
		        printf("%c",p3->data);
		        p3 = p3->next;
	        }
	        puts("");
        }
    }
	
	return 0;
}


//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head01(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = L;                      //初始化一个空链表  

	int i = n-1;                //x为链表数据域中的数据  
    while(i >= 0) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i--];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}  
```
</details>

## 24、已知L为一个单链表的头结点，设计算法将表中从i号结点到m号结点构成一个逆置的循环链表

**注意对题目的理解：**
题目中说将表中i号结点到m号结点构成一个逆置循环链表，那么有没有头结点呢？
没有特殊说明，默认它有，而且很多时候有头结点各种操作方便许多。

<details>
<summary>点击查看代码</summary>

```c
LinkList func24(LinkList L, int i, int m)
{
    LinkList re = (LinkList) malloc (sizeof(LNodes));
    re->next = re;

    if (NULL == L || L->next == L)
        return NULL;

    LNodes *p = L->next, *pre = L, *p_End;
    int cnt = 0;
    puts("开始寻找第i个结点……");
    while (NULL != p && cnt < i)
    {
        pre = pre->next;
        p = p->next;
        printf("%d\n",cnt);
        cnt++;
    }
    if (p == NULL)
        return NULL;
    
    puts("开始寻找第m个结点……");
    //cnt = 0;
    //p_End = p_Start;
    while (NULL != p && cnt <= m)
    {
        LNodes *tmp = p->next;
        pre->next = p->next;
        
        p->next = re->next;
        re->next = p;

        p = tmp;
        printf("%d\n",cnt);
        cnt++;
    }
    if (cnt-1 < m && NULL == p)
        return NULL;
    
    return re;
}
```
</details>

<details>
<summary>点击查看测试代码</summary>

```c
/*
* author:HRL
*
* date:10/03/2020
* 
* description:
* 24、已知L为一个单链表的头结点，设计算法将表中从i号结点到m号结点构成一个逆置的循环链表
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head01(ElemType *data,int n);

//单链表（带头结点）的建立1，头插法建立循环单链表
LinkList LinkListCreat_Head_C(ElemType *data,int n);

LinkList func24(LinkList L, int i, int m)
{
    LinkList re = (LinkList) malloc (sizeof(LNodes));
    re->next = re;

    if (NULL == L || L->next == L)
        return NULL;

    LNodes *p = L->next, *pre = L, *p_End;
    int cnt = 0;
    puts("开始寻找第i个结点……");
    while (NULL != p && cnt < i)
    {
        pre = pre->next;
        p = p->next;
        printf("%d\n",cnt);
        cnt++;
    }
    if (p == NULL)
        return NULL;
    
    puts("开始寻找第m个结点……");
    //cnt = 0;
    //p_End = p_Start;
    while (NULL != p && cnt <= m)
    {
        LNodes *tmp = p->next;
        pre->next = p->next;
        
        p->next = re->next;
        re->next = p;

        p = tmp;
        printf("%d\n",cnt);
        cnt++;
    }
    if (cnt-1 < m && NULL == p)
        return NULL;
    
    return re;
}

int main()
{
	int n, i, m;	
	ElemType *data;
	LinkList L = (LinkList) malloc (sizeof(LinkList));
	LNodes *p = NULL;

	puts("输入随机数的个数");
	scanf("%d",&n);

	data = CreatRand01(n,0);

	for (int j = 0;j < n;j++)
		printf("%d ",data[j]);
	puts("");

	L = LinkListCreat_Head01(data,n);
	p = L->next;
	puts("打印单链表各结点：");
	while (NULL != p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	puts("");

    puts("请输入提取的起始序号i：");
    scanf("%d",&i);
    puts("请输入提取结束的序号m：");
    scanf("%d",&m);

    LinkList re = func24(L, i, m);
    if (re == NULL)
        puts("处理失败！");
    else
    {
        puts("处理成功！");
        LNodes *pr = re;
        printf("re: %d\n",pr->data);
        pr = re->next;
        while (re != pr)
        {
            printf("%d ",pr->data);
		    pr = pr->next;
        }
        puts("");
    }
    
	
	return 0;
}
//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head01(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  

	int i = n-1;                //x为链表数据域中的数据  
    while(i >= 0) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i--];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}  

//单链表（带头结点）的建立1，头插法建立循环单链表  
LinkList LinkListCreat_Head_C(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = L;                      //初始化一个空链表  

	int i = n-1;                //x为链表数据域中的数据  
    while(i >= 0) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i--];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}  
```
</details>

## 25、已知L1和L2分别为两个循环单链表的头结点指针，m和n分别为L1和L2中数据结点的个数，设计时间复杂度最小的算法将两个链表合并成一个带头结点的循环单链表

<details>
<summary>点击查看代码</summary>

```c
LinkList func25(LinkList L1, int m, LinkList L2, int n)
{
    if (NULL == L1 || L1->next == L1)
        return NULL;
    if (NULL == L2 || L2->next == L2)
        return NULL;

    LNodes *p, *pre, *pMax, *pMin;
    if (m < n)
    {
        pMin = L1;
        pMax = L2;
    }
    else
    {
        pMin = L2;
        pMax = L1;
    }
    
    pre = pMin;
    p = pMin->next;
    while (pMin != p)
    {
        LNodes *tmp = p->next;
        pre->next = p->next;

        p->next = pMax->next;
        pMax->next = p;
        p = tmp;
    }
    
    free(pMin);
    return pMax;
}
```
</details>

<details>
<summary>点击查看测试代码</summary>

```c
/*
* author:HRL
*
* date:10/03/2020
* 
* description:
* 25、已知L1和L2分别为两个循环单链表的头结点指针，m和n分别为L1和L2中数据结点的个数，
设计时间复杂度最小的算法将两个链表合并成一个带头结点的循环单链表
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "CreatFunction.h"	//用于生成随机数组的头文件

#define MAX_SIZE 100
#define ElemType int

#define Status int
#define true 1
#define false 0

typedef struct LNodes
{
    ElemType data;
    struct LNodes *next;
} LNodes,*LinkList;

//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head01(ElemType *data,int n);

//单链表（带头结点）的建立1，头插法建立循环单链表
LinkList LinkListCreat_Head_C(ElemType *data,int n);

LinkList func25(LinkList L1, int m, LinkList L2, int n)
{
    if (NULL == L1 || L1->next == L1)
        return NULL;
    if (NULL == L2 || L2->next == L2)
        return NULL;

    LNodes *p, *pre, *pMax, *pMin;
    if (m < n)
    {
        pMin = L1;
        pMax = L2;
    }
    else
    {
        pMin = L2;
        pMax = L1;
    }
    
    pre = pMin;
    p = pMin->next;
    while (pMin != p)
    {
        LNodes *tmp = p->next;
        pre->next = p->next;

        p->next = pMax->next;
        pMax->next = p;
        p = tmp;
    }
    
    free(pMin);
    return pMax;
}

int main()
{
	int n, m;	
	ElemType *data1, *data2;
	LinkList L1 = (LinkList) malloc (sizeof(LinkList));
    LinkList L2 = (LinkList) malloc (sizeof(LinkList));
	LNodes *p1 = NULL, *p2 = NULL;

	puts("输入第一个循环链表的个数");
	scanf("%d",&m);
    puts("输入第二个循环链表的个数");
	scanf("%d",&n);

	data1 = CreatRand01(m,0);
    data2 = CreatRand01(n,0);

	L1 = LinkListCreat_Head_C(data1,m);
	p1 = L1->next;
	puts("打印第1个循环链表各结点：");
	while (L1 != p1)
	{
		printf("%d ",p1->data);
		p1 = p1->next;
	}
	puts("");

    L2 = LinkListCreat_Head_C(data2,n);
	p2 = L2->next;
	puts("打印第2个循环链表各结点：");
	while (L2 != p2)
	{
		printf("%d ",p2->data);
		p2 = p2->next;
	}
	puts("");

    LinkList re = func25(L1, m, L2, n);
    if (re == NULL)
        puts("处理失败！");
    else
    {
        puts("处理成功！");
        LNodes *pr = re;
        printf("re: %d\n",pr->data);
        pr = re->next;
        while (re != pr)
        {
            printf("%d ",pr->data);
		    pr = pr->next;
        }
        puts("");
    }
    
	
	return 0;
}
//单链表（带头结点）的建立1，头插法建立单链表  
LinkList LinkListCreat_Head01(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = NULL;                      //初始化一个空链表  

	int i = n-1;                //x为链表数据域中的数据  
    while(i >= 0) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i--];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}  

//单链表（带头结点）的建立1，头插法建立循环单链表  
LinkList LinkListCreat_Head_C(ElemType *data,int n) 
{  
    LNodes *L;  
    L = (LNodes *)malloc(sizeof(LNodes));   //申请头结点空间  
    L->next = L;                      //初始化一个空链表  

	int i = n-1;                //x为链表数据域中的数据  
    while(i >= 0) {  
        LNodes *p;  
        p = (LNodes *)malloc(sizeof(LNodes));   //申请新的结点   
        p->data = data[i--];                     //结点数据域赋值   
        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL   
        L->next = p;   
    }  
    return L;   
}  
```
</details>