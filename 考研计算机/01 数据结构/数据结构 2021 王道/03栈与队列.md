# 3.1 栈

**卡特兰数的应用**

## 顺序栈

### 顺序栈的数据类型定义

**结构体定义**

**模板类定义**

### 基本操作

**判断栈是否为空**

**入栈**

**出栈**

**清空栈中所有元素**

**销毁栈**

**判断栈是否为满**

```q.top == q.size;```

## 链栈

**结构体定义**

**模板类定义**

### 基本操作

**判断栈是否为空**

**入栈**

**出栈**

**清空栈中所有元素**

**销毁栈**

**判断栈是否为满**

# 3.2 队列

## 队列

### 队列的基本操作

**入队**

```q.elem[q.rear++] = x;```

**出队**

```q.elem[q.front++]=x;```

**注意**：

入队和出队都是指针加1，入队时尾指针加1，出队是头指针加1

**判满**

## 循环队列

### 基本操作

**判空**

**入队**

**出队**

**判满**

## 链队列

### 基本操作

**判空**

**入队**

**出队**

**判满**

## 双端队列（新题型）

**输入受限的双端队列**

**输出受限的双端队列**

# 3.3 栈与队列的应用

## 栈的应用

### 1、括号匹配

#### 基本思想

1. 初始设置一个空栈，顺序读入括号
2. 若是右括号，则和栈顶元素进行比较，如果是对应的括号，则把栈顶元素出栈
3. 若是左括号，则压栈
4. 结束时检查栈是否为空，为空则括号匹配，否则括号不匹配

#### 代码实现

```c++
int main()
{
	int num = 0,k;
	char a[10];
	char c,n;
	SqStack S;
	cout << "请输入括号表达式" << endl;
	
	//输入字符数组
	while (~scanf_s("%c",&c))
	{
		a[num] = c;
		num++;
	}

	//初始化一个栈
	InitStack_Sq(S, 4, 2);

	k = 0;
	while (k <= num)
	{
		switch (a[k])
		{
		case '(':
		case '[':
		case '{':
			Push(S, a[k]);
			break;
		case ')':
			if (S.elem[S.top - 1] == '(')
				Pop(S, n);
			break;
		case ']':
			if (S.elem[S.top - 1] == '[')
				Pop(S, n);
			break;
		case '}':
			if (S.elem[S.top - 1] == '{')
				Pop(S, n);
		default:
			break;
		}
		k++;
	}

	
	//OutStack(S);
	if (StackBlanks(S))
	{
		cout << "括号匹配" << endl;
	}
	else
	{
		cout << "括号不匹配" << endl;
	}

	return 0;
}
```

### 2、表达式求值

由于人们习惯的是中缀表达式，而计算机方便计算的则是后缀表达式

**后缀表达式**与**表达原表达式的的二元树**有异曲同工之妙

#### 中缀表达式转化为后缀表达式

首先我们设操作符的**栈外优先级**为icp，**栈内优先级**为isp

#### 算法思想
从左到右开始扫描中缀表达式

* 遇到数字就加入后缀表达式
* 遇到运算符时
* * 若为“(”，入栈
* * 若为“)”，则一次把栈中的运算符加入后缀表达式，直到出现”(“，从栈中删除”(”
* * 若为除括号外的其他运算符，当其优先级高于除‘（’外的栈顶运算符式，直接入栈
* * * 否则从栈顶开始，依次弹出比当前处理的运算符优先级等级高的和优先级相等的运算符，直到一个比它优先级低的或遇到一个左括号为止
* 当扫描额度中缀表达式结束时，栈中所有运算符依次出栈加入后缀表达式



设“#”为输入的结束符

则对于中缀表达式 a+b-a*((c+d)/e-f)+g

|  操作符  | #   | (   | *,/   | +,-   | )   |
| --- | --- | --- | --- | --- | --- |
|  isp  |  0  | 1   |5    | 3   | 6   |
|  icp |  0  |  6  |   4 |   2 |  1  |

输入的字符序列是：a+b-a*((c+d)/e-f)+g#

从右到左开始进栈：

#### 后缀表达式的计算

1. 顺序扫描表达式的每一项，然后根据它的类型做相应操作：
2. 操作数：压栈；
3. 操作符：则连续从栈中连续退出两个操作数，进行计算，并将结果压入栈中

最后栈里只剩一个栈顶元素就是表达式的值

### 3、递归的实现

递归算法要转换为非递归算法一般要借助栈来实现

典型例子：斐波那契数列的求解

#### 递归要满足的条件：

1. 递归表达式
2. 边界条件（递归的出口）

#### 递归的缺点

1. 递归次数过多容易栈溢出
2. 效率不高

效率不高的原因是：递归过程中进行了大量的重复计算

**递归的具体实现参考《编译原理》中的相应内容**

## 队列的应用

### 1、层次遍历

例如：二叉树的层次遍历

算法简单描述：
1. 根结点入队
2. 若队空，结束遍历；否则重复3操作
3. 队列中第一个结点出队，并访问。若其有左孩子则将其左孩子入队；若其有右孩子，则将右孩子入队，返回2

### 2、计算机系统中的应用

#### 2.1 解决主机与外部设备之间速度不匹配的问题

例如：主机与打印机的速度不匹配

解决办法：
设置一个数据缓冲区（队列）

#### 2.2 解决有多用户引起的资源竞争问题

例如：CPU资源的竞争