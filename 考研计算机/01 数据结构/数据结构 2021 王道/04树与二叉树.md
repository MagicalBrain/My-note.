# 4.1 树的基本概念

## 树的定义

## 基本术语

**祖先结点**

**子孙结点**

**双亲结点**

**孩子结点**

**结点的度**

**树的度**

**分支结点**

**叶子结点**

**结点的深度**

**结点的高度**

**树的高度**

**有序树**

**无序数**

**（两个结点之间的）路径**

**路径长度**

**森林**

## 树的性质

1. 树中的结点数等于所有结点的度数+1
2. 度为m的树中，第i层上之多有$m^{i-1}$个结点$(i \geqslant 1)$
3. 高度为h的结点m 叉树至多有$\frac{(m^h-1)}{m-1}$个结点
4. 具有n个结点的m叉树的最小高度为$$\lceil \log_m (n(m-1)+1) \rceil$$

# 4.2 二叉树的概念

参考原文链接：https://blog.csdn.net/qq_26399665/article/details/54565849

## 二叉树的定义及其主要特性

### 特殊的二叉树

**满二叉树（FullBinaryTree）**

一棵深度为k且有2k-1个结点的二又树称为满二叉树。
    　满二叉树的特点：
　　（1） 每一层上的结点数都达到最大值。即对给定的高度，它是具有最多结点数的二叉树。
　　（2） 满二叉树中不存在度数为1的结点，每个分支结点均有两棵高度相同的子树，且树叶都在最下一层上。

**完全二叉树（Complete BinaryTree）**

若一棵二叉树至多只有最下面的两层上结点的度数可以小于2，并且最下一层上的结点都集中在该层最左边的若干位置上，则此二叉树称为完全二叉树。
  **特点**：

1. 满二叉树是完全二叉树，完全二叉树不一定是满二叉树。
2. 在满二叉树的最下一层上，从最右边开始连续删去若干结点后得到的二叉树仍然是一棵完全二叉树。
3. 在完全二叉树中，若某个结点没有左孩子，则它一定没有右孩子，即该结点必是叶结点。 

**二叉排序树**

**平衡二叉树**

### 二叉树的性质

#### 性质一
第$i$层结点数最多 $2^{i-1}$ 个

**证明**：

#### 性质二
深度为k的二叉树最多有$2^{k-1}$个节点

**证明**：

由性质一可得：$$\sum_{i=1}^{k} 2^{i-1} = 2^0 + 2^1 + 2^2 + \dots +2^{k - 1}$$
$$= 1 + 2 + 2^2 + \dots + 2^{k-1}$$
由等比数列求和公式可得：
$$= 1 + \frac{2 - 2^{k-1} \times 2}{1 - 2}$$
$$= 2^k - 1$$

#### 性质三
对任一二叉树，设其叶子节点数为 $n_0$ ,度数为2的结点数为 $n_2$，则 $n_0 = n_2 + 1$

证明：
设度数为1的结点数为 $n_1$ ,所有的结点数为 $n$
得：$$ n = n_0 + n_1 + n_2$$
因为除了根节点外都有分支，且分支均是由度数为1和2的结点产生的，故：
$$n = B + 1 $$

**因为：**
每个节点如果有双亲则对应一个分支，而根结点没有双亲。

$$B = n_1 + 2 \times n_2$$
得：
$$n_0 = n_2 + 1$$

#### 性质四

对**完全二叉树**从上到下、从左到右依次编号，则有：

1. （孩子找双亲）
2. （双亲找孩子）
3. 结点所在的层次（深度）

这个比较容易想，但是在关于完全二叉树的编程中比较常用

#### 性质五

具有n个结点的完全二叉树的高度为$\lceil \log_2(n+1) \rceil$或$\lfloor \log_2(n)\rfloor + 1$

## 二叉树的存储结构

### 顺序存储

适合**满二叉树**和**完全二叉树**

### 链式存储

**重要结论**：
在含有$n$个结点的二叉链表中，含有$n+1$个空链域

#  4.3 二叉树的遍历和线索二叉树

## 二叉树的遍历

遍历的“序”只是访问根的顺序，左右子结点的访问顺序都是先左再右

### 先序遍历

#### 递归实现

#### 非递归实现

借助栈

**基本思路**：

1. 将指针指向根结点，访问，若右子结点非空则入栈；
2. 将指针移到左子结点，重复1的操作，直到左子结点为空，出栈
3. 将指针移到出栈的结点重复1、2的操作；
4. 直到栈空结束

### 中序遍历

#### 递归实现

#### 非递归实现

**基本思路**：
1. 将指针指向根结点，扫描其左子结点，将左子结点入栈知直到左子结点为空
2. 出栈并访问结点，扫描右子结点若右子结点为空则出栈；否则重复1的操作；
3. 直到栈空结束

### 后序遍历

#### 递归实现

**基本思路**：

先递归访问左子，再递归访问右子，最后访问根节点

```c++
void PostOrder(BiTree T)
{
	if (T)
	{
		PostOrder(T->lchild);
		PostOrder(T->rchild);
		printf("%c",T->data);
	}
}
```

#### 非递归实现

**基本思路**：

用堆栈来实现非递归的后序遍历的关键在于当访问到叶子结点时，要把根节点出栈继续访问，但由于出栈的时候是可能是访问到左子也可能是访问到右子，所以要分清楚是左子还是右子。

其实这个问题的本质是：如何避免重复访问右子，导致遍历不下去。

常用的办法有两种：

1. 标记位法：每个节点设置一个标记tag，0为是左子返回的（右子未访问），1则是从右子返回的（右子被已访问）
2. 最近访问比较法：设置一个变量存储最近一次访问的结点，如果返回根节点后其右子等于最近访问过的结点，则右子已被访问过，反之则没有。

1. 先访问左子，一路向左
2. 把右子和根节点依序压栈
3. 当遍历到结点为空是，出栈一个结点，并判断其右子有没有被访问过（使用上述方法）
4. 若右子未被访问，则指针转向右子，否则访问该节点，然后再出栈一个元素

```c++
bool PostOrder(BiTree T)
{
	if (T == NULL)
		return false;

	BiTree s[100];
	int  top = 0, front = 0, rear = 0;
	BiTree r = NULL;
	while (T || top > 0)
	{
		if (T)
		{
			s[top++] = T;
			T = T->lchild;
		}
		else
		{
			T = s[top-1];			
			if (T->rchild && T->rchild != r)
			{
				T = T->rchild;
			}
			else
			{
				T = s[--top];
				cout << T->data << ",";
				r = T;
				T = NULL;//不重置为NULL的话会出不了栈，造成死循环
			}
		}
	}
	cout << endl;
	return true;
}
```

### 层次遍历

借助于队列

**基本思路**：
1. 先让根节点入队
2. 然后循环出队一个结点并访问，然后把该节点的左右子节点入队
3. 队空结束循环

```c++{class=line-numbers}
bool TBLevelorder(BiTree BT)
/*
* 正常的层次遍历，即从上往下，自左向右
* 得利用队列
*/
{
	queue q,*q0;
	InitQueue(q,10);
	q0 = &q;

	BiTree p;
	EnQueue(q0,BT);
	while (!isEmpty(q))
	{
		DeQueue(q, p);
		Visit(p->data);
		if (p->lchild != NULL)
		{
			EnQueue(q0, p->lchild);
		}
		if (p->rchild != NULL)
		{
			EnQueue(q0, p->rchild);
		}
	}
	return true;
}
```

#### 层次遍历的应用

##### 计算二叉树高度的非递归实现

**基本思路**：


```c++{class=line-numbers}
int func05(BiTree BT)
{
	BiTree q[100];
	int front = -1, rear =0;
	int level = 0, last = 0;

	BiTree p = BT;
	q[rear++] = p;
	while (front<rear-1)
	{
		p = q[++front];;
		//Visit(p->data);
		//e.ptr = p;
		//Push(S, e);
		if (p->lchild != NULL)
		{
			q[rear++] = p->lchild;
		}
		if (p->rchild != NULL)
		{
			q[rear++] = p->rchild;
		}
		if (front == last)
		{
			level++;
			last = rear-1;
		}
	}
	return level;
}
```

##### 计算某层的结点个数

```c++
int func0501(BiTree BT,int n)
//返回第i层的结点个数
{
	if (!BT)
		return 0;

	int num = 0;

	BiTree q[100];
	int front = -1, rear = 0;
	int level = 0, last = 0;

	BiTree p = BT;
	q[rear++] = p;
	while (front < rear - 1)
	{
		p = q[++front];
		num++;
		if (p->lchild != NULL)
		{
			q[rear++] = p->lchild;
		}
		if (p->rchild != NULL)
		{
			q[rear++] = p->rchild;
		}
		if (front == last)
		{	
			level++;
			if (level == n)
			{
				return num;
			}
			num = 0;
			last = rear - 1;
		}
	}
	return -1;
}
```

如果要计算每层结点的个数同理

##### 计算树的最大宽度

其实就是把每层结点数比较出一个最大值出来即可。

## 由遍历序列构造一棵树

二叉树的遍历有：
1. 先序遍历
2. 中序遍历
3. 后序遍历
4. 层次遍历

但只有先序遍历和后序遍历的组合是无法确定一棵二叉树的
**确定一棵树的序列中必须包括中序遍历序列**
**确定一棵二叉树的序列必须要有中序序列的原因**：
？

### 先序遍历和中序遍历确定一棵二叉树

###  后序遍历和中序遍历确定一棵二叉树

### 层次遍历（层序序列）和中序遍历确定一棵二叉树

## 线索二叉树

**引入目的**：
利用二叉链表大量的空指针来指向其在序列中的前驱和后继，以加快查找结点的前驱和后继结点的速度

### 存储结构描述

```c++
#define ElemType int

typedef struct ThreadNode
{
	ElemType data;
	struct ThreadNode* lchild, * rchild;
	int ltag, rtag;
}ThreadNode,*ThreadTree;
```

### 线索二叉树的构造

**中序遍历算法**：

```c++
void InThread(ThreadTree &p,ThreadTree &pre)
/*中序遍历对二叉树线索化的递归算法*/
{
	if (p == NULL)
	{
		InThread(p->lchild, pre);
		if (p->lchild == NULL)
		{
			p->lchild = pre;
			p->ltag = 1;
		}
		if (pre != NULL && pre->lchild == NULL)
		{
			p->rchild = pre;
			p->rtag = 1;
		}
		pre = p;
		InThread(p->rchild, pre);
	}
}
```

**利用中序遍历建立线索二叉树**：

```c++
void CreateInThread(ThreadTree& T)
/*利用中序遍历建立线索二叉树*/
{
	ThreadTree pre = NULL;
	if (T != NULL)
		//非空才进行线索化
	{
		InThread(T, pre);	//	递归线索化
		pre->rchild = NULL;	//处理遍历的最后一结点
		pre->rtag = 1;
	}
}
```

### 不借助栈的二叉树的非递归遍历

线索二叉树可以实现不借助栈的非递归遍历

# 4.4 树与森林

## 树的存储结构

## 数、二叉树、森林的转换

“左子孩子，右子兄弟”

## 树和森林的遍历

## 并查集（树的应用）

### 并查集的操作（3种）

```c++

```

通常用树的双亲表示法作为存储结构

# 4.5 树与二叉树的应用

## 二叉排序树

### 二叉排序树的定义

二叉排序树（BST），又称二叉查找树

具有以下性质：

1. 若左子树非空，则左子树所有结点的关键字均小于根节点的关键字的键值
2. 若右子树非空，则右子树上所有节点的关键字均大于根节点的键值
3. 左右子树本身也是一棵二叉排序树

### 二叉排序树的查找

#### 递归实现

#### 非递归实现

### 二叉排序树的插入

### 二叉排序树的构造

### 二叉排序树的删除

### 二叉排序树的查找效率分析

## 平衡二叉树

### 平衡二叉树的定义

### 平衡二叉树的性质

#### 1、构成高度为h的平衡二叉树的最少结点数：

$$n_0=0,n_1=1,n_2=2,n_3=1+1+2=4,\cdots,n_h=1+n_{h-1}+n_{h-2}$$

### 平衡二叉树的插入

共有四种情况

#### LL旋转（右单旋转）

当根节点的左子树上插入左子树

且平衡因子从1变为2

#### RR旋转（左单旋转）

当根节点的右子树上插入右子树

且平衡因子从-1变为-2

#### LR旋转（先左后右双旋）

当根节点的左子树上插入右子树

且平衡因子从1变为2

#### RL旋转（先右后左双旋）

当根节点的右子树上插入左子树

且平衡因子从-1变为-2

### 平衡二叉树的查找

## 哈夫曼树与哈弗曼编码

**带权路径长度（WPL）**：

$$WPL=\sum\limits^n_{i=1} w_il_i$$



### 哈夫曼的定义

带权路径长度最小的二叉树即哈夫曼树，又称最优二叉树

