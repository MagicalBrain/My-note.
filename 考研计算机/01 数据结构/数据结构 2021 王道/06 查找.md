# 6.1 查找的基本概念

**查找表**

**查找表的操作**：
1. 查询某个元素是否在表中
2. 检索满足条件的某个元素
3. 在查找表中插入一个元素
4. 从表中删除一个元素

**静态查找表**：
只包含上面的1、2操作

**动态查找表**：
包含了上面的3、4操作

**平均查找长度**：

# 6.2 折半查找与顺序查找


算法如:

```c
 int Binary Search(SeqList L, ElemType key)
/*在有序表L中查找关键字为key的元素,若存在则返回其位置,不存在则返回-1*/
 {
    int low=0, high=L.TableLen-1, mid; 
    while(low<=high)
    {
        mid=(low+high)/2;
        //取中间位置
        if(L.elem[mid]==key)
            return mid;
        //查找成功则返回所在位置
         else if (L.elem[mid]>key)
            high=mid-1;
        //从前半部分继续查找
        else
            low=mid+1;
        //从后半部分继续查找
        }
 return -1;
 }
```

#  6.3 B树与B+树

**（842不考）**可跳过

# 6.4 散列表（哈希表）



# 6.5 串

## 串的定义

## 串的存储结构

### 1、定长顺序存储

长度是事先定下来的

### 2、堆分配存储

长度是动态的可以改变的，是通过动态分配来分配空间的

### 3、块链表示 

## 串的基本操作

**最小操作子集**：
1. 串赋值
2. 串比较
3. 求串长
4. 串链接
5. 求子串

## 串的模式匹配

**串的模式匹配**：
即子串（“模式串”）的定位操作

### 简单模式匹配

**two-pointers**

**时间复杂度**：
（最坏）$O(n m)$
n为主串长度，m为子串长度

## KMP算法（改进的模式匹配）

### 子串的基本概念

**前缀**：
除最后一个字符外的所有头部字符子串（**注意**：前缀、后缀是一个**集合**！）

**后缀**：
除第一个字符外的所有尾部子串

**部分匹配值**：
前后缀最长相等长度
或
最长相等前后缀长度

### 求next数组的办法

例：“ababaaababaa”


|  a  | b   | a   | b   | a   |  a  |  a  | b   | a   | b   | a   | a   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 1   |  1  | 2   |  3  |   4 |   2 | 2   |  3  |  4  |  5  |  6  |
| -1   |  0  | 0   |  1  | 2   | 3   | 1   | 1   |  2  | 3   | 4   | 5   |

(**详情看《王道》P283**)

第一个和第二个是初始值，分别为0，1（数组下标从1开始时的，如果数组下标从0开始，则是-1，0）

从第三个开始真正开始计算