# 计算机图形学 直线画图算法

## DDA算法（数值微分法）

```c++
void LineDDA(int x1, int y1, int x2,int y2,int color)
{
    int dm = 0 ;
    if (abs(x2 - x1) >= abs(y2 - y1))
        dm = abs(x2 - x1);
    else
        dm = abs(y2 - y1);

    float dx = (float) (x2 - x1) / dm;
    float dy = (float) (y2 - y1) / dm;
    float x = x1 + 0.5;
    float y = y1 + 0.5;

    for (int i = 0;i < dm;i++)
    {
        setpixel((int)x,(int)y,color);
        x += dx;
        y += dy;
    }
}
```

### 新版本的OpenGL实现
```c++
int dm = 0;
	if (abs(x2 - x1) >= abs(y2 - y1))
		dm = abs(x2 - x1);
	else
		dm = abs(y2 - y1);

	float dx = (float)(x2 - x1) / dm;
	float dy = (float)(y2 - y1) / dm;
	float x = x1 + 0.5;
	float y = y1 + 0.5;

	for (int i = 0; i < dm; i++)
	{
		glVertex2i((int)x, (int)y);
		x += dx;
		y += dy;
	}
```

### 输出结果

![image_1ctuks5hf1if818kd17h1qqjgcp9.png-6.9kB][1]

## 逐点比较法

### 书本代码
```c++
void PrintLine(int x1, int y1, int x2, int y2, int color)
{
   int x, y, xA, yA;
	if (y1>y2)	//平移直线的坐标，使y值较小的点位于坐标原点
	{
		yA = y1 - y2; 
		xA = x1 - x2;
	}
	else
	{
		yA = y2 - y1; 
		xA = x2 - x1;
	}
	int F = x = y = 0;
	int n = abs(xA) + abs(yA);
	for (int i = 0; i<n; i++) {
		if (xA>0) {	
			//如果斜率为正
			if (F >= 0) 
			{ 
				x++; 
				F -= yA; 
			}
			else { 
				y++; 
				F += xA; 
			}
		}
		else {//如果斜率为负
			if (F >= 0) {
				y++;
				F += xA; }
			else { 
				x--;
				F += yA; }
		}
if (y1>y2)
        setpixel(x+x2, y+y2, color); 
else 
        setpixel(x+x1, y+y1, color); 
}
```
--------------------- 
作者：步行者08 
来源：CSDN 
原文：https://blog.csdn.net/wpxu08/article/details/82962444 
版权声明：本文为博主原创文章，转载请附上博文链接！


```c++
void PrintLine(int x1, int y1, int x2, int y2, int color)
//逐点比较法
{
	int x, y, xA, yA;
	if (y1 > y2)
	{
		yA = y1 - y2;
		xA = x1 - x2;
	}
	else
	{
		yA = y2 - y1;
		xA = x2 - x1;
	}
	int F = x = y = 0;
	int n = abs(xA) + abs(yA);

	for (int i = 0; i < n; i++)
	{
		if (xA > 0)
		{
			if (F >= 0)
			{
				x++;
				F -= yA;
			}
			else
			{
				y++;
				F += xA;
			}
		}
		else
		{
			if (F >= 0)
			{
				y++;
				F += xA;
			}
			else
			{
				x--;
				F += yA;
			}
		}

		if (y1 > y2)
		{
			glVertex2i(x + x2, y + y2);
		}
		else
			glVertex2i(x + x1, y + y1);
	}
}
```

### 输出结果

![image_1ctukvbb11lk21n6a171s37ksukm.png-6.8kB][2]

##  Bresenham画线法

### 基本思想


```c++
void swap_value (int* a, int* b)
{
    int temp=*a; 
    *a=*b;
    *b=temp;
}
void Bres_Line(int x1, int y1, int x2, int y2, int color)
{
    setpixel(x1,y1, color);
    int dx=abs(x2-x1);
    int dy=abs(y2-y1);
    if (dx==0&&dy==0)
        return; 
    int flag=0;
    if (dx<dy)         	//下面将斜率变换至0≤|k|≤1区间
    {
        flag=1;
        swap_value(&x1, &y1);
        swap_value(&x2, &y2);
        swap_value(&dx, &dy);
    }
    int tx=(x2-x1)>0 ? 1:-1;
    int ty=(y2-y1)>0 ? 1: -1;
    int curx=x1;
    int cury=y1;
    int dS=2*dy;
    int dT=2*(dy-dx);
    int d=dS-dx; 
    while (curx!=x2)
    {
        if (d<0) 
            d+=dS;
        else
        {cury+=ty;  d+=dT; }

        if (flag)
            setpixel(cury, curx, color);  
        else 
            setpixel(curx, cury, color);
        curx+=tx;
    }
}
```

--------------------- 
作者：步行者08 
来源：CSDN 
原文：https://blog.csdn.net/wpxu08/article/details/82962444 
版权声明：本文为博主原创文章，转载请附上博文链接！

### 输出结果

![image_1ctul2m1enfm1g461feq1aohms92j.png-7.2kB][3]

## 中点画线法
```c++
void MidPLine(int x0, int y0, int x1, int y1, int color)
{
    int a, b,  d, x, y,tag=0;
    if(abs(x1-x0)<abs(y1-y0))	//若斜率的绝对值大于1，将坐标和坐标互换
    {  
        swap(&x0,&y0);  
        swap(&x1,&y1);
        tag=1;
    }
    if(x0>x1)//保证x0<x1
    {   
        swap(&x0,&x1);
        swap(&y0,&y1);
    }
    a=y0-y1;    
    b=x1-x0; 
    d=a+b/2;    
    if(y0<y1)//斜率为正
    {
        x=x0; y=y0;
        setPixel(x, y, 255);
        while (x<x1)
        {    
            if (d<0)       
                {x++; y++; d=d+a+b; }
            else       
                {x++; d+=a;}
            if(tag)//斜率大于1
                setPixel(y, x, color);	//互换
            else
                setPixel(x, y, color);
        }  /* while */
    }
    else//斜率为负(y0>=y1)
    {	
        x=x1;
        y=y1;
        setPixel(x, y, 255);
        while (x>x0)
        {  
            if (d<0)       
                {x--; y++; d=d-a+b; }
            else       
                {x--; d-=a;}
            if(tag)//斜率大于1
                setPixel(y, x, color);	//互换
            else
                setPixel(x, y, color);
        }  /* while */
    }
}
```

### 输出结果

![image_1ctulbrpf1pm1lgmg7g17me1q6e30.png-7kB][4]


  [1]: http://static.zybuluo.com/Arbalest-Laevatain/9pvucr5ktakh6e5tp0gxa22v/image_1ctuks5hf1if818kd17h1qqjgcp9.png
  [2]: http://static.zybuluo.com/Arbalest-Laevatain/b9xcv29ark658fsiggsfr4kh/image_1ctukvbb11lk21n6a171s37ksukm.png
  [3]: http://static.zybuluo.com/Arbalest-Laevatain/j3fxk94o6tvszotnbyoqqp4l/image_1ctul2m1enfm1g461feq1aohms92j.png
  [4]: http://static.zybuluo.com/Arbalest-Laevatain/pjnhh1rdjyzxbbzjjqpebqfe/image_1ctulbrpf1pm1lgmg7g17me1q6e30.png