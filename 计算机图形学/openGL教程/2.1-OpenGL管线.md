# 2.1-OpenGL管线

首先OpenGL图形管线：
1. 编写GLSL程序
2. 将GLSL程序导入到GPU

## 编写GLSL程序

## 将GLSL程序导入的GPU

1. 首先使用C++获取GLSL着色器代码，既可以从文件中读取，也可以硬编码在字符串中。
2. 接下来创建OpenGL着色器对象并将GLSL着色器代码加载进着色器对象。
3. 最后，用OpenGL命令编译并连接着色器对象，并将它们安装进GPU。

## 第一个OpenGL C++程序

GLFW库包含了GLFWwindow类，我们可以在其上进行3D场景绘制。
第一个OpenGL程序要创建一个GLFWwindows实例并为其设置背景色。

## 顶点着色器和片段着色器

即vertex shader和 fragment shader。

## 曲面细分着色器

## 几何着色器

## 光栅化

我们的设备整个2D屏幕由光栅——**矩形像素阵列**组成。

故要显示3D的物体需要进行光栅化

## 片段着色器

## 像素操作

绘制场景中的物体时，我们通常期望前面的物体挡住后面的物体。这也可以推广到物体自身，我们通常期望看到物体的正面对着我们，而不是背对我们。
为了实现这个效果，我们需要**隐藏面消除（Hidden Surface Removal，HSR）**

### OpenGL是如何完成隐藏面消除的？

OpenGL通过精巧地协调两个缓冲区完成隐藏面消除：

1. 颜色缓冲区（我们之前讨论过）
2. 深度缓冲区（也叫作Z缓冲、Z-buffer）。 

这两个缓冲区都和光栅的大小相同——即对于屏幕上每个像素，在两个缓冲区都各有一个对应条目。

当绘制场景中的各种对象时，片段着色器会生成像素颜色。像素颜色会存放在颜色缓冲区中——颜色缓冲区最终会被写入屏幕。
当多个对象占据颜色缓冲区中的相同像素时，必须根据哪个对象最接近观察者来确定保留哪个像素颜色。

隐藏面消除按照如下步骤完成。

1. 在每个场景渲染前，深度缓冲区全部初始化为表示最大深度的值。
2. 当像素颜色由片段着色器输出时，计算它到观察者的距离。
3. 如果距离小于深度缓冲区存储的值（对当前像素），那么用当前像素颜色替换颜色缓冲区中的颜色，同时用当前距离替换深度缓冲区中的值，否则抛弃当前像素。

这个过程叫作Z-Buffer算法，如图2.14所示。


