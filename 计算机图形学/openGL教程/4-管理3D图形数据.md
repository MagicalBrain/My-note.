# 4-管理3D图形数据

使用OpenGL渲染3D图形通常需要将若干数据集发送给OpenGL着色器管线。
举个例子，想要绘制一个简单的3D对象，比如一个立方体，你至少需要发送以下项目。

1. 立方体模型的顶点。
2. 控制立方体在3D空间中朝向表现的变换矩阵。

把数据发送给OpenGL着色器管线有两种方式：
1. 通过顶点属性的缓冲区
2. 直接发送给统一变量

理解这两种方式具体的工作原理十分重要，这样我们才可以为每个要发送的项目选取适合的方法。

## 4.1 缓冲区和顶点属性

想要绘制一个对象，它的顶点数据需要被发送给顶点着色器。
通常会把顶点数据在C++端放入一个缓冲区，并把这个缓冲区和着色器中声明的顶点属性相关联。
要完成这件事，有好几个步骤，有些步骤只需要做一次，而如果是动画场景的话，有些步骤需要每帧都做一次。

只做一次的步骤：

**我们一般把这些步骤都放在init()函数里执行**

1. 创建一个缓存区
2. 将顶点数据复制到缓冲区

每帧都要做的步骤：

**我们一般把这些步骤都放在display()函数里执行**

1. 启用包含顶点数据的缓冲区
2. 将这个缓冲区和一个顶点属性相关联
3. 启用这个顶点属性
4. 使用`glDrawArrays()`绘制对象

**VBO**
顶点缓冲对象（Vertex Buffer Object，VBO）中，VBO在C++/OpenGL应用程序中被声明和实例化。一个场景可能需要很多VBO，所以常常会在init()中生成并填充若干个VBO，这样在你的程序需要绘制一个或多个VBO的时候就可以直接使用。

**VAO**
顶点数组对象（Vertex Array Object，VAO）。OpenGL的3.0版本引入了VAO，作为一种组织缓冲区的方法，让缓冲区在复杂场景中更容易操控。OpenGL要求至少创建一个VAO，对我们现在来说一个就够了。

**注意**
VAO其实就是用来管理VBO的，一个显示对象对应一个VBO，而VAO可以存储多个VBO。

```cpp
GLuint vao[1];     // OpenGL 要求这些数值以数组的形式指定
GLuint vbo[2];     
//
glGenVertexArrays(1, vao);  // 创建VAO
glBindVertexArray(vao[0]);  // 将生成的缓冲区与创建的VAO绑定，并将VAO标记为“活跃”的
glGenBuffers(2, vbo);   // 创建VBO
```

## 4.5 我们的第一个3D程序——立方体

@import "./code/Chapter_04_pipeline/Prog4_1_1_plainRedCube/main.cpp"

## 4.6 渲染一个对象的多个副本

只需要修改`void display()`函数就行了：

```cpp
void display(GLFWwindow* window, double currentTime) {
	glClear(GL_DEPTH_BUFFER_BIT);
	glClearColor(0.0, 0.0, 0.0, 1.0);
	glClear(GL_COLOR_BUFFER_BIT);

	glUseProgram(renderingProgram);

	mvLoc = glGetUniformLocation(renderingProgram, "mv_matrix");
	projLoc = glGetUniformLocation(renderingProgram, "proj_matrix");

	vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));

	glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));

	for (displayLoopi = 0; displayLoopi<24; displayLoopi++) {
		tf = currentTime + displayLoopi;
		tMat = glm::translate(glm::mat4(1.0f), glm::vec3(sin(.35f*tf)*8.0f, cos(.52f*tf)*8.0f, sin(.70f*tf)*8.0f));
		rMat = glm::rotate(glm::mat4(1.0f), 1.75f*tf, glm::vec3(0.0f, 1.0f, 0.0f));
		rMat = glm::rotate(rMat, 1.75f*tf, glm::vec3(1.0f, 0.0f, 0.0f));
		rMat = glm::rotate(rMat, 1.75f*tf, glm::vec3(0.0f, 0.0f, 1.0f));
		mMat = tMat * rMat;
		mvMat = vMat * mMat;

		glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));

		glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
		glVertexAttribPointer(0, 3, GL_FLOAT, false, 0, 0);
		glEnableVertexAttribArray(0);

		glEnable(GL_DEPTH_TEST);
		glDepthFunc(GL_LEQUAL);

		glDrawArrays(GL_TRIANGLES, 0, 36);
	}
}
```

显然这样单纯地将display代码加入到循环里是不太方便的。

这时我们就可以引入**实例化**的机制

### 实例化

**实例化（Instancing）**提供了一种机制，可以只用一个C++/OpenGL调用就告诉显卡渲染一个对象的多个副本。这可以带来显著的性能好处，特别是当有数千甚至数百万的对象被绘制时——例如渲染在场地中的许多花朵的时候。

说白了就是，如果有多个对象需要被渲染的时候就需要用到实例化这个机制。

为了使用实例化来重复我们以前的翻滚立方体示例，我们需要将构建不同模型矩阵的计算（先前在display()中的循环内实现）移动到顶点着色器中。
由于GLSL不提供平移或旋转函数，并且我们无法从着色器内部调用GLM，因此我们需要使用程序3.1中的工具函数。
我们还需要将C++/OpenGL应用程序中的“时间因子”通过统一变量传递给顶点着色器。
我们还需要将模型和视图矩阵传递到单独的统一变量中，因为对每个立方体的模型矩阵都需要进行旋转计算。我们对代码的修改，包括C++/OpenGL应用程序中的修改以及新的顶点着色器中的修改，如程序4.2所示。

着色器代码：

顶点着色器代码
```cpp
#version 430

layout(location = 0) in vec3 position;

// 分开定义模型和视图矩阵
//uniform mat4 m_matrix;
uniform mat4 v_matrix;

uniform mat4 proj_matrix;

// 用于动画和放置立方体的时间因子
uniform float tf;	

out vec4 varyingColor;

// 矩阵变换工具函数的声明
// GLSL函数要求先声明后调用
// 我个人习惯直接把函数定义写在main函数前面
 
// 构建并返回绕X轴的旋转矩阵
mat4 buildRotateX(float rad) {
    mat4 xrot = mat4(
        1.0, 0.0, 0.0, 0.0,
        0.0, cos(rad), -sin(rad), 0.0,
        0.0, sin(rad), cos(rad), 0.0,
        0.0, 0.0, 0.0, 1.0
    );
    return xrot;
}

// 构建并返回绕Y轴的旋转矩阵
mat4 buildRotateY(float rad) {
    mat4 yrot = mat4(
        cos(rad), 0.0, sin(rad), 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sin(rad), 0.0, cos(rad), 0.0,
        0.0, 0.0, 0.0, 1.0);
    return yrot;
}

// 构建并返回绕Z轴的旋转矩阵
mat4 buildRotateZ(float rad) {
    mat4 zrot = mat4(
        cos(rad), -sin(rad), 0.0, 0.0,
        sin(rad), cos(rad), 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0);
    return zrot;

}

mat4 buildTranslate(float x, float y, float z)
{
	mat4 trans = mat4(
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		x,	 y,	  z,   1.0
	);

	return trans;
}

void main(void)
{
	gl_Position = proj_matrix * mv_matrix * vec4(position, 1.0);
	varyingColor = vec4(position, 1.0) * 0.5 + vec4(0.5, 0.5, 0.5, 0.5);
}

```

OpenGL代码：

```cpp
// 构建和变换Mat的计算被移到顶点着色器里去了
// 在C++程序里不再需要构建MV矩阵

```

## 习题

### 4.1 （项目）修改程序4.1以使用你自己设计的其他简单3D形状替换立方体。请务必在glDrawArrays()命令中正确指定顶点数。

### 4.2 （项目）在程序4.1中，在display()函数中“view”矩阵被简单地定义为摄像机位置的负数：
vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));
将此代码替换为图3.13所示的计算实现。这将允许你通过指定摄像机位置和3个朝向轴来定位摄像机。你将发现有必要存储3.7节中描述的向量U、V、N。然后，尝试不同的摄像机视点，并观察渲染立方体的最终外观。

### 4.3 （项目）修改程序4.4以包含第二个“行星”，使用练习4.1中你自定义的3D形状。确保你的新“行星”处于与现有行星不同的轨道上，这样它们就不会发生碰撞。

### 4.4 （项目）修改程序4.4，使用“查看”函数构建“视图”矩阵（如第3.9节所述）。然后尝试将“查看”参数设置到不同的位置，例如查看太阳（在这种情况下场景应该看起来正常），查看行星或查看月球。

### 4.5 （研究）提出glCullFace(GL_FRONT_AND_BACK)的实际用途。
