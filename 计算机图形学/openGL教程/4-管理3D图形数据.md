# 4-管理3D图形数据

使用OpenGL渲染3D图形通常需要将若干数据集发送给OpenGL着色器管线。
举个例子，想要绘制一个简单的3D对象，比如一个立方体，你至少需要发送以下项目。

1. 立方体模型的顶点。
2. 控制立方体在3D空间中朝向表现的变换矩阵。

把数据发送给OpenGL着色器管线有两种方式：
1. 通过顶点属性的缓冲区
2. 直接发送给统一变量

理解这两种方式具体的工作原理十分重要，这样我们才可以为每个要发送的项目选取适合的方法。

## 4.1 缓冲区和顶点属性

想要绘制一个对象，它的顶点数据需要被发送给顶点着色器。
通常会把顶点数据在C++端放入一个缓冲区，并把这个缓冲区和着色器中声明的顶点属性相关联。
要完成这件事，有好几个步骤，有些步骤只需要做一次，而如果是动画场景的话，有些步骤需要每帧都做一次。

只做一次的步骤：

**我们一般把这些步骤都放在init()函数里执行**

1. 创建一个缓存区
2. 将顶点数据复制到缓冲区

每帧都要做的步骤：

**我们一般把这些步骤都放在display()函数里执行**

1. 启用包含顶点数据的缓冲区
2. 将这个缓冲区和一个顶点属性相关联
3. 启用这个顶点属性
4. 使用`glDrawArrays()`绘制对象

**VBO**
顶点缓冲对象（Vertex Buffer Object，VBO）中，VBO在C++/OpenGL应用程序中被声明和实例化。一个场景可能需要很多VBO，所以常常会在init()中生成并填充若干个VBO，这样在你的程序需要绘制一个或多个VBO的时候就可以直接使用。

**VAO**
顶点数组对象（Vertex Array Object，VAO）。OpenGL的3.0版本引入了VAO，作为一种组织缓冲区的方法，让缓冲区在复杂场景中更容易操控。OpenGL要求至少创建一个VAO，对我们现在来说一个就够了。

**注意**
VAO其实就是用来管理VBO的，一个显示对象对应一个VBO，而VAO可以存储多个VBO。

```cpp
GLuint vao[1];     // OpenGL 要求这些数值以数组的形式指定
GLuint vbo[2];     
//
glGenVertexArrays(1, vao);  // 创建VAO
glBindVertexArray(vao[0]);  // 将生成的缓冲区与创建的VAO绑定，并将VAO标记为“活跃”的
glGenBuffers(2, vbo);   // 创建VBO
```

## 4.5 我们的第一个3D程序——立方体

@import "./code/Chapter_04_pipeline/Prog4_1_1_plainRedCube/main.cpp"

## 4.6 渲染一个对象的多个副本

只需要修改`void display()`函数就行了：

```cpp
void display(GLFWwindow* window, double currentTime) {
	glClear(GL_DEPTH_BUFFER_BIT);
	glClearColor(0.0, 0.0, 0.0, 1.0);
	glClear(GL_COLOR_BUFFER_BIT);

	glUseProgram(renderingProgram);

	mvLoc = glGetUniformLocation(renderingProgram, "mv_matrix");
	projLoc = glGetUniformLocation(renderingProgram, "proj_matrix");

	vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));

	glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(pMat));

	for (displayLoopi = 0; displayLoopi<24; displayLoopi++) {
		tf = currentTime + displayLoopi;
		tMat = glm::translate(glm::mat4(1.0f), glm::vec3(sin(.35f*tf)*8.0f, cos(.52f*tf)*8.0f, sin(.70f*tf)*8.0f));
		rMat = glm::rotate(glm::mat4(1.0f), 1.75f*tf, glm::vec3(0.0f, 1.0f, 0.0f));
		rMat = glm::rotate(rMat, 1.75f*tf, glm::vec3(1.0f, 0.0f, 0.0f));
		rMat = glm::rotate(rMat, 1.75f*tf, glm::vec3(0.0f, 0.0f, 1.0f));
		mMat = tMat * rMat;
		mvMat = vMat * mMat;

		glUniformMatrix4fv(mvLoc, 1, GL_FALSE, glm::value_ptr(mvMat));

		glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);
		glVertexAttribPointer(0, 3, GL_FLOAT, false, 0, 0);
		glEnableVertexAttribArray(0);

		glEnable(GL_DEPTH_TEST);
		glDepthFunc(GL_LEQUAL);

		glDrawArrays(GL_TRIANGLES, 0, 36);
	}
}
```

显然这样单纯地将display代码加入到循环里是不太方便的。

这时我们就可以引入**实例化**的机制

### 实例化

**实例化（Instancing）**提供了一种机制，可以只用一个C++/OpenGL调用就告诉显卡渲染一个对象的多个副本。这可以带来显著的性能好处，特别是当有数千甚至数百万的对象被绘制时——例如渲染在场地中的许多花朵的时候。

说白了就是，如果有多个对象需要被渲染的时候就需要用到实例化这个机制。

为了使用实例化来重复我们以前的翻滚立方体示例，我们需要将构建不同模型矩阵的计算（先前在display()中的循环内实现）移动到顶点着色器中。
由于GLSL不提供平移或旋转函数，并且我们无法从着色器内部调用GLM，因此我们需要使用程序3.1中的工具函数。
我们还需要将C++/OpenGL应用程序中的“时间因子”通过统一变量传递给顶点着色器。
我们还需要将模型和视图矩阵传递到单独的统一变量中，因为对每个立方体的模型矩阵都需要进行旋转计算。我们对代码的修改，包括C++/OpenGL应用程序中的修改以及新的顶点着色器中的修改，如程序4.2所示。

着色器代码：

顶点着色器代码
```cpp
#version 430

layout(location = 0) in vec3 position;

// 分开定义模型和视图矩阵
//uniform mat4 m_matrix;
uniform mat4 v_matrix;

uniform mat4 proj_matrix;

// 用于动画和放置立方体的时间因子
uniform float tf;	

out vec4 varyingColor;

// 矩阵变换工具函数的声明
// GLSL函数要求先声明后调用
// 我个人习惯直接把函数定义写在main函数前面
 
// 构建并返回绕X轴的旋转矩阵
mat4 buildRotateX(float rad) {
    mat4 xrot = mat4(
        1.0, 0.0, 0.0, 0.0,
        0.0, cos(rad), -sin(rad), 0.0,
        0.0, sin(rad), cos(rad), 0.0,
        0.0, 0.0, 0.0, 1.0
    );
    return xrot;
}

// 构建并返回绕Y轴的旋转矩阵
mat4 buildRotateY(float rad) {
    mat4 yrot = mat4(
        cos(rad), 0.0, sin(rad), 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sin(rad), 0.0, cos(rad), 0.0,
        0.0, 0.0, 0.0, 1.0);
    return yrot;
}

// 构建并返回绕Z轴的旋转矩阵
mat4 buildRotateZ(float rad) {
    mat4 zrot = mat4(
        cos(rad), -sin(rad), 0.0, 0.0,
        sin(rad), cos(rad), 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0);
    return zrot;

}

mat4 buildTranslate(float x, float y, float z)
{
	mat4 trans = mat4(
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		x,	 y,	  z,   1.0
	);

	return trans;
}

void main(void)
{
	gl_Position = proj_matrix * mv_matrix * vec4(position, 1.0);
	varyingColor = vec4(position, 1.0) * 0.5 + vec4(0.5, 0.5, 0.5, 0.5);
}

```

OpenGL代码：

```cpp
// 构建和变换Mat的计算被移到顶点着色器里去了
// 在C++程序里不再需要构建MV矩阵

```

## 4.7 在同一个场景中渲染多个不同的模型

要在单个场景中渲染多个模型方法有：
1. 为每个模型使用单独的缓冲区，每个模型都需要自己的模型矩阵、模型-视图矩阵，还需要为每个模型单独调用glDrawArrays()，因此我们需要修改init()和display()函数


同时包含立方体和金字塔的场景显示效果如图：

### 代码

OpenGL C++代码：
```cpp

```

glsl代码：
```cpp

```

## 4.8 矩阵堆栈

到目前为止，我们渲染的模型都是由一组顶点构成的。然而，实际上我们通常希望通过组装较小的简便模型来构建复杂的模型。

例如，可以通过分别绘制头部、身体、腿部和手臂来创建“机器人”模型，这当中每一个部件都是一个单独的模型。

以这种当时构建的对象通常称为分层模型。

构建分层模型的棘手问题在于如何跟踪所有模型-视图矩阵并确保它们完美协调——否则“机器人”可能会散成几块。

分层模型不仅可以用来构建复杂的对象，也可以用来生成复杂的场景。

例如，考虑一下我们的行星地球围绕太阳旋转的方式，以及月球围绕地球旋转的方式。这样的一个场景如图4.11[插图]所示。计算月球在太空中的实际路径可能很复杂。然而，如果我们能够组合代表两条简单圆形路径的变换——月球围绕地球旋转的路径和地球围绕太阳旋转的路径——我们就能避免直接计算月球的轨迹。

事实证明，我们可以使用矩阵堆栈轻松地完成此操作。顾名思义，矩阵堆栈是一堆变换矩阵。正如我们将看到的，矩阵堆栈使得创建和管理复杂的分层对象和场景变得容易，它使得变换可以构建在其他变换之上（或者从其他变换中被移除）。

C++标准模板库（STL）有一个名为“stack”的类，通过使用它构建mat4的堆栈，它可以相对简单直接地当作矩阵堆栈使用。正如我们将看到的，复杂场景中通常需要的许多模型、视图和模型-视图矩阵可以由单个`stack<glm::mat4>`实例替换。

我们将首先编写实例化和使用C++堆栈的基本命令，然后使用一个堆栈来构建复杂的动画场景。我们将通过以下方法使用C++堆栈类。

pop()

push()

top()

<stack>.top() *= rotate（构建旋转矩阵的参数）。

<stack>.top() *= scale（构建缩放矩阵的参数）。←---直接对堆栈顶部的矩阵应用变换。

<stack>.top() *= translate（构建平移矩阵的参数）。←---直接对堆栈顶部的矩阵应用变换。

" *= "运算符在mat4中被重载，因此它可以用于连接矩阵。因此，我们通常将它用于向矩阵堆栈顶部的矩阵添加平移、旋转等，正如我们展示出来的这些形式。

推入堆栈的第一个矩阵通常是视图矩阵。（注意：第一个被推进栈的矩阵是在最下方的。）
它上面的矩阵即后面推进去的矩阵，是复杂程度越来越高的模型-视图矩阵；
也就是说，它们应用了越来越多的模型变换。这些变换既可以直接应用，也可以先结合其他矩阵。

在我们的行星系统示例中，位于视图矩阵正上方的矩阵将是太阳的MV矩阵。（MV矩阵即 模型-视图矩阵）
在它之上的矩阵将是地球的MV矩阵，由太阳的MV矩阵的副本和应用于其之上的地球模型矩阵变换组成。
也就是说，地球的MV矩阵是通过将行星的变换结合到太阳的变换中而建立的。同样，月球的MV矩阵位于行星的MV矩阵之上，并通过将月球的模型矩阵变换应用于紧邻其下方的行星的MV矩阵来构建。

使用矩阵堆栈的display()函数通常是什么结构
1. 基本配置
   1. 实例化矩阵堆栈
2. 摄像机
   1. 将新矩阵（实例化一个空的视图矩阵）推入堆栈；将变换应用于堆栈顶部的视图矩阵
   2. 将变换应用于堆栈顶部的视图矩阵
3. 父对象
   1. 将新矩阵推入堆栈。对第一个父对象来说，它直接复制一份视图矩阵
   2. 应用变换，将父对象的模型矩阵和复制的视图矩阵结合
   3. 发送最顶层的矩阵
   4. 绘制父对象
4. 子对象
   1. 将新矩阵推入堆栈。这将是子对象的MV矩阵，最初直接复制一份父对象的MV矩阵
   2. 应用变换，将子对象的模型矩阵和复制的父MV矩阵结合
   3. 发送最顶层的矩阵（即对顶点着色器中的MV矩阵统一变量使用`glm::value_ptr()`
   4. 绘制子对象
5. 清理
   1. 将子对象的MV矩阵弹出堆栈
   2. 将父对象的MV矩阵弹出堆栈
   3. 将视图矩阵弹出堆栈

大立方体（行星）围绕太阳的旋转（如图4.13（左）所示）将影响月球的运动，因此它被推到堆栈上并在绘制月球时保持在那里。
相比之下，行星在其轴上的旋转（如图4.13（右）所示）是局部的，不会影响月亮，因此在绘制月球之前它需要被从堆栈中弹出。



## 习题

### 4.1 （项目）修改程序4.1以使用你自己设计的其他简单3D形状替换立方体。请务必在glDrawArrays()命令中正确指定顶点数。

### 4.2 （项目）在程序4.1中，在display()函数中“view”矩阵被简单地定义为摄像机位置的负数：
vMat = glm::translate(glm::mat4(1.0f), glm::vec3(-cameraX, -cameraY, -cameraZ));
将此代码替换为图3.13所示的计算实现。这将允许你通过指定摄像机位置和3个朝向轴来定位摄像机。你将发现有必要存储3.7节中描述的向量U、V、N。然后，尝试不同的摄像机视点，并观察渲染立方体的最终外观。

### 4.3 （项目）修改程序4.4以包含第二个“行星”，使用练习4.1中你自定义的3D形状。确保你的新“行星”处于与现有行星不同的轨道上，这样它们就不会发生碰撞。

### 4.4 （项目）修改程序4.4，使用“查看”函数构建“视图”矩阵（如第3.9节所述）。然后尝试将“查看”参数设置到不同的位置，例如查看太阳（在这种情况下场景应该看起来正常），查看行星或查看月球。

### 4.5 （研究）提出glCullFace(GL_FRONT_AND_BACK)的实际用途。
