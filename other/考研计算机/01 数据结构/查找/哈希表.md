# 哈希表研究

标签（空格分隔）： 数据结构

---

## 基本概念
哈希表是一种高效的查找结构，只需少量比较或不比较关键字来确定记录的存储位置。

### 哈希函数
又称为散列函数

#### 均匀哈希函数
关键字集合里任何一个关键字，经过哈希函数映射后，到地址集合里任何一个地址的概率是相等的

#### 完美哈希函数


哈希函数越均匀越好（发生冲突的概率越低）
### 冲突
不同关键字的哈希函数值可能相同

### 同义词
哈希函数值相同的关键字

## 哈希函数构造方法

### 直接定址法
直接用关键字作为哈希地址

一般使用线性函数
```c++
int hash_d(int key)
{
    return a*key+b;
    //a为缩放系数，b为平移系数
}
```

### 除留余数法
设地址区间长度为m，则

```c++
int hash_m(int key)
{
    return key % p;
}
```
注意：$p \leqslant m$

理论研究表明：
p为不大于m且最接近于m的素数，或不包括小于20的质因子的合数时，可使哈希地址尽可能地均匀分布在地址空间

### 数字分析法
分析关键字每一位的分布情况，取分布较为均匀的那一位作为哈希地址

适合位数较多，且可算出关键字每一位分布情况，
完全依赖于关键字集合


### 折叠法
将关键字分割成相同的若干部分（最后一部分位数可以较少），取各部分的叠加和为哈希函数
适用于关键字位数较多，且每一位数都分布大致均匀

```C++
int hash_s (long key)
{
    int i,j=1,qu,sum=0;
    for (i=0;i<w;i++)
        j*=10;
    while (key!=0)
    {
        qu=key %j;
        sum+=qu;
        key/=j;
    }
    return sum;
}
```

例如：设地址区间长度为10000，关键字为 40 1108 1053 0216 9891
移位叠加：
0040
1108
1053
0216
9891
累加，保留四位：2308

Z型叠加
0040
8011
1053
6120
9891
累加，保留四位：5115


### 平方取中法
先算出关键字的平方，然后根据地址区间长度m找平方中间的m位数为哈斯地址

使得不同关键字的哈希值分布较为均匀

```c++
int hash_3(int key)
{
    long temp;
    temp = key*key / m;
    if (temp >= m)
        temp -=temp / m*m;
        return temp;
}
```
## 处理冲突的方法

### 链地址法

```c
//处理冲突函数
Status Collision(ChainHashTab H, HLink &p) {
	// 求得下一个探查地址p 
	if (p && (p->next == NULL) ) {
		p = p->next;
		return SUCCESS;
	}
	else return UNSUCCESS;
}
```

### 开放定址法
当冲突时，使用探测技术在哈希表空间中找到空地址，然后插入元素

#### 线性探测法
$H' = (H(key)+i) \% m (1 \leqslant i \leqslant m-1)$

#### 二次探测法
$H' = (H(key)+d_i) \% m (1 \leqslant i \leqslant m-1)$
$d_i = 1^2,-1^2,2^2,-2^2……,k^2,-k^2 (k \leqslant m/2)$
注意：如果算出来结果为负数，则加一个地址区间长度即可


## 哈希表的实现

### 链地址哈希表

### 开放定址哈希表

## 哈希表的查找性能
装填因子：
$\alpha = 插入记录数/地址区间长度$

### 链地址法查找平均长度
$S_c = 1+ \alpha / 2$

### 线性探测法查找平均长度
$S_l = 1/2 * (1+1/(1- \alpha)) $


### 二次探测法平均查找长度
$S_r = -(1/ \alpha) * ln(1- \alpha)$












