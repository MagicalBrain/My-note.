# 图

## 1、图的基本概念

### 1.1 无向图
连通图：
如果图的任意两顶点都是连通的，就称之为连通图

连通分量：一个图里的极大连通子图

#### 1.1.1 无向图的性质

假设一个有n个顶点的无向图
最少有0条边
最多有$\frac{n(n-1)}{2}$条边

### 1.2 有向图
强连通图：
如果对于任意两顶点w和v，既有w到v，又有v到w的路径，则称之为强连通图

强连通分量：一个有向图的极大强连通子图

#### 1.2.1 有向图的性质

假设一个有n个顶点的有向图
最少有1条边
最多有$n(n-1)$条边

### 1.3 简单图

一个图满足：
1. 不存在重复的边
2. 不存在顶点到自身的边

（数据结构只讨论简单图）

#### 1.3.1 完全图（=简单完全图）

### 1.4 多重图（于简单图相对的）

若一个图满足：
1. 某两个顶点之间的边数多于1
2. 允许顶点通过同一条边和自己关联

### 1.5 子图

### 1.6 路径

**路径长度**
路径上边的数量

**回路**
路径序列中，第一个顶点与最后一顶点相同的为回路

**简单路径**
路径序列中，顶点不重复的为简单路径

**简单回路**
除第一个和最后一个之外（这个不重复就不是回路了），顶点不重复。

**距离**
两个顶点之间最短路径的长度，若没有路径，则距离为$\infty$

### 1.7 连通

一个顶点到另一个顶点有路径，则这两个顶点是**连通**的

#### 1.7.1 连通图

若**无向图**中的任意两个顶点都是连通的，则该图是**连通图**，否则是**非连通图**

**连通子图**
**无向图**中的一部分顶点是连通的，则称其及其连通的边为连通子图

#### 1.7.2 极大连通子图与极小连通子图

**极大连通子图**
无向图的**极大连通子图**称为**连通分量**
（极大表示不能再加结点了）

**极小连通子图**
保持连通，**边数最少**的子图（极小表示再加一条边就会有回路，即不能再加边）

**总结：**
在非连通图里才需要找极大连通子图，没有极小连通子图（极小连通子图要求包含所有顶点且顶点是连通的）
在连通图或者某个非连通图的极大连通子图里才需要找极小连通子图

### 1.8 强连通

**有向图**中，顶点a到顶点b，顶点b到顶点a都有路径，称这两点是**强连通**的

#### 1.8.1 强连通图

**有向图**中，任意两顶点之间都有路径到达，称这两点是**强连通**的
类比连通图

### 1.9 生成树

包含图中**所有顶点**的极小连通子图

1. 顶点数为n，$\Rightarrow$ 边为n-1条
2. 去掉一条边$\Rightarrow$ 非连通图
3. 加一条边 $\Rightarrow$ 回路

### 1.10 无向图中顶点的度

由于无向图中的边没有方向，故顶点的度为分支的个数

### 1.11 有向图中顶点的度

#### 1.11.1 入度

由顶点向内的分支的个数为入度

#### 1.11.2 出度

由顶点向外的分支的个数为出度

### 1.12 有向树

一个顶点的入度为0，其余顶点的入度为1的有向图

### 1.13 边的权

**带权图**=**网**

### 1.14 稠密图与稀疏图

## 2、图的存储结构
### 邻接矩阵

设有顶点数组：
$$G.vex = \{A,B,C,D\}$$

根据关系数组（关系矩阵）来分析图
无向无权图：
$$\begin{bmatrix}
0 & 1 & 1 & 1\\
1 & 0 & 0 & 0\\
1 & 0 & 0 & 1\\
1 & 0 & 1 & 1
\end{bmatrix}$$

矩阵性质：
假设顶点在顶点数组里对应的下标为i
1、第i行的不为0的元素个数即为该顶点的出度
2、第i列的不为0的元素个数即为该顶点的出度
3、所有元素关于矩阵的主对角线对称

有向无权图：
$$\begin{bmatrix}
0 & 1 & 1 & 1\\
1 & 0 & 0 & 0\\
1 & 0 & 0 & 1\\
1 & 0 & 0 & 1
\end{bmatrix}$$

矩阵性质：
假设顶点在顶点数组里对应的下标为i
1、第i行的不为0的元素个数即为该顶点的出度
2、第i列的不为0的元素个数即为该顶点的出度

无向带权图：
Inf即为无穷大，在计算机里面为该类型的最大值
$$\begin{bmatrix}
Inf & 1 & 1 & 1\\
1 & Inf & Inf & Inf\\
1 & Inf & Inf & 1\\
1 & Inf & 1 & 1
\end{bmatrix}$$

矩阵性质：
假设顶点在顶点数组里对应的下标为i
1、第i行的不为0的元素个数即为该顶点的出度
2、第i列的不为0的元素个数即为该顶点的出度
3、所有元素关于矩阵的主对角线对称

有向带权图：
$$\begin{bmatrix}
Inf & 1 & 1 & 1\\
1 & Inf & Inf & Inf\\
1 & Inf & Inf & 1\\
1 & Inf & Inf & 1
\end{bmatrix}$$

矩阵性质：
假设顶点在顶点数组里对应的下标为i
1、第i行的不为Inf的元素个数即为该顶点的出度
2、第i列的不为Inf的元素个数即为该顶点的出度

### 邻接表

性质：
假设顶点在顶点数组里对应的下标为i
1、第i个链表里的结点数为该节点的出度
2、整个邻接链表里数据域等于第i个结点的结点的个数为入度

## 3、图的遍历

### 遍历中的基本操作

#### 访问第一个弧结点

#### 访问下一个弧结点

```c
//邻接矩阵的实现
/*
取邻接矩阵中，顶点x的邻接顶点y的下一个邻接顶点
*/
int NextNeighbor (MGraph &G ,int x int y )
{
	if (x != -1 && y != -1)
	{
		for (int col = y + 1; col < G.vexnum ;col++)
			if ( G.Edge[x][col] > 0 && G.Edge[x][col] < maxWeight)
				return col ; //maxWeight
	}
	return -1;
}

//邻接表的实现
/*
取邻接表中，顶点x的邻接顶点y的下一个邻接顶点
*/
int NextNeighbor (ALGraph &G ,int x , int y )
{
	if (x != -1)
	{
		ArcNode *p = G.vertices[x].first;
		while (p != NULL && p->data != y)
			p =p->next;
		if (p != NULL && p->next != NULL)
			return p ->next->data;
}
```

### 深度优先遍历
类似于树的先序遍历

```c++
Status DFS(MGraph G,int k,Status (*visit)(int))
{
    int i;
    if (ERROR == visit(k))
        return ERROR;
    G.tags[k] = VISITED;
    
}
```

```c
bool visited [ MAXVERTEX NUM ]; // 
void DFSTraverse (Graph G )
{
//( ) 
	for (v=0;v<G.vexnum;++v)
		visited.[v]=FALSE;
	for (v=0;v<G.vexnum;++v)
		if (!visited[v])
			DFS (G,v);
}

void DFS (GraphG ,int v ){
// , G 
{
	visit (v);
/ /v
	visited [v]=TRUE;
	for (w=FirstNeighbor( G,v ); w >=0; w =NextNeighor(G,v ,))
		 if (!visited[w])
		{
			/ /wu 
			DFS (G,w);
		}//if
}
```

### 广度优先遍历

伪代码：
```c
bool visited[MAX_VERTEX_NUM];

void BFSTraverse(Graph G)
{
	for (int i =0;i<G.vexnum;++i)
		visited[i] = false;
	InitQueue(Q);
	for (int i=0;i<G.vexnum;++i)
		if (!visited[i])
			BFS(G,i);
}

void BFS(Graph G,int v)
{
	visit(v);
	visited[v]=TRUE;
	Enqueue(Q,v);
	while(!isEmpty(Q))
	{
		Dequeue(Q,v);
		for (w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
			if (!visited[w])
			{
				visit(w);
				visited[w]=TRUE;
				Enqueue(Q,w);
			}
	}
}
```

## 4、最小生成树
### 普里姆算法
选最小边

### 克鲁斯卡尔算法
在选最小边的基础上，还要判断是否会产生回路


## 5、拓扑排序

### 5.1 AOV网
活动在顶点上的网（Activity On Vertex network，AOV）
是一种可以形象地反映出整个工程中各个活动之间的先后关系的有向图。

考试中，只要知道AOV网是一种以顶点表示活动、以边表示活动的先后次序且没有回路的有向图即可。因为AOV网有实际意义，所以出现回路就代表一项活动以自己为前提，这显然违背实际。

**顶点有权值且无回路的有向图**

## 6、关键路径

对于活动在边上的网（ Activity On Edge network，AOE）

### 6.1 AOV与AOE比较

**两者的相同点:** 都是有向无环图。

**两者的不同点:** 
AOE网的边表示活动，边有权值，边代表活动持续时间；顶点表示事件，事件是图中新活动开始或者旧活动结束的标志。
AOV网的顶点表示活动，边无权值，边代表活动之间的先后关系。

**源点**
对于一个表示工程的AOE网，只存在一个入度为0的顶点，表示整个工程的开始；

**汇点**
也只存在一个出度为0的顶点，表示整个工程的结束。

