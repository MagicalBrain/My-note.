# 5.1 图的基本概念

## 图的定义

## 无向图

## 有向图

## 简单图

一个图满足：
1. 不存在重复的边
2. 不存在顶点到自身的边

（数据结构只讨论简单图）

## 多重图（于简单图相对的）

若一个图满足：
1. 某两个顶点之间的边数多于1
2. 允许顶点通过同一条边和自己关联

## 完全图（=简单完全图）

## 子图

## 路径

**路径长度**

**回路**

**简单路径**

顶点不重复

**简单回路**

除第一个和最后一个之外（这个不重复就不是回路了），顶点不重复

## 距离

两个顶点之间最短路径的长度，若没有路径，则距离为$\infty$

## 连通

一个顶点到另一个顶点有路径，则这两个顶点时**连通**的

### 连通图

若**无向图**中的任意两个顶点都是连通的，则该图是**连通图**，否则是**非连通图**

### 连通子图

**无向图**中的一部分顶点是连通的，则称其及其连通的边为连通子图

#### 极大连通子图与连通分量

无向图的**极大连通子图**称为**连通分量**
包含其**所有边**的连通子图

#### 极小连通子图

保持连通，**边数最少**的子图

## 强连通

**有向图**中，顶点a到顶点b，顶点b到顶点a都有路径，称这两点是**强连通**的

### 强连通图

类比连通图

## 生成树

包含图中**所有顶点**的极小连通子图

1. 顶点数为n，$\Rightarrow$ 边为n-1条
2. 去掉一条边$\Rightarrow$ 非连通图
3. 加一条边 $\Rightarrow$ 回路

## 无向图中顶点的度

## 有向图中顶点的度

### 入度

### 出度

## 有向树

一个顶点的入度为0，其余顶点的入度为1的有向图

## 边的权

**带权图**=**网**

## 稠密图与稀疏图

# 5.2 图的存储及其基本操作

## 邻接矩阵

是图的**顺序存储结构**

### 存储结构定义：

```c

```

### 邻接矩阵存储法的特点：

1. 对于无向图，邻接矩阵一定是对称的
2. 对于无向图第i行或第i列的元素和为顶点i的度数
3. 对于有向图，第i行或第i列，对应的是顶点i的入度或出度
4. 邻接矩阵法易确定两顶点之间是否有边相连，但找出图中所有的边需要遍历所有的顶点进行判断
5. 稠密图适合有邻接矩阵来表示
6. 对于图G的邻接矩阵A，$A^n$的$A[i][j]$的值为顶点i到顶点j的长度为n的路径数量

## 邻接表

是图的**链式存储结构**

### 存储结构定义

### 邻接表的特点：

1. 对于无向图，所需的存储空间为$O(|V|+2|E|)$
2. 对于有向图，所需的存储空间为$O(|V|+|E|)$
3. 对于稀疏图，使用邻接表会节省存储空间
4. 对于有向图，求一个顶点的出度，只需计算其邻接表的结点个数即可，但求入度则需要遍历所有邻接表的顶点，所以又有逆邻接表（与邻接表类似）
5. 图的邻接表并不唯一，各边上的结点链接次序是任意的，取决于建立邻接表的算法及边的输入顺序

## 十字链表

是专门针对**有向图**的**链式**存储结构

### 十字链表的存储结构定义：

## 邻接多重表

是**无向图**的另外一种**链式**存储结构

### 邻接多重表的存储结构的定义：

## 图的基本操作

1、判断是否存在边$<x,y>$

2、求与x邻接的边

3、在图中插入顶点x

# 5.3 图的遍历

图的遍历主要有两种算法：
1. 广度优先搜索算法
2. 深度优先搜索算法

几乎所有的图的遍历算法都可以抽象为**优先级搜索**和**最佳优先搜索**

## 广度优先搜索（BFS）

(Breadth-First-Search)

**不可使用递归**

**基本思想**：
与二叉树的层次遍历类似

**代码实现**：

```c

```

### 性能分析

**顶点入队**：
无论是邻接表还是邻接矩阵，都需借助一个辅助队列，n个顶点的入对为$O(n)$

**搜索顶点**：
邻接表：搜索顶点：$O(n) = O(|V|)$,搜索任意顶点的相邻点：$O(|E|)$,总时间复杂度：$O(|V|+|E|)$

邻接矩阵：搜索顶点：$O(|V|)$,搜索任意顶点的相邻顶点：$O(|V|)$,总时间复杂度：$O(|V|^2)$ 

### 求解单源最短路径问题

若图为非带权图，定义从顶点u到顶点v的最短路径$d(u,v)$为从u到v的任何路径中最少的边数，若没有路径则值为$\infty$

### 广度优先树

在广度遍历的时候可以得到一棵遍历树，即为**广度优先生成树**

一个图的**邻接矩阵**的表示唯一故，广度优先生成树**唯一**

**邻接表**表示不唯一，则广度优先生成树**不唯一**

## 深度优先搜索（DFS）

(Depth-First-Search）

**可使用递归**

**基本思想**：
类似于二叉树的先序遍历

**代码实现**：

### 性能分析

### 深度优先生成树和生成森林

## 图的遍历与图的连通性

### 验证无向图的连通性

若**连通**，则**任意顶点出发**仅需**一次遍历**就能访问所有顶点
反之则只能访问初始顶点所在的**连通分量**的所有顶点

### 验证有向图的连通性

连通也不一定就能一次遍历所有顶点，因为连通分为
1. 强连通
2. 非强连通

若**强连通**，则**任意顶点出发**仅需**一次遍历**就能访问所有顶点
若**非强连通**，一次遍历是不行的
反之则只能访问初始顶点所在的**连通分量**的所有顶点

# 5.4 图的基本应用

## 最小生成树

**生成树**是图的极小连通子图

**最小生成树**是**边的权值最小**的生成树

相比于**广度优先遍历**在**边没有权值或者边的权值相同**情况下找最短路径，**最小生成树**则是在**边有任意权值**的情况下找最短路径

### 最小生成树的性质

1. 不唯一，形状不唯一（**只有在任意边的权值都不同时才唯一**）
2. 最小生成树的边数为顶点数减一，若无向连通图的边数比顶点数小一，则其本身为最小生成树
3. 最小生成树的权值（边的权值）和唯一

### 构造最小生成树的算法

#### Prim算法

**基本步骤**：
1. 找出起始点的最短邻边
2. 已经找出的边所连着的顶点的相邻边里再找最短边（前提是不能构成回路）
3. 直到所有顶点都被访问了

**时间复杂度**：$O(|V|^2)$

适用于求解边稠密的图

#### Kruskal算法

**基本步骤**：
1. 在所有的边里找出最短边
2. 在剩下的边里再找最短（前提是不能构成回路）
3. 直到所有顶点都被访问了

**时间复杂度**：$O(|E|\log(|E|))$

一般用用**堆**这一数据结构来存放边的集合
可以采用**并查集**的数据结构来描述这个算法构造的最小生成树，所有被添加到树里的边都是**等价类**


**两种算法都是基于贪心策略的**

## 最短路径

最短路径问题分为两类：
1. 单源最短路径问题
2. 顶点间最短路金问题

### 利用Dijikatra算法来解单源最短路径问题



### 利用Floyd算法解格顶点间最短路径问题

## 拓扑排序

**有向无环图（DAG）**：
没有环的有向图

**AOV网（Activity-On-Vector）**
若用DAG表示一个工程、流程，其顶点表示活动，边表示各顶点之间的前驱后继关系

**拓扑排序**：
一个由有向无环图顶点组成的一个序列
1. 包含的顶点不能重复
2. 若A在B前，则没有B到A的路径

**拓扑排序的常用算法**：
1. 找一个没有前驱的顶点作为起始点
2. 删除这个点和以这个点为起点的所有边，重复1的操作循环
3. 直到图里的点都被删了或找不到没有前驱的顶点

**时间复杂度**：$O(|V|+|E|)$

可以使用**深度优先遍历**来实现

**顶点的后继不唯一，拓扑序列可能不唯一**
**每个顶点的后继只有一个，则拓扑序列唯一**
**邻接矩阵是三角阵，则存在拓扑序列，反之不一定**

## 关键路径

**AOE网(Activity-On-Edge)**：
以顶点表示事件，边的权值表示事件的开销（比如时间）

**AOE网的性质**：
1. 只有在某顶点所代表的事件发生后，从该顶点出发的有向边指向的顶点（活动）才能开始
2. 仅有一个入度为0的顶点（**开始顶点、源点**）和出度为0的顶点（**结束顶点、汇点**）

**关键路径**：
从源点到汇点所有路径中，最长的为**关键路径**

**关键活动**：
关键路径上的活动

