# 2.3 进程同步

## 基本概念

进程同步的目的是因为操作系统具有异步性，如果不同步，那么进程之间的制约关系就无法保持和协调。

临界资源：
1. 同一时间段可供多个进程使用
2. 一次只能为一份进程提供服务

可重入代码：
1. 可以在任意时刻共享给多个进程
2. 不允许任何修改的代码

## **同步**：
“讲究个先来后到”

## **互斥**：
”占地盘“

### **互斥原则（四条）**
1. 空闲让进
2. 忙则等待
3. 有限等待
4. 让权等待

### 实现互斥的方法

#### 软件（4种）

##### 1、单标志法

```c
int turn=0;

void P0()
{
    while(true)
    {
        while(turn!=0);
        //临界区：
        trun=1;
    }
    
}

void P1()
{
    while(true)
    {
        while(turn!=1);
        //临界区：
        trun=0;
    }
    
}
```

**缺点：**
两个进程必须交替进入临界区，若某个进程不再进入，另一进程则无法进入，违背**空闲让进**原则，导致资源利用不充分。

##### 2、双标志先检查算法

```c
void Pi()
{
    while(true)
    {
        while(flag[j]);
        flag[i]=true;

        //临界区：
        flag[i]=false;
    }
}

void Pj()
{
    while(true)
    {
        while(flag[i]);
        flag[j]=true;

        //临界区：
        flag[j]=false;
    }
}
```

**优点：**
不用交替进入，可连续使用

**缺点：**
Pi和Pj可能同时进入临界区
（问题出在检查和修改操作不能一次完成）

##### 3、双标志后检查算法

```c
void Pi()
{
    while(true)
    {
        flag[i]=true;
        while(flag[j]);

        //临界区：
        flag[i]=false;
    }
}

void Pj()
{
    while(true)
    {
        flag[j]=true;
        while(flag[i]);

        //临界区：
        flag[j]=false;
    }
}
```

**缺点：**
会导致饥饿现象

##### 4、Peterson算法

为防止两个进程进入临界区而无限等待，设置了变量turn

每个变量在先设置自己的标志后再设置turn。

再同时检查另一进程状态标志和不允许进入标志

C语言实现：
```c
void Pi()
{
    while(true)
    {
        flag[i]=true;
        turn=i;
        while(flag[i]&&(turn==i));

        //临界区：
        flag[i]=false;
    }
}

void Pj()
{
    while(true)
    {
        flag[j]=true;
        turn=j;
        while(flag[j]&&(turn==j));

        //临界区：
        flag[j]=false;
    }
}
```

用flag数组解决互斥进入临界区的问题
**优点：**
利用turn解决饥饿问题

手动模拟：
1、
```c
flag[i]=true;
flag[j]=true;
turn=i;
turn=j;
```
Pj自我堵塞，Pi进入临界区

2、
```c
flag[i]=true;
flag[j]=true;
turn=j;
turn=i;
```
Pi自我堵塞，Pj进入临界区

3、
```c
flag[i]=true;
turn=i;
flag[j]=true;
turn=j;
```
Pj自我堵塞，Pi进入临界区

4、
```c
flag[j]=true;
turn=j;
flag[i]=true;
turn=i;
```
Pi自我堵塞，Pj进入临界区

该算法大致分为以上情形，可见其可以使进程互斥地进入临界区。

#### 硬件（3种）

通过硬件支持实现临界区问题的方法称为**低级方法**，或**元方法**

##### 1、中断屏蔽方法

##### 2、硬件指令方法

**TestAndSet指令：**
原子操作，不允许被中断

功能：读出指定标志后设置为真

```c
boolean TestAndSet(boolean *lock)
{
    boolean old;
    old=*lock;
    *lock=true;
    return old;
}
```

进程在进入临界区前利用该指令反复检查，直到临界区里的进程退出。

实现进程互斥算法代码：
```c
while(TestAndSet(&lock));
//进程的临界区代码段
lock=false;
//进程的其他代码
```

**Swap指令：**
Swap = Exchange = XCHG 指令

功能：交换两个字的内容

```c
Swap(boolean *a, boolean *b)
{
    boolean temp;
    temp =*a;
    *a=*b;
    *b=temp;
}
```

实现互斥的代码如下：

```c
key =true;
while(key!=false)
    Swap(&lock,&key);
//进程的临界代码段
lock=false;
//进程的其他代码
```

**硬件方法的优点：**
1. 简单，易验证
2. 可支持多个临界区

**硬件方法的缺点：**
1. 进程等待进入处理机需耗费处理机的时间，不能实现**让权等待**
2. 可能会导致饥饿

## 信号量

可用来解决互斥与同步问题

### PV操作

这是两个原子操作（原语），且不可被中断

### 整型信号量

### 记录型信号量

## 管程

### 管程的定义

管程是又一组数据即定义在这组数据之上的对这组数据的操作组成的软件模块。

可类比面向对象编程的类

管程是由编程语言支持的进程同步机制

### 管程的组成

1. 局部共享数据说明（类的共有数据成员）
2. 数据结构的操作的一组过程
3. 对管程共享数据设置初始值的语句

### 管程的基本特性

1. 局部于管程的数据只能被局部于管程内的过程所访问
2. 一个进程只有通过管程内的过程才能进入管程访问共享数据
3. 每次仅允许一个进程在管程内执行某个内部过程


@import "./2.3 经典同步问题.md"
