# 灰度图（2D）和深度图（3D）结合进行物体识别

[toc]

# 目前的思路

先弄个简单的：
先在2D图里抠出被识别的物体，然后去3D图里获取质心的坐标。

这个简单的思路会导致一个问题：
如果有多个物体，那么获取质心的时候，这多个物体会被当成一个整体。这样获取的质心是这由多个物体组成的整体的质心，而不是单个物体的质心，这样的质心是没有意义的，无法进行抓取的。

完善了一下思路：
1. 先在2D图里抠出被识别的物体；
2. 去3D图里获取被识别出来的物体其所包含的所有点的坐标加入到点云
3. 对识别出来的物体的点云进行分割
4. 计算分割出来的物体的质心的坐标。

## 一、2D抠图的流程

2D的处理主要使用opencv。

### 1、图像形态学处理

包括：腐蚀（erode）、膨胀、开关、顶帽底帽操作等。

### 2、边缘检测

目前使用的是Canny算法来检测边缘

### 3、提取轮廓并处理

`findcontours`

实际上提取出来的轮廓可能会有许多问题，例如：
1. 有多余的轮廓干扰
2. 提取出来的轮廓不是闭合的，处理效果不好

#### 多余轮廓的筛选

目前是用轮廓的长度来进行筛选。

#### 处理非闭合的轮廓

目前由两种方法：
1. 在提取轮廓之前对图像进行 膨胀操作（dilate）
2. 把轮廓画粗一点
3. 根据需要被识别的物体形状对轮廓进行多边形拟合。

但实际上选用哪个方法还需要具体问题具体分析。

##### 膨胀操作

尝试之后发现几乎没啥用，因为这部操作会将多个挨在一起的轮廓合并成一个轮廓

##### 画粗轮廓

简单粗暴，效果并不是很好。

##### 轮廓拟合

尝试进行轮廓多边形拟合，因为目前此算法识别的对象都是比较规则的物体。

**木块拆垛码垛**：

矩形拟合：
1. 通过`cv::minAreaRect()`找到最小矩形的四个角点
2. 给这四个角点连线（计算点的坐标并加进contours里）
3. 接下面的寻找最大连通图

目前来说用处不大，仅仅适合表面没有纹理的物体，否则纹理轮廓拟合出来的矩形会干扰到后面的最大连通区域生成。

**圆柱紧贴竖放**

*外接圆拟合*：

1. 通过`cv::minEnclosingCircle()`获得

### 画出

`drawcontours`


### 寻找最大连通图

`connectedComponentsWithStats`

## 3D处理流程

去到深度图获取点的坐标

### 点云分割

区域生长分割出来后常常会把多个木块看作一个，也就是说效果不是太好。

如果2D部分搞好的话，下一步试试LCCP

### 计算质心
